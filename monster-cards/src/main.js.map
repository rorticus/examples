{"version":3,"sources":["webpack:///src/main.js","webpack:///webpack/bootstrap 6cc1f563352f1376ce5c","webpack:///./src/main.ts","webpack:///./src/routes.ts","webpack:///node_modules/dojo-routing/createRoute.ts","webpack:///node_modules/dojo-compose/compose.ts","webpack:///node_modules/dojo-core/instrument.ts","webpack:///node_modules/dojo-core/has.ts","webpack:///node_modules/dojo-core/global.ts","webpack:///node_modules/dojo-shim/support/has.ts","webpack:///node_modules/dojo-shim/support/global.ts","webpack:///node_modules/dojo-has/has.ts","webpack:///./~/process/browser.js","webpack:///node_modules/dojo-core/lang.ts","webpack:///node_modules/dojo-shim/array.ts","webpack:///node_modules/dojo-shim/support/util.ts","webpack:///node_modules/dojo-shim/iterator.ts","webpack:///node_modules/dojo-shim/string.ts","webpack:///node_modules/dojo-shim/Symbol.ts","webpack:///node_modules/dojo-shim/number.ts","webpack:///node_modules/dojo-shim/WeakMap.ts","webpack:///node_modules/dojo-shim/support/decorators.ts","webpack:///node_modules/dojo-compose/aspect.ts","webpack:///node_modules/dojo-core/UrlSearchParams.ts","webpack:///node_modules/dojo-routing/createRouter.ts","webpack:///node_modules/dojo-compose/mixins/createEvented.ts","webpack:///node_modules/dojo-core/aspect.ts","webpack:///node_modules/dojo-shim/Map.ts","webpack:///node_modules/dojo-shim/object.ts","webpack:///node_modules/dojo-compose/mixins/createDestroyable.ts","webpack:///node_modules/dojo-shim/Promise.ts","webpack:///node_modules/dojo-shim/support/queue.ts","webpack:///./~/timers-browserify/main.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///node_modules/dojo-core/async/Task.ts","webpack:///node_modules/dojo-core/async/ExtensiblePromise.ts","webpack:///node_modules/dojo-core/on.ts","webpack:///node_modules/dojo-routing/lib/path.ts","webpack:///node_modules/dojo-routing/history/createHashHistory.ts","webpack:///./src/actions/routeActions.ts","webpack:///node_modules/dojo-actions/createAction.ts","webpack:///node_modules/dojo-compose/mixins/createStateful.ts","webpack:///node_modules/dojo-compose/util/createCancelableEvent.ts","webpack:///./src/stores/widgetStore.ts","webpack:///node_modules/dojo-stores/createMemoryStore.ts","webpack:///./~/immutable/dist/immutable.js","webpack:///./~/@reactivex/rxjs/dist/amd/Observable.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/root.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/@reactivex/rxjs/dist/amd/symbol/observable.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/toSubscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/Subscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isFunction.js","webpack:///./~/@reactivex/rxjs/dist/amd/Subscription.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isArray.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isObject.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/tryCatch.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/errorObject.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/UnsubscriptionError.js","webpack:///./~/@reactivex/rxjs/dist/amd/symbol/rxSubscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/Observer.js","webpack:///./src/stores/cardStore.ts","webpack:///./src/actions/widgetStoreActions.ts","webpack:///./src/app.ts","webpack:///node_modules/dojo-widgets/d.ts","webpack:///./~/maquette/dist/maquette.js","webpack:///node_modules/dojo-widgets/FactoryRegistry.ts","webpack:///node_modules/dojo-widgets/createProjector.ts","webpack:///node_modules/dojo-widgets/createWidgetBase.ts","webpack:///node_modules/dojo-compose/bases/createStateful.ts","webpack:///node_modules/dojo-compose/bases/createEvented.ts","webpack:///node_modules/dojo-widgets/mixins/createVNodeEvented.ts","webpack:///node_modules/dojo-shim/Set.ts","webpack:///./src/widgets/navbar/createNavbar.ts","webpack:///./src/widgets/common/createSearchInput.ts","webpack:///./src/widgets/home/createHomePage.ts","webpack:///node_modules/dojo-widgets/mixins/createCssTransitionMixin.ts","webpack:///./src/widgets/card-details/createCardDetailsPage.ts","webpack:///./src/widgets/card-details/createCardDescription.ts","webpack:///./src/widgets/card-details/createCardNavBar.ts","webpack:///./src/widgets/card/createCard.ts","webpack:///./src/widgets/card-details/createSeenWith.ts","webpack:///./src/widgets/cards/createCardsPage.ts","webpack:///./src/widgets/cards/createCardsList.ts","webpack:///./src/widgets/card/createCardSummary.ts","webpack:///./src/widgets/gameplay/createGameplayPage.ts","webpack:///./src/widgets/about/createAboutPage.ts","webpack:///./~/maquette/src/css-transitions.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","this","concat","routes_1","cardStore_1","widgetStore_1","app_1","root","document","getElementsByTagName","app","default","stateFrom","cssTransitions","append","then","bindActions","start","createRoute_1","createRouter_1","createHashHistory_1","routeActions_1","cardDetailRoute","path","exec","request","params","gotoCardDetails","do","cardsRoute","gotoCards","homeRoute","gotoHome","aboutRoute","gotoAbout","gameplayRoute","gotoGameplay","history","router","defineProperty","value","computeDefaultParams","parameters","searchParameters","fromPathname","searchParams","forEach","name","index","get","undefined","compose_1","UrlSearchParams_1","WeakMap_1","path_1","privateStateMap","parentMap","noop","createRoute","parent","add","_this","routes","route","hasBeenAppended","Error","push","set","Array","isArray","_i","add_1","length","match","segments","hasTrailingSlash","_a","computeParams","trailingSlashMustMatch","result","hasRemaining","trailingSlash","knownSearchParams","reduce","list","getAll","values","offset","rawPathValues","rawSearchParams","select","context","fallback","guard","matchResult","guardResult","redirect","remainingSelection","handler","selected","remainingSegments_1","some","nested","nestedResult","selection","instance","_b","_c","test","TypeError","deconstructedPath","deconstruct","missingMethod","method","assignFactoryName","factory","assignFunctionName","Symbol_1","toStringTag","configurable","nameDescriptor","getOwnPropertyDescriptor","writable","assignProperties","overwrite","target","sources","arguments","source","defineProperties","getOwnPropertyNames","descriptors","key","sourceDescriptor","sourceValue","targetDescriptor","targetValue","current","array_1","includes","from","objectCreate","rebase","getInitFunctionNames","initFns","privateFactoryData","map","factoryDescriptor","mixin","className","assignAdviceMap","createPrivateFactoryData","optionsAdvice","advice","factories","initFunction","proto","staticProperties","factoryData","base","optionsInitFns","initFn","lang_1","assign","Boolean","createFactory","options","constructor","SyntaxError","unshift","factoryPrototype","_loop_1","aspect","sourceMethod","aspect_1","before","after","around","staticMethods","DEFAULT_FACTORY_LABEL","freeze","isComposeFactory","extend","extension","instrument_1","deprecated","message","override","baseFactory","properties","keys","overlay","overlayFunction","aspectAdviceToAdviceMap","aspectAdvice","mapAdvice","type","adviceTuple","adviceMap","beforeAdvice","afterAdvice","aroundAdvice","objectKeys","isComposeMixinable","toMixin","mixinDescriptor","initialize","doFrom","doBefore","doAfter","doAround","create","_static","doExtend","doMixin","doOverride","doOverlay","doAspect","doStatic","doFactoryDescriptor","static","compose","warn","url","has_1","DEFAULT_DEPRECATED_MESSAGE","warning","globalWarn","console","deprecatedAdvice","deprecatedDecorator","propertyKey","descriptor","originalFn_1","setWarn","__export","global_1","requestAnimationFrame","ArrayBuffer","FormData","XMLHttpRequest","open","responseType","abort","global","globalObject","window","self","has_2","Symbol","fill","Number","POSITIVE_INFINITY","getCallSite","callSite","substitutions","String","raw","supportsTrunc","Math","acosh","clz32","imul","Promise","Observable","Set","has","Map","entries","e","WeakMap","key1","key2","setImmediate","postMessage","MutationObserver","WebKitMutationObserver","Function","process","isStaticFeatureFunction","load","resourceId","require","config","normalize","skip","term","tokens","exists","feature","staticCache","testCache","testFunctions","globalScope","staticFeatures","DojoHasEnvironment","location","versions","node","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","argv","version","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","shouldDeepCopyObject","toString","copyArray","inherited","item","_mixin","deep","kwArgs","mixins","RangeError","deepAssign","deepMixin","duplicate","getPrototypeOf","isIdentical","lateBind","suppliedArgs","partial","targetFunction","createHandle","destructor","destroy","createCompositeHandle","handles","handles_1","handle","toLength","isNaN","isFinite","floor","min","max","number_1","MAX_SAFE_INTEGER","toInteger","abs","normalizeOffset","Shim","util_1","iterator_1","arrayLike","mapFunction","thisArg","bind","Constructor","isArrayLike","isIterable","forOf","of","items","copyWithin","end","count","direction","find","callback","findIndex","searchElement","fromIndex","currentElement","wrapNative","getValueDescriptor","enumerable","nativeFunction","iterator","iterable","ShimIterator","doBreak","broken","next","done","l","char","code","charCodeAt","string_1","HIGH_SURROGATE_MIN","HIGH_SURROGATE_MAX","staticDone","_nextIndex","_nativeIterator","_list","LOW_SURROGATE_MIN","LOW_SURROGATE_MAX","normalizeSubstringArgs","text","search","position","isEnd","rawStrings","numSubstitutions","length_1","fromCodePoint","codePoints","fromCharCode","MAX_SIZE","codeUnits","codePoint","isValid","highSurrogate","lowSurrogate","codePointAt","first","second","repeat","Infinity","startsWith","endsWith","endPosition","indexOf","padEnd","maxLength","fillString","strText","padding","padStart","isSymbol","validateSymbol","InternalSymbol","objPrototype","globalSymbols","getSymbolName","created","desc","postfix","description","sym","__description__","__name__","keyFor","hasInstance","for","isConcatSpreadable","observable","replace","species","split","toPrimitive","unscopables","valueOf","Exposed","SymbolShim","wellKnown","isInteger","isSafeInteger","EPSILON","pow","MIN_SAFE_INTEGER","__decorate","decorators","d","r","Reflect","decorate","decorators_1","getUID","random","DELETED","generateName","startId","Date","now","_frozenEntries","_getFrozenEntryIndex","delete","entry","_name","frozenIndex","splice","isFrozen","hasClass","trueClass","falseClass","getDispatcher","joinPoint","dispatcher","dispatchAdviceMap","previousArgs","currentArgs","previousResult","before_1","after_1","advise","AdviceType","Around","Before","After","parseQueryString","input","query","indexOfFirstEquals","decodeURIComponent","UrlSearchParams","encodedKey","encodeURIComponent","values_1","join","createDeferral","cancel","resume","promise","Promise_1","resolve","reject","reportError","error","catchRejection","thenable","catch","createEvented_1","Task_1","on_1","createRouter","dispatch","state","dispatchFromStart","canceled","deferrals","defer","success","parse","all","dispatched","currentSelection","result_1","link","roots","hierarchy","parent_1","addLeadingSlash","leadingSlash","addTrailingSlash","currentPathValues","currentSearchParams","expectedSegments","namedOffset","expectedSegments_1","segment","isNamedSegment","literal","searchParameters_1","value_1","_d","_e","pathname","prefix","dispatchCurrent","started","contextFactory","pause","lastDispatch","redirectCount","redirecting","listener","pausable","event","own","sharedContext_1","isActionable","resolveListener","handlesArraytoHandle","Map_1","createDestroyable_1","listenersMap","createEvented","listenerMap","type_1","listeners","listenerMapArg_1","isMapLike","receiveArguments","previous","advised","nextId","methodName","existing","results","executionId","newResults","object_1","_keys","_values","_indexOfKey","is","clear","length_2","getOwnPropertyDescriptorsWrapper","o","getOwnPropertySymbols","value1","value2","filter","substring","symbolAwareKeys","prop","hasGetOwnPropertySymbols","getOwnPropertyDescriptors","destroyed","isDestroyable","handlesWeakMap","createDestroyable","queue_1","isThenable","executor","isChained","isResolved","callbacks","whenFinished","settle","newState","resolvedValue","queueMicroTask","onFulfilled","onRejected","fulfill","complete","finish","populating","total","processItem","race","reason","clearImmediate","executeTask","isActive","getQueueHandle","microTasks","microTaskQueued","checkMicroTaskQueue","queueTask","enqueue","addEventListener","data","stopPropagation","shift","HostMutationObserver","node_1","createElement","queue_2","observer","observe","attributes","setAttribute","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","task","tasksByHandle","nextHandle","registerImmediate","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","attachEvent","installMessageChannelImplementation","channel","MessageChannel","port1","port2","installReadyStateChangeImplementation","html","doc","documentElement","script","onreadystatechange","removeChild","appendChild","installSetTimeoutImplementation","attachTo","isTask","children","__extends","__","ExtensiblePromise_1","Task","_super","canceler","superResolve","superReject","_state","_cancel","finallyTask","runFinally","_finally","child","finally","unwrapPromises","unwrapped","ExtensiblePromise","_promise","rejected","valueOrError","dispatchEvent","ownerDocument","createEvent","nativeEvent","initEvent","bubbles","cancelable","capture","removeEventListener","paused","pathnameTokens","searchStart","hashStart","t","isMatch","expected","consume","peek","inSearchComponent","name_1","closing","separator","next_1","createHashHistory","privateState","browserLocation","hash","createAction_1","cardDescription","pickRandomCards","seenWith","patch","isAction","createStateful_1","doFunctions","configureFunctions","createAction","doFn","enabled","enable","setState","disable","configure","configuration","configureFn","unobserve","stateful","observedState","observedStateMap","statecomplete","createCancelableEvent_1","defaultPrevented","setStatefulState","stateWeakMap","createStateful","observeState","subscription","subscribe","err","unsubscribe","createCancelableEvent","preventDefault","createMemoryStore_1","sections","href","enterAnimation","exitAnimation","wrapResult","store","storeMethods","wrapError","immutable_1","Observable_1","dataWeakMap","itemObserverWeakMap","storeObserverWeakMap","createMemoryStore","idProperty","observers","observerArray","payload","puts","deletes","beforeAll","afterAll","put","size","OrderedMap","storeObservers","afterData","payload_1","completeObservable","completeStoreObservers","payload_2","fromArray","idx","createClass","ctor","superClass","Iterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","arr","newArr","ii","ensureSize","iter","__iterate","returnTrue","wrapIndex","uint32Index","NaN","wholeSlice","begin","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Iterator","iteratorValue","k","v","iteratorResult","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","object","_object","IterableSeq","_iterable","IteratorSeq","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","maybeIndexedSeqFromValue","seqIterate","reverse","useKeys","cache","_cache","maxIndex","__iterateUncached","seqIterator","__iteratorUncached","fromJS","json","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","valueA","valueB","equals","deepEqual","__hash","notAssociative","every","flipped","cacheResult","_","allEqual","bSize","NOT_SET","Repeat","times","_value","EMPTY_REPEAT","invariant","condition","Range","step","_start","_end","_step","ceil","EMPTY_RANGE","Collection","KeyedCollection","IndexedCollection","SetCollection","smi","i32","h","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","string","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","obj","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","nodeType","uniqueID","assertNotInfinite","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","prev","__prev","makeMap","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","update","isLeafNode","mergeIntoNode","newNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","mergeDeep","deepMergerWith","mergeDeepWith","nextValue","collection","x","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","newValue","nextExisting","nextUpdated","remove","popCount","setIn","val","canEdit","newArray","spliceIn","newLen","spliceOut","pop","List","empty","emptyList","isList","makeList","VNode","toArray","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","tail","left","to","right","DONE","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","groups","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","isKeyedIterable","singleton","concatSeq","flatten","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","stack","flatMapFactory","interposeFactory","interposedSequence","sortFactory","comparator","defaultComparator","sort","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","s","validateEntry","resolveSize","forceIterator","keyPath","Record","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","names","setProp","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","head","StackPrototype","_head","EMPTY_STACK","methods","keyCopier","keyMapper","entryMapper","not","neg","quoteString","JSON","stringify","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","SLICE$0","Keyed","Indexed","DELETE","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","__toString","searchValue","lastIndexOf","other","possibleIndex","offsetValue","keyValues","updateIn","deleteIn","updatedValue","merge","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","removed","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","insert","oldSize","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","union","intersect","originalSet","subtract","pushAll","toJS","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","returnValue","findEntry","sideEffect","joined","isFirst","reducer","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","flatMap","searchKey","getIn","searchKeyPath","groupBy","hasIn","isSubset","isSuperset","keyOf","last","lastKeyOf","maxBy","minBy","rest","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","chain","contains","mapEntries","mapKeys","KeyedIterablePrototype","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","Immutable","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root_1","observable_1","toSubscriber_1","_isScalar","_subscribe","lift","operator","observerOrNext","sink","toSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","PromiseCtor","Rx","subscriber","$$observable","objectTypes","boolean","function","number","freeGlobal","webpackPolyfill","deprecate","paths","Subscriber_1","rxSubscriber_1","nextOrObserver","Subscriber","$$rxSubscriber","isFunction_1","Subscription_1","Observer_1","destinationOrNext","isStopped","destination","SafeSubscriber","_next","_error","_complete","isUnsubscribed","Subscription","_parent","isFunction","_context","__tryOrSetError","__tryOrUnsub","_unsubscribe","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_subscriptions","trial","tryCatch","errorObject","sub","isObject","UnsubscriptionError","teardown","EMPTY","subscriptions","subscriptionIndex","tryCatcher","tryCatchTarget","cardStore","changeRecord","widgetStoreActions_1","putCard","getShuffledCards","cards","temp","shuffledArray","j","numberToPick","exclude","filteredCards","card","cardType","score","tagline","imageClass","favouriteCount","getStates","cardStates","cardSummaryStates","getPageFromRoute","routeDNode","d_1","w","createHomePage_1","createCardsPage_1","createCardDetailsPage_1","createGameplayPage_1","createAboutPage_1","previousRouteDNode","createProjector_1","createNavbar_1","createApp","getChildrenNodes","tagName","tag","optionsOrChildren","render","maquette_1","FactoryRegistry_1","registry","__WEBPACK_AMD_DEFINE_FACTORY__","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","overrides","same","vnode1","vnode2","vnodeSelector","toTextVNode","domNode","appendChildren","parentSelector","insertions","main","missingTransition","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","token","classList","classNames","classNameCount","styleNames","styleCount","oldPropValue","evt","setAttributeNS","updateProperties","previousProperties","propertiesUpdated","previousValue","previousOn","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","nodeAdded","vNode","nodeToRemove","pointerEvents","removeDomNode","parentNode","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","createTextNode","charAt","createElementNS","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","updatedVnode","selector","childIndex","argsLength","onlyChild","dom","beforeNode","element","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","newSources","newKeys","oldTargets","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","projections","renderFunctions","doRender","renderNow","stop","cancelAnimationFrame","renderMaquetteFunction","detach","FactoryRegistry","factoryLabel","define","registryItem","projectorData","projectorDataMap","ProjectorState","Attached","attach","attachPromise","attachHandle","Detached","AttachType","Append","Merge","Replace","createWidgetBase_1","projectorState","body","maquetteProjectorOptions","nodeAttributes","generateID","widgetCount","isWNode","getFromRegistry","dNodeToVNode","dNode","internalState","widgetInternalStateMap","initializedFactoryMap","childrenMapKey","cachedChild","historicChildrenMap","currentChildrenMap","errorMsg","manageDetachedChildren","formatTagNameAndClasses","classes","createVNodeEvented_1","createWidget","getNode","getNodeAttributes","props","newProps","dirty","baseIdProp","data-widget-id","styles","widgetClasses","cachedVNode","widget","factoryRegistry","completeStatefulState","previousState","eventObject","Set_1","vnodeEvents","UNINITIALIZED_LISTENERS","createVNodeEvented","origFn","_setData","callbackfn","listItem","createNavBarLink","innerHTML","counter","createSearchInput_1","createNavbar","isReady","homeLink","src","sectionLinks","searchAction","favouriteAction","pageLinks","actionLinks","createSearchInput","icon","createCssTransitionMixin_1","createHomePage","mmLogo","jumbotron","createCssTransitionMixin","createCardDescription_1","createCardNavBar_1","createSeenWith_1","createCardDetailsPage","cardNavBar","descriptionState","cardDescriptionView","seenWithView","createButtonLink","iconClass","buttonText","shareButtonConfig","createCardDescription","cardImage","cardName","cardTagline","cardFavouriteCount","shareButtons","createCard_1","createCardNavBar","cardNodes","createCard","baseImageClass","large","createSeenWith","createCardsList_1","createCardsPage","cardsList","createCardSummary_1","createCardList","createCardSummary","cardPoints","createGameplayPage","heading","createAboutPage","browserSpecificTransitionEndEventName","determineBrowserSpecificStyleNames","init","testElement","removeNode","finished","transitionEnd","amd"],"mappings":"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","file":"src/main.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(13);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar routes_1 = __webpack_require__(14);\n\tvar cardStore_1 = __webpack_require__(72);\n\tvar widgetStore_1 = __webpack_require__(54);\n\tvar app_1 = __webpack_require__(74);\n\t__webpack_require__(100);\n\tvar root = document.getElementsByTagName('my-app')[0];\n\tvar app = app_1.default({\n\t    id: 'app',\n\t    stateFrom: widgetStore_1.default,\n\t    root: root,\n\t    cssTransitions: true\n\t});\n\tapp.append()\n\t    .then(function () { return cardStore_1.bindActions(); })\n\t    .then(function () { return routes_1.default.start(); });\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createRoute_1 = __webpack_require__(15);\n\tvar createRouter_1 = __webpack_require__(35);\n\tvar createHashHistory_1 = __webpack_require__(49);\n\tvar routeActions_1 = __webpack_require__(50);\n\tvar cardDetailRoute = createRoute_1.default({\n\t    path: 'cards/{id}',\n\t    exec: function (request) {\n\t        var id = request.params.id;\n\t        return routeActions_1.gotoCardDetails.do({ id: id });\n\t    }\n\t});\n\tvar cardsRoute = createRoute_1.default({\n\t    path: 'cards',\n\t    exec: function (request) {\n\t        return routeActions_1.gotoCards.do();\n\t    }\n\t});\n\tvar homeRoute = createRoute_1.default({\n\t    path: '',\n\t    exec: function (request) {\n\t        return routeActions_1.gotoHome.do();\n\t    }\n\t});\n\tvar aboutRoute = createRoute_1.default({\n\t    path: 'about',\n\t    exec: function (request) {\n\t        return routeActions_1.gotoAbout.do();\n\t    }\n\t});\n\tvar gameplayRoute = createRoute_1.default({\n\t    path: 'gameplay',\n\t    exec: function (request) {\n\t        return routeActions_1.gotoGameplay.do();\n\t    }\n\t});\n\texports.history = createHashHistory_1.default();\n\tvar router = createRouter_1.default({ history: exports.history });\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = router;\n\trouter.append([\n\t    cardsRoute,\n\t    cardDetailRoute,\n\t    homeRoute,\n\t    aboutRoute,\n\t    gameplayRoute\n\t]);\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar createRouter_1 = __webpack_require__(35);\n\tvar path_1 = __webpack_require__(48);\n\tvar privateStateMap = new WeakMap_1.default();\n\t// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n\t// change the private state of their children.\n\tvar parentMap = new WeakMap_1.default();\n\tvar noop = function () { };\n\tfunction computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n\t    var params = {};\n\t    parameters.forEach(function (name, index) {\n\t        params[name] = fromPathname[index];\n\t    });\n\t    searchParameters.forEach(function (name) {\n\t        var value = searchParams.get(name);\n\t        if (value !== undefined) {\n\t            params[name] = value;\n\t        }\n\t    });\n\t    return params;\n\t}\n\tvar createRoute = compose_1.default({\n\t    get parent() {\n\t        return parentMap.get(this);\n\t    },\n\t    get path() {\n\t        return privateStateMap.get(this).path;\n\t    },\n\t    append: function (add) {\n\t        var _this = this;\n\t        var routes = privateStateMap.get(this).routes;\n\t        var append = function (route) {\n\t            if (createRouter_1.hasBeenAppended(route)) {\n\t                throw new Error('Cannot append route that has already been appended');\n\t            }\n\t            routes.push(route);\n\t            parentMap.set(route, _this);\n\t        };\n\t        if (Array.isArray(add)) {\n\t            for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                var route = add_1[_i];\n\t                append(route);\n\t            }\n\t        }\n\t        else {\n\t            append(add);\n\t        }\n\t    },\n\t    match: function (segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n\t        var result = path_1.match(path, segments);\n\t        if (result === null) {\n\t            return null;\n\t        }\n\t        if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t            return null;\n\t        }\n\t        // Only extract the search params defined in the route's path.\n\t        var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n\t            var value = searchParams.getAll(name);\n\t            if (value !== undefined) {\n\t                list[name] = value;\n\t            }\n\t            return list;\n\t        }, {});\n\t        var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n\t        if (params === null) {\n\t            return null;\n\t        }\n\t        return {\n\t            hasRemaining: result.hasRemaining,\n\t            offset: result.offset,\n\t            params: params,\n\t            rawPathValues: result.values,\n\t            rawSearchParams: knownSearchParams\n\t        };\n\t    },\n\t    select: function (context, segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n\t        var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\t        // Return early if possible.\n\t        if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t            return [];\n\t        }\n\t        var params = matchResult.params;\n\t        if (guard) {\n\t            var guardResult = guard({ context: context, params: params });\n\t            if (typeof guardResult === 'string') {\n\t                return guardResult;\n\t            }\n\t            if (!guardResult) {\n\t                return [];\n\t            }\n\t        }\n\t        var handler = exec;\n\t        var redirect;\n\t        var remainingSelection;\n\t        var selected = false;\n\t        if (matchResult.hasRemaining) {\n\t            // Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t            var remainingSegments_1 = segments.slice(matchResult.offset);\n\t            selected = routes.some(function (nested) {\n\t                var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n\t                if (typeof nestedResult === 'string') {\n\t                    redirect = nestedResult;\n\t                    return true;\n\t                }\n\t                if (nestedResult.length > 0) {\n\t                    remainingSelection = nestedResult;\n\t                    return true;\n\t                }\n\t                return false;\n\t            });\n\t            // No remaining segments matched, only select this route if a fallback handler was specified.\n\t            if (!selected && fallback) {\n\t                selected = true;\n\t                handler = fallback;\n\t            }\n\t        }\n\t        else {\n\t            selected = true;\n\t            if (index) {\n\t                handler = index;\n\t            }\n\t        }\n\t        if (!selected) {\n\t            return [];\n\t        }\n\t        if (redirect !== undefined) {\n\t            return redirect;\n\t        }\n\t        var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n\t        var selection = {\n\t            // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t            // think no routes were selected.\n\t            handler: handler || noop,\n\t            path: path,\n\t            params: params,\n\t            rawPathValues: rawPathValues,\n\t            rawSearchParams: rawSearchParams,\n\t            route: this\n\t        };\n\t        return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n\t    }\n\t}, function (instance, _a) {\n\t    var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n\t    if (path && /#/.test(path)) {\n\t        throw new TypeError('Path must not contain \\'#\\'');\n\t    }\n\t    var deconstructedPath = path_1.deconstruct(path || '/');\n\t    var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n\t    if (computeParams) {\n\t        if (parameters.length === 0 && searchParameters.length === 0) {\n\t            throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t        }\n\t    }\n\t    else {\n\t        computeParams = function (fromPathname, searchParams) {\n\t            return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t        };\n\t    }\n\t    privateStateMap.set(instance, {\n\t        computeParams: computeParams,\n\t        exec: exec,\n\t        fallback: fallback,\n\t        guard: guard,\n\t        index: index,\n\t        path: deconstructedPath,\n\t        routes: [],\n\t        trailingSlashMustMatch: trailingSlashMustMatch\n\t    });\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRoute;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar instrument_1 = __webpack_require__(17);\n\tvar lang_1 = __webpack_require__(24);\n\tvar array_1 = __webpack_require__(25);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar Symbol_1 = __webpack_require__(29);\n\tvar aspect_1 = __webpack_require__(33);\n\t/**\n\t * The default factory label if no label can be derived during the factory creation process\n\t */\n\tvar DEFAULT_FACTORY_LABEL = 'Compose';\n\t/* References to support minification */\n\tvar defineProperty = Object.defineProperty;\n\tvar isArray = Array.isArray;\n\tvar objectCreate = Object.create;\n\tvar objectKeys = Object.keys;\n\t/**\n\t * A weakmap that stores all the private data for a factory\n\t */\n\tvar privateFactoryData = new WeakMap_1.default();\n\t/**\n\t * An internal function which stubs out a method which, when called at runtime, throws.\n\t *\n\t * @param method The name of \"abstract\" method being called\n\t */\n\tfunction missingMethod(method) {\n\t    return function throwOnMissingMethod() {\n\t        throw new TypeError(\"Advice being applied to missing method named: \" + method);\n\t    };\n\t}\n\t/**\n\t * Internal function which can label a factory with a name and also sets\n\t * the `toString()` method on the prototype to return the approriate\n\t * name for instances.\n\t *\n\t * @param fn The name of the factory to label\n\t * @param value The name to supply for the label\n\t */\n\tfunction assignFactoryName(factory, value) {\n\t    if (typeof factory === 'function' && factory.prototype) {\n\t        assignFunctionName(factory, value);\n\t        defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n\t            get: function () {\n\t                return value;\n\t            },\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * Internal function which can label a function with a name\n\t */\n\tfunction assignFunctionName(fn, value) {\n\t    var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\t    if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t        defineProperty(fn, 'name', {\n\t            value: value,\n\t            writable: true,\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * A helper function that copies own properties and their descriptors\n\t * from one or more sources to a target object. Includes non-enumerable properties\n\t *\n\t * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n\t * @param target The target that properties should be copied onto\n\t * @param sources The rest of the parameters treated as sources to apply\n\t */\n\tfunction assignProperties(overwrite, target) {\n\t    var sources = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        sources[_i - 2] = arguments[_i];\n\t    }\n\t    sources.forEach(function (source) {\n\t        if (!source) {\n\t            return;\n\t        }\n\t        Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n\t            if (key !== 'constructor') {\n\t                var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t                var sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t                var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t                var targetValue = targetDescriptor && targetDescriptor.value;\n\t                /* Special handling to merge array proprties */\n\t                if (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n\t                    sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n\t                        if (!array_1.includes(target[key], current)) {\n\t                            value.push(current);\n\t                        }\n\t                        return value;\n\t                    }, array_1.from(targetValue));\n\t                }\n\t                descriptors[key] = sourceDescriptor;\n\t            }\n\t            return descriptors;\n\t        }, objectCreate(null)));\n\t    });\n\t    return target;\n\t}\n\t/**\n\t * A helper funtion to return a function that is rebased to infer that the\n\t * first argument of the passed function will be the `this` when the function\n\t * is executed.\n\t *\n\t * @param  fn The function to be rebased\n\t * @return    The rebased function\n\t */\n\tfunction rebase(fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        return fn.apply(this, [this].concat(args));\n\t    };\n\t}\n\t/**\n\t * For a given factory, return the names of the initialization functions that will be\n\t * invoked upon construction.\n\t *\n\t * @param factory The factory that the array of function names should be returned for\n\t */\n\tfunction getInitFunctionNames(factory) {\n\t    var initFns = privateFactoryData.get(factory).initFns;\n\t    if (initFns) {\n\t        return initFns.map(function (fn) { return fn.name; });\n\t    }\n\t}\n\texports.getInitFunctionNames = getInitFunctionNames;\n\t/* The rebased functions we need to decorate compose constructors with */\n\t/**\n\t * Perform an extension of a class\n\t *\n\t * @deprecated\n\t */\n\tvar doExtend = rebase(extend);\n\t/**\n\t * Perform a mixin of a class\n\t */\n\tvar doMixin = rebase(mixin);\n\t/**\n\t * Perform a override of a class\n\t */\n\tvar doOverride = rebase(override);\n\t/**\n\t * Perform an overlay of a class\n\t */\n\tvar doOverlay = rebase(overlay);\n\t/**\n\t * Apply aspect advice to a class\n\t */\n\tvar doAspect = rebase(aspect);\n\t/**\n\t * Add static method/properties to a class\n\t */\n\tvar doStatic = rebase(_static);\n\t/**\n\t * Take a mixin and return a factory descriptor for the mixin\n\t *\n\t * @param mixin The factory to return the descriptor for\n\t * @template T The outer type of the descriptor\n\t * @template O The outer factory options of the descriptor\n\t * @template U The inner type of the descriptor\n\t * @template P The inner factory options of the descriptor\n\t */\n\tfunction factoryDescriptor(mixin) {\n\t    return {\n\t        mixin: mixin,\n\t        className: mixin.name\n\t    };\n\t}\n\t/**\n\t * Generate a factory descriptor for a class\n\t */\n\tvar doFactoryDescriptor = rebase(factoryDescriptor);\n\t/**\n\t * A set of functions that are used to decorate the compose factories\n\t */\n\tvar staticMethods = {\n\t    extend: doExtend,\n\t    mixin: doMixin,\n\t    override: doOverride,\n\t    overlay: doOverlay,\n\t    from: doFrom,\n\t    before: doBefore,\n\t    after: doAfter,\n\t    around: doAround,\n\t    aspect: doAspect,\n\t    factoryDescriptor: doFactoryDescriptor,\n\t    static: doStatic\n\t};\n\t/**\n\t * Internal function that merges (or creates) an advice map\n\t *\n\t * @param sources The advice maps to be merged into a single one\n\t */\n\tfunction assignAdviceMap() {\n\t    var sources = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sources[_i - 0] = arguments[_i];\n\t    }\n\t    var result = {};\n\t    sources.forEach(function (source) {\n\t        if (source) {\n\t            for (var method in source) {\n\t                result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n\t            }\n\t        }\n\t    });\n\t    return result;\n\t}\n\t/**\n\t * An internal function that takes a set of create widget options and returns a set of private factory data\n\t *\n\t * @param options The set of factory options to use in creating the private factory data\n\t */\n\tfunction createPrivateFactoryData(_a) {\n\t    var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, overwrite = _a.overwrite, proto = _a.proto, staticProperties = _a.staticProperties;\n\t    var factoryData = (factories || []).reduce(function (factoryData, factory) {\n\t        var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n\t        if (advice) {\n\t            factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t        }\n\t        if (base) {\n\t            assignProperties(false, factoryData.base, base);\n\t        }\n\t        var optionsInitFns = factoryData.initFns;\n\t        initFns.forEach(function (initFn) {\n\t            if (!array_1.includes(optionsInitFns, initFn)) {\n\t                optionsInitFns.push(initFn);\n\t            }\n\t        });\n\t        return factoryData;\n\t    }, {\n\t        base: {},\n\t        initFns: [],\n\t        staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n\t    });\n\t    if (initFunction) {\n\t        factoryData.initFns.push(initFunction);\n\t    }\n\t    if (optionsAdvice) {\n\t        factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t    }\n\t    assignProperties(Boolean(overwrite), factoryData.base, proto);\n\t    return factoryData;\n\t}\n\tfunction createFactory(options) {\n\t    /**\n\t     * A compose factory\n\t     */\n\t    function factory() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        if (this && this.constructor === factory) {\n\t            throw new SyntaxError('Factories cannot be called with \"new\".');\n\t        }\n\t        var instance = objectCreate(factory.prototype);\n\t        /* clone any arrays in the instance */\n\t        for (var key in instance) {\n\t            if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t                instance[key] = array_1.from(instance[key]);\n\t            }\n\t        }\n\t        args.unshift(instance);\n\t        privateFactoryData.get(factory).initFns.forEach(function (fn) {\n\t            fn.apply(null, args);\n\t        });\n\t        return instance;\n\t    }\n\t    var factoryData = createPrivateFactoryData(options);\n\t    privateFactoryData.set(factory, factoryData);\n\t    var factoryPrototype = factory.prototype;\n\t    /* mixin base properties into the prototype */\n\t    assignProperties(false, factoryPrototype, factoryData.base);\n\t    /* apply any advice to the prototype */\n\t    if (factoryData.advice) {\n\t        var _loop_1 = function(method) {\n\t            factoryData.advice[method].forEach(function (_a) {\n\t                var aspect = _a[0], advice = _a[1];\n\t                var sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t                switch (aspect) {\n\t                    case 'before':\n\t                        factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n\t                        break;\n\t                    case 'after':\n\t                        factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n\t                        break;\n\t                    case 'around':\n\t                        factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n\t                }\n\t            });\n\t        };\n\t        for (var method in factoryData.advice) {\n\t            _loop_1(method);\n\t        }\n\t    }\n\t    /* assign a constructor to the prototype */\n\t    factoryPrototype.constructor = factory;\n\t    /* assign static methods/properties */\n\t    lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n\t    /* assign factory name */\n\t    var className = options.className ||\n\t        (options.factories && options.factories[0] && options.factories[0].name) ||\n\t        DEFAULT_FACTORY_LABEL;\n\t    assignFactoryName(factory, className);\n\t    /* freeze the factory, so it cannot be accidently modified */\n\t    Object.freeze(factory);\n\t    return factory;\n\t}\n\t/**\n\t * A custom type guard that determines if the value is a ComposeFactory\n\t *\n\t * @param   value The target to check\n\t * @returns       Return true if it is a ComposeFactory, otherwise false\n\t */\n\tfunction isComposeFactory(value) {\n\t    return Boolean(value && privateFactoryData.get(value));\n\t}\n\texports.isComposeFactory = isComposeFactory;\n\tfunction extend(base, className, extension) {\n\t    instrument_1.deprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n\t    if (typeof className !== 'string') {\n\t        extension = className;\n\t        className = undefined;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        proto: typeof extension === 'function' ? extension.prototype : extension,\n\t        factories: [base]\n\t    });\n\t}\n\tfunction override(baseFactory, className, properties) {\n\t    if (typeof className !== 'string') {\n\t        properties = className;\n\t        className = undefined;\n\t    }\n\t    if (typeof properties !== 'object') {\n\t        throw new TypeError('Argument \"properties\" must be an object.');\n\t    }\n\t    var base = privateFactoryData.get(baseFactory).base;\n\t    /* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n\t     * similiar to this */\n\t    Object.keys(properties).forEach(function (key) {\n\t        if (!(key in base)) {\n\t            throw new TypeError(\"Attempting to override missing property \\\"\" + key + \"\\\"\");\n\t        }\n\t    });\n\t    return createFactory({\n\t        className: className,\n\t        overwrite: true,\n\t        proto: properties,\n\t        factories: [baseFactory]\n\t    });\n\t}\n\t/**\n\t * Internal implementation of the overlay functionality, to allow a function to modify a\n\t * compose factory prototype\n\t *\n\t * @param base The target compose factory\n\t * @param overlayFunction The callback function that will modify the prototype of the factory\n\t */\n\tfunction overlay(base, overlayFunction) {\n\t    var factory = createFactory({\n\t        factories: [base]\n\t    });\n\t    overlayFunction(factory.prototype);\n\t    return factory;\n\t}\n\t/**\n\t * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n\t * creating a factory\n\t *\n\t * @param aspectAdvice The aspect advice to convert into an advice map\n\t */\n\tfunction aspectAdviceToAdviceMap(aspectAdvice) {\n\t    if (!aspectAdvice) {\n\t        return;\n\t    }\n\t    var adviceMap = {};\n\t    var beforeAdvice = aspectAdvice.before;\n\t    var afterAdvice = aspectAdvice.after;\n\t    var aroundAdvice = aspectAdvice.around;\n\t    function mapAdvice(type, key, advice) {\n\t        var adviceTuple = [type, advice[key]];\n\t        if (adviceMap[key]) {\n\t            adviceMap[key].push(adviceTuple);\n\t        }\n\t        else {\n\t            adviceMap[key] = [adviceTuple];\n\t        }\n\t    }\n\t    if (beforeAdvice) {\n\t        objectKeys(beforeAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('before', key, beforeAdvice);\n\t        });\n\t    }\n\t    if (afterAdvice) {\n\t        objectKeys(afterAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('after', key, afterAdvice);\n\t        });\n\t    }\n\t    if (aroundAdvice) {\n\t        objectKeys(aroundAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('around', key, aroundAdvice);\n\t        });\n\t    }\n\t    return adviceMap;\n\t}\n\t/**\n\t * A custom type guard that determines if a value is ComposeMixinable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isComposeMixinable(value) {\n\t    return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n\t}\n\t/**\n\t * The internal implementation of mixin in values into a compose factory\n\t *\n\t * @param base The base compose factory that is the target for being mixed in\n\t * @param toMixin The value to be mixed in\n\t */\n\tfunction mixin(base, toMixin) {\n\t    /* ensure we are dealing with a mixinDescriptor */\n\t    var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\t    /* destructure out most of the factory creation options */\n\t    var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n\t    /* we will at least be using the base factory to create the new one */\n\t    var factories = [base];\n\t    var proto;\n\t    /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\t    if (isComposeFactory(mixin)) {\n\t        factories.push(mixin);\n\t    }\n\t    else {\n\t        /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t        proto = typeof mixin === 'function' ? mixin.prototype : mixin;\n\t    }\n\t    /* convert the advice, if any, to the format used by createFactory */\n\t    var advice = aspectAdviceToAdviceMap(aspectAdvice);\n\t    /* label the initFn */\n\t    if (initFunction) {\n\t        assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n\t    }\n\t    /* return the newly created factory */\n\t    return createFactory({\n\t        advice: advice,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        className: className,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of extracting methods from another object\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction from(base, method) {\n\t    return base.prototype[method];\n\t}\n\t/**\n\t * Internal implementation to apply from when `this` represents the base\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction doFrom(base, method) {\n\t    return createFactory({\n\t        factories: [this],\n\t        proto: (_a = {},\n\t            _a[method] = base.prototype[method],\n\t            _a\n\t        )\n\t    });\n\t    var _a;\n\t}\n\tfunction before() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i - 0] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.before(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply before advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doBefore(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['before', advice]],\n\t            _a\n\t        )\n\t    });\n\t    var _a;\n\t}\n\tfunction after() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i - 0] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.after(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply after advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAfter(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['after', advice]],\n\t            _a\n\t        )\n\t    });\n\t    var _a;\n\t}\n\tfunction around() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i - 0] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.around(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply around advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAround(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['around', advice]],\n\t            _a\n\t        )\n\t    });\n\t    var _a;\n\t}\n\t/**\n\t * The internal implementation of applying aspect advice to a factory\n\t *\n\t * @param base The base factory the advice should be applied to\n\t * @param advice The advice map to apply to the factory\n\t */\n\tfunction aspect(base, advice) {\n\t    return createFactory({\n\t        factories: [base],\n\t        advice: aspectAdviceToAdviceMap(advice)\n\t    });\n\t}\n\tfunction create(className, base, initFunction) {\n\t    /* disambugate arguments */\n\t    if (typeof className !== 'string') {\n\t        initFunction = base;\n\t        base = className;\n\t        className = undefined;\n\t    }\n\t    /* Label the initFunction */\n\t    if (initFunction && className) {\n\t        assignFunctionName(initFunction, \"init\" + className);\n\t    }\n\t    var factories;\n\t    var proto;\n\t    /* If base is a compose factory, set it as the factory array */\n\t    if (base && isComposeFactory(base)) {\n\t        factories = [base];\n\t    }\n\t    else {\n\t        proto = typeof base === 'function' ? base.prototype : base;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of applying static properties to a compose factory\n\t *\n\t * @param factory The factory that the static properties should be applied to\n\t * @param staticProperties The properties to be applied to the factory\n\t */\n\tfunction _static(base, staticProperties) {\n\t    return createFactory({\n\t        factories: [base],\n\t        staticProperties: staticProperties\n\t    });\n\t}\n\t/**\n\t * A factory construction utility\n\t *\n\t * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n\t * @param initFunction An optional initialization function for the factory\n\t */\n\tvar compose = create;\n\t/* Add static methods to compose */\n\tlang_1.assign(compose, {\n\t    create: create,\n\t    static: _static,\n\t    extend: extend,\n\t    mixin: mixin,\n\t    override: override,\n\t    overlay: overlay,\n\t    from: from,\n\t    before: before,\n\t    after: after,\n\t    around: around,\n\t    aspect: aspect\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = compose;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(18);\n\t/**\n\t * The default message to warn when no other is provided\n\t */\n\tvar DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n\t/**\n\t * When set, globalWarn will be used instead of `console.warn`\n\t */\n\tvar globalWarn;\n\t/**\n\t * A function that will console warn that a function has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecated(_a) {\n\t    var _b = _a === void 0 ? {} : _a, message = _b.message, name = _b.name, warn = _b.warn, url = _b.url;\n\t    /* istanbul ignore else: testing with debug off is difficult */\n\t    if (has_1.default('debug')) {\n\t        message = message || DEFAULT_DEPRECATED_MESSAGE;\n\t        var warning = \"DEPRECATED: \" + (name ? name + ': ' : '') + message;\n\t        if (url) {\n\t            warning += \"\\n\\n    See \" + url + \" for more details.\\n\\n\";\n\t        }\n\t        if (warn) {\n\t            warn(warning);\n\t        }\n\t        else if (globalWarn) {\n\t            globalWarn(warning);\n\t        }\n\t        else {\n\t            console.warn(warning);\n\t        }\n\t    }\n\t}\n\texports.deprecated = deprecated;\n\t/**\n\t * A function that generates before advice that can be used to warn when an API has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedAdvice(options) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        deprecated(options);\n\t        return args;\n\t    };\n\t}\n\texports.deprecatedAdvice = deprecatedAdvice;\n\t/**\n\t * A method decorator that will console warn when a method if invoked that is deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedDecorator(options) {\n\t    return function (target, propertyKey, descriptor) {\n\t        if (has_1.default('debug')) {\n\t            var originalFn_1 = descriptor.value;\n\t            options = options || {};\n\t            /* IE 10/11 don't have the name property on functions */\n\t            options.name = target.constructor.name ? target.constructor.name + \"#\" + propertyKey : propertyKey;\n\t            descriptor.value = function () {\n\t                var args = [];\n\t                for (var _i = 0; _i < arguments.length; _i++) {\n\t                    args[_i - 0] = arguments[_i];\n\t                }\n\t                deprecated(options);\n\t                return originalFn_1.apply(target, args);\n\t            };\n\t        }\n\t        return descriptor;\n\t    };\n\t}\n\texports.deprecatedDecorator = deprecatedDecorator;\n\t/**\n\t * A function that will set the warn function that will be used instead of `console.warn` when\n\t * logging warning messages\n\t *\n\t * @param warn The function (or `undefined`) to use instead of `console.warn`\n\t */\n\tfunction setWarn(warn) {\n\t    globalWarn = warn;\n\t}\n\texports.setWarn = setWarn;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(19);\n\tvar has_1 = __webpack_require__(20);\n\t__export(__webpack_require__(20));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\thas_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\n\thas_1.add('raf', typeof requestAnimationFrame === 'function');\n\thas_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\n\thas_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\n\thas_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\n\thas_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\n\thas_1.add('xhr2-blob', function () {\n\t    if (!has_1.default('xhr2')) {\n\t        return false;\n\t    }\n\t    var request = new XMLHttpRequest();\n\t    request.open('GET', '/', true);\n\t    request.responseType = 'blob';\n\t    request.abort();\n\t    return request.responseType === 'blob';\n\t});\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (function () {\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    return {};\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(21);\n\tvar has_1 = __webpack_require__(22);\n\tvar has_2 = __webpack_require__(22);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\t__export(__webpack_require__(22));\n\t/* ECMAScript 6 and 7 Features */\n\t/*\n\t * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n\t * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n\t * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n\t * will be anything that uses their iterator symbol, like Map, Set, etc.\n\t */\n\t/* Symbol */\n\thas_2.add('es6-symbol', typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n\t/* Object */\n\thas_2.add('es6-object-assign', typeof Object.assign === 'function');\n\t/* Array */\n\thas_2.add('es6-array-from', 'from' in global_1.default.Array);\n\thas_2.add('es6-array-of', 'of' in global_1.default.Array);\n\thas_2.add('es6-array-fill', function () {\n\t    if ('fill' in global_1.default.Array.prototype) {\n\t        /* Some versions of Safari do not properly implement this */\n\t        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t    }\n\t    return false;\n\t});\n\thas_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\n\thas_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n\t/* String */\n\thas_2.add('es6-string-raw', function () {\n\t    function getCallSite(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        return callSite;\n\t    }\n\t    if ('raw' in global_1.default.String) {\n\t        var b = 1;\n\t        var callSite = (_a = [\"a\\n\", \"\"], _a.raw = [\"a\\\\n\", \"\"], getCallSite(_a, b));\n\t        callSite.raw = ['a\\\\n'];\n\t        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\\\n';\n\t        return supportsTrunc;\n\t    }\n\t    return false;\n\t    var _a;\n\t});\n\thas_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\n\thas_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\n\thas_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\n\thas_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\n\thas_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padstart', 'padStart' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padend', 'padEnd' in global_1.default.String.prototype);\n\t/* Math */\n\thas_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\n\thas_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\n\thas_2.add('es6-math-imul', function () {\n\t    if ('imul' in global_1.default.Math) {\n\t        /* Some versions of Safari on ios do not properly implement this */\n\t        return Math.imul(0xffffffff, 5) === -5;\n\t    }\n\t    return false;\n\t});\n\t/* Promise */\n\thas_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'));\n\t/* Observable */\n\thas_2.add('es-observable', typeof global_1.default.Observable !== 'undefined');\n\t/* Set */\n\thas_2.add('es6-set', function () {\n\t    if (typeof global_1.default.Set === 'function') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t        var set = new global_1.default.Set([1]);\n\t        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Map */\n\thas_2.add('es6-map', function () {\n\t    if (typeof global_1.default.Map === 'function') {\n\t        /*\n\t        IE11 and older versions of Safari are missing critical ES6 Map functionality\n\t        We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t        take arguments (iOS 8.4)\n\t         */\n\t        try {\n\t            var map = new global_1.default.Map([[0, 1]]);\n\t            return map.has(0) &&\n\t                typeof map.keys === 'function' && has_1.default('es6-symbol') &&\n\t                typeof map.values === 'function' &&\n\t                typeof map.entries === 'function';\n\t        }\n\t        catch (e) {\n\t            /* istanbul ignore next: not testing on iOS at the moment */\n\t            return false;\n\t        }\n\t    }\n\t    return false;\n\t});\n\t/* WeakMap */\n\thas_2.add('es6-weakmap', function () {\n\t    if (typeof global_1.default.WeakMap !== 'undefined') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t        var key1 = {};\n\t        var key2 = {};\n\t        var map = new global_1.default.WeakMap([[key1, 1]]);\n\t        Object.freeze(key1);\n\t        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Miscellaneous features */\n\thas_2.add('float32array', 'Float32Array' in global_1.default);\n\thas_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\n\thas_2.add('postmessage', typeof postMessage === 'function');\n\thas_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n\t/* DOM Features */\n\thas_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (typeof global === 'undefined') ? Function('return this')() : global;\n\t// global spec defines a reference to the global object called 'global'\n\t// https://github.com/tc39/proposal-global\n\tif (!('global' in globalObject)) {\n\t    globalObject.global = globalObject;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {\"use strict\";\n\t/**\n\t * A cache of results of feature tests\n\t */\n\texports.testCache = {};\n\t/**\n\t * A cache of the un-resolved feature tests\n\t */\n\texports.testFunctions = {};\n\t/**\n\t * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n\t */\n\tvar globalScope = (function () {\n\t    /* istanbul ignore else */\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    /* istanbul ignore next */\n\t    return {};\n\t})();\n\t/* Grab the staticFeatures if there are available */\n\tvar staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n\t/* Cleaning up the DojoHasEnviornment */\n\tif ('DojoHasEnvironment' in globalScope) {\n\t    delete globalScope.DojoHasEnvironment;\n\t}\n\t/**\n\t * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n\t * returns a map.\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isStaticFeatureFunction(value) {\n\t    return typeof value === 'function';\n\t}\n\t/**\n\t * The cache of asserted features that were available in the global scope when the\n\t * module loaded\n\t */\n\tvar staticCache = staticFeatures\n\t    ? isStaticFeatureFunction(staticFeatures)\n\t        ? staticFeatures.apply(globalScope)\n\t        : staticFeatures\n\t    : {};/* Providing an empty cache, if none was in the environment\n\t\n\t/**\n\t* AMD plugin function.\n\t*\n\t* Conditional loads modules based on a has feature test value.\n\t*\n\t* @param resourceId Gives the resolved module id to load.\n\t* @param require The loader require function with respect to the module that contained the plugin resource in its\n\t*                dependency list.\n\t* @param load Callback to loader that consumes result of plugin demand.\n\t*/\n\tfunction load(resourceId, require, load, config) {\n\t    resourceId ? require([resourceId], load) : load();\n\t}\n\texports.load = load;\n\t/**\n\t * AMD plugin function.\n\t *\n\t * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n\t * value(s).\n\t *\n\t * @param resourceId The id of the module\n\t * @param normalize Resolves a relative module id into an absolute module id\n\t */\n\tfunction normalize(resourceId, normalize) {\n\t    var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\t    var i = 0;\n\t    function get(skip) {\n\t        var term = tokens[i++];\n\t        if (term === ':') {\n\t            // empty string module name, resolves to null\n\t            return null;\n\t        }\n\t        else {\n\t            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t            if (tokens[i++] === '?') {\n\t                if (!skip && has(term)) {\n\t                    // matched the feature, get the first value from the options\n\t                    return get();\n\t                }\n\t                else {\n\t                    // did not match, get the second value, passing over the first\n\t                    get(true);\n\t                    return get(skip);\n\t                }\n\t            }\n\t            // a module\n\t            return term;\n\t        }\n\t    }\n\t    var id = get();\n\t    return id && normalize(id);\n\t}\n\texports.normalize = normalize;\n\t/**\n\t * Check if a feature has already been registered\n\t *\n\t * @param feature the name of the feature\n\t */\n\tfunction exists(feature) {\n\t    return Boolean(feature in staticCache || feature in exports.testCache || exports.testFunctions[feature]);\n\t}\n\texports.exists = exists;\n\t/**\n\t * Register a new test for a named feature.\n\t *\n\t * @example\n\t * has.add('dom-addeventlistener', !!document.addEventListener);\n\t *\n\t * @example\n\t * has.add('touch-events', function () {\n\t *    return 'ontouchstart' in document\n\t * });\n\t *\n\t * @param feature the name of the feature\n\t * @param value the value reported of the feature, or a function that will be executed once on first test\n\t * @param overwrite if an existing value should be overwritten. Defaults to false.\n\t */\n\tfunction add(feature, value, overwrite) {\n\t    if (overwrite === void 0) { overwrite = false; }\n\t    if (exists(feature) && !overwrite && !(feature in staticCache)) {\n\t        throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n\t    }\n\t    if (typeof value === 'function') {\n\t        exports.testFunctions[feature] = value;\n\t    }\n\t    else {\n\t        exports.testCache[feature] = value;\n\t        delete exports.testFunctions[feature];\n\t    }\n\t}\n\texports.add = add;\n\t/**\n\t * Return the current value of a named feature.\n\t *\n\t * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n\t */\n\tfunction has(feature) {\n\t    var result;\n\t    if (feature in staticCache) {\n\t        result = staticCache[feature];\n\t    }\n\t    else if (exports.testFunctions[feature]) {\n\t        result = exports.testCache[feature] = exports.testFunctions[feature].call(null);\n\t        delete exports.testFunctions[feature];\n\t    }\n\t    else if (feature in exports.testCache) {\n\t        result = exports.testCache[feature];\n\t    }\n\t    else {\n\t        throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n\t    }\n\t    return result;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has;\n\t/*\n\t * Out of the box feature tests\n\t */\n\t/* Evironments */\n\t/* Used as a value to provide a debug only code path */\n\tadd('debug', true);\n\t/* Detects if the environment is \"browser like\" */\n\tadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\t/* Detects if the enviornment appears to be NodeJS */\n\tadd('host-node', function () {\n\t    if (typeof process === 'object' && process.versions && process.versions.node) {\n\t        return process.versions.node;\n\t    }\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(23)))\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(18);\n\tvar slice = Array.prototype.slice;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Type guard that ensures that the value can be coerced to Object\n\t * to weed out host objects that do not derive from Object.\n\t * This function is used to check if we want to deep copy an object or not.\n\t * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n\t * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n\t * so it is not handled here.\n\t * @param  value The value to check\n\t * @return       If the value is coercible into an Object\n\t */\n\tfunction shouldDeepCopyObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\tfunction copyArray(array, inherited) {\n\t    return array.map(function (item) {\n\t        if (Array.isArray(item)) {\n\t            return copyArray(item, inherited);\n\t        }\n\t        return !shouldDeepCopyObject(item) ?\n\t            item :\n\t            _mixin({\n\t                deep: true,\n\t                inherited: inherited,\n\t                sources: [item],\n\t                target: {}\n\t            });\n\t    });\n\t}\n\tfunction _mixin(kwArgs) {\n\t    var deep = kwArgs.deep;\n\t    var inherited = kwArgs.inherited;\n\t    var target = kwArgs.target;\n\t    for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n\t        var source = _a[_i];\n\t        if (source === null || source === undefined) {\n\t            continue;\n\t        }\n\t        for (var key in source) {\n\t            if (inherited || hasOwnProperty.call(source, key)) {\n\t                var value = source[key];\n\t                if (deep) {\n\t                    if (Array.isArray(value)) {\n\t                        value = copyArray(value, inherited);\n\t                    }\n\t                    else if (shouldDeepCopyObject(value)) {\n\t                        value = _mixin({\n\t                            deep: true,\n\t                            inherited: inherited,\n\t                            sources: [value],\n\t                            target: {}\n\t                        });\n\t                    }\n\t                }\n\t                target[key] = value;\n\t            }\n\t        }\n\t    }\n\t    return target;\n\t}\n\t/**\n\t * Copies the values of all enumerable own properties of one or more source objects to the target object.\n\t *\n\t * @param target The target object to receive values from source objects\n\t * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n\t * @return The modified target object\n\t */\n\texports.assign = has_1.default('object-assign') ?\n\t    Object.assign :\n\t    function (target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: false,\n\t            inherited: false,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    };\n\tfunction create(prototype) {\n\t    var mixins = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        mixins[_i - 1] = arguments[_i];\n\t    }\n\t    if (!mixins.length) {\n\t        throw new RangeError('lang.create requires at least one mixin object.');\n\t    }\n\t    var args = mixins.slice();\n\t    args.unshift(Object.create(prototype));\n\t    return exports.assign.apply(null, args);\n\t}\n\texports.create = create;\n\tfunction deepAssign(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: false,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepAssign = deepAssign;\n\tfunction deepMixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepMixin = deepMixin;\n\t/**\n\t * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n\t * deep copies the provided source's values into the new target.\n\t *\n\t * @param source The object to duplicate\n\t * @return The new object\n\t */\n\tfunction duplicate(source) {\n\t    var target = Object.create(Object.getPrototypeOf(source));\n\t    return deepMixin(target, source);\n\t}\n\texports.duplicate = duplicate;\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param a First value to compare\n\t * @param b Second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\tfunction isIdentical(a, b) {\n\t    return a === b ||\n\t        /* both values are NaN */\n\t        (a !== a && b !== b);\n\t}\n\texports.isIdentical = isIdentical;\n\t/**\n\t * Returns a function that binds a method to the specified object at runtime. This is similar to\n\t * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n\t * As a result, the function returned by `lateBind` will always call the function currently assigned to\n\t * the specified property on the object as of the moment the function it returns is called.\n\t *\n\t * @param instance The context object\n\t * @param method The name of the method on the context object to bind to itself\n\t * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n\t * @return The bound function\n\t */\n\tfunction lateBind(instance, method) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 2] = arguments[_i];\n\t    }\n\t    return suppliedArgs.length ?\n\t        function () {\n\t            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t            // TS7017\n\t            return instance[method].apply(instance, args);\n\t        } :\n\t        function () {\n\t            // TS7017\n\t            return instance[method].apply(instance, arguments);\n\t        };\n\t}\n\texports.lateBind = lateBind;\n\tfunction mixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: false,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.mixin = mixin;\n\t/**\n\t * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n\t * Like `Function.prototype.bind`, but does not alter execution context.\n\t *\n\t * @param targetFunction The function that needs to be bound\n\t * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n\t * @return The bound function\n\t */\n\tfunction partial(targetFunction) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 1] = arguments[_i];\n\t    }\n\t    return function () {\n\t        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t        return targetFunction.apply(this, args);\n\t    };\n\t}\n\texports.partial = partial;\n\t/**\n\t * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n\t * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n\t * event listeners, timers, etc.\n\t *\n\t * @param destructor A function that will be called when the handle's `destroy` method is invoked\n\t * @return The handle object\n\t */\n\tfunction createHandle(destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            destructor.call(this);\n\t        }\n\t    };\n\t}\n\texports.createHandle = createHandle;\n\t/**\n\t * Returns a single handle that can be used to destroy multiple handles simultaneously.\n\t *\n\t * @param handles An array of handles with `destroy` methods\n\t * @return The handle object\n\t */\n\tfunction createCompositeHandle() {\n\t    var handles = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        handles[_i - 0] = arguments[_i];\n\t    }\n\t    return createHandle(function () {\n\t        for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n\t            var handle = handles_1[_i];\n\t            handle.destroy();\n\t        }\n\t    });\n\t}\n\texports.createCompositeHandle = createCompositeHandle;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(20);\n\tvar util_1 = __webpack_require__(26);\n\tvar iterator_1 = __webpack_require__(27);\n\tvar number_1 = __webpack_require__(30);\n\t/**\n\t * Ensures a non-negative, non-infinite, safe integer.\n\t *\n\t * @param length The number to validate\n\t * @return A proper length\n\t */\n\tfunction toLength(length) {\n\t    length = Number(length);\n\t    if (isNaN(length)) {\n\t        return 0;\n\t    }\n\t    if (isFinite(length)) {\n\t        length = Math.floor(length);\n\t    }\n\t    // Ensure a non-negative, real, safe integer\n\t    return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n\t}\n\t/**\n\t * From ES6 7.1.4 ToInteger()\n\t *\n\t * @param value A value to convert\n\t * @return An integer\n\t */\n\tfunction toInteger(value) {\n\t    value = Number(value);\n\t    if (isNaN(value)) {\n\t        return 0;\n\t    }\n\t    if (value === 0 || !isFinite(value)) {\n\t        return value;\n\t    }\n\t    return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n\t}\n\t/**\n\t * Normalizes an offset against a given length, wrapping it if negative.\n\t *\n\t * @param value The original offset\n\t * @param length The total length to normalize against\n\t * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n\t */\n\tfunction normalizeOffset(value, length) {\n\t    return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n\t}\n\t/**\n\t * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n\t * the functionality is required or not.\n\t */\n\tvar Shim;\n\t(function (Shim) {\n\t    function from(arrayLike, mapFunction, thisArg) {\n\t        if (arrayLike == null) {\n\t            throw new TypeError('from: requires an array-like object');\n\t        }\n\t        if (mapFunction && thisArg) {\n\t            mapFunction = mapFunction.bind(thisArg);\n\t        }\n\t        /* tslint:disable-next-line:variable-name */\n\t        var Constructor = this;\n\t        var length = toLength(arrayLike.length);\n\t        // Support extension\n\t        var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n\t        if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n\t            return array;\n\t        }\n\t        var i = 0;\n\t        iterator_1.forOf(arrayLike, function (value) {\n\t            array[i] = mapFunction ? mapFunction(value, i) : value;\n\t            i++;\n\t        });\n\t        if (arrayLike.length !== undefined) {\n\t            array.length = length;\n\t        }\n\t        return array;\n\t    }\n\t    Shim.from = from;\n\t    function of() {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i - 0] = arguments[_i];\n\t        }\n\t        return Array.prototype.slice.call(items);\n\t    }\n\t    Shim.of = of;\n\t    function copyWithin(target, offset, start, end) {\n\t        if (target == null) {\n\t            throw new TypeError('copyWithin: target must be an array-like object');\n\t        }\n\t        var length = toLength(target.length);\n\t        offset = normalizeOffset(toInteger(offset), length);\n\t        start = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        var count = Math.min(end - start, length - offset);\n\t        var direction = 1;\n\t        if (offset > start && offset < (start + count)) {\n\t            direction = -1;\n\t            start += count - 1;\n\t            offset += count - 1;\n\t        }\n\t        while (count > 0) {\n\t            if (start in target) {\n\t                target[offset] = target[start];\n\t            }\n\t            else {\n\t                delete target[offset];\n\t            }\n\t            offset += direction;\n\t            start += direction;\n\t            count--;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.copyWithin = copyWithin;\n\t    function fill(target, value, start, end) {\n\t        var length = toLength(target.length);\n\t        var i = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        while (i < end) {\n\t            target[i++] = value;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.fill = fill;\n\t    function find(target, callback, thisArg) {\n\t        var index = findIndex(target, callback, thisArg);\n\t        return index !== -1 ? target[index] : undefined;\n\t    }\n\t    Shim.find = find;\n\t    function findIndex(target, callback, thisArg) {\n\t        var length = toLength(target.length);\n\t        if (!callback) {\n\t            throw new TypeError('find: second argument must be a function');\n\t        }\n\t        if (thisArg) {\n\t            callback = callback.bind(thisArg);\n\t        }\n\t        for (var i = 0; i < length; i++) {\n\t            if (callback(target[i], i, target)) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    Shim.findIndex = findIndex;\n\t    function includes(target, searchElement, fromIndex) {\n\t        if (fromIndex === void 0) { fromIndex = 0; }\n\t        var len = toLength(target.length);\n\t        for (var i = fromIndex; i < len; ++i) {\n\t            var currentElement = target[i];\n\t            if (searchElement === currentElement ||\n\t                (searchElement !== searchElement && currentElement !== currentElement)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    Shim.includes = includes;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\texports.from = has_1.default('es6-array-from')\n\t    ? Array.from\n\t    : Shim.from;\n\t/**\n\t * Creates a new array from the function parameters.\n\t *\n\t * @param arguments Any number of arguments for the array\n\t * @return An array from the given arguments\n\t */\n\texports.of = has_1.default('es6-array-of')\n\t    ? Array.of\n\t    : Shim.of;\n\t/* ES6 Array instance methods */\n\t/**\n\t * Copies data internally within an array or array-like object.\n\t *\n\t * @param target The target array-like object\n\t * @param offset The index to start copying values to; if negative, it counts backwards from length\n\t * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n\t * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n\t * @return The target\n\t */\n\texports.copyWithin = has_1.default('es6-array-copywithin')\n\t    ? util_1.wrapNative(Array.prototype.copyWithin)\n\t    : Shim.copyWithin;\n\t/**\n\t * Fills elements of an array-like object with the specified value.\n\t *\n\t * @param target The target to fill\n\t * @param value The value to fill each element of the target with\n\t * @param start The first index to fill\n\t * @param end The (exclusive) index at which to stop filling\n\t * @return The filled target\n\t */\n\texports.fill = has_1.default('es6-array-fill')\n\t    ? util_1.wrapNative(Array.prototype.fill)\n\t    : Shim.fill;\n\t/**\n\t * Finds and returns the first instance matching the callback or undefined if one is not found.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning if the current value matches a criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first element matching the callback, or undefined if one does not exist\n\t */\n\texports.find = has_1.default('es6-array-find')\n\t    ? util_1.wrapNative(Array.prototype.find)\n\t    : Shim.find;\n\t/**\n\t * Performs a linear search and returns the first index whose value satisfies the passed callback,\n\t * or -1 if no values satisfy it.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning true if the current value satisfies its criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n\t */\n\texports.findIndex = has_1.default('es6-array-findindex')\n\t    ? util_1.wrapNative(Array.prototype.findIndex)\n\t    : Shim.findIndex;\n\t/* ES7 Array instance methods */\n\t/**\n\t * Determines whether an array includes a given value\n\t *\n\t * @param target the target array-like object\n\t * @param searchElement the item to search for\n\t * @param fromIndex the starting index to search from\n\t * @return `true` if the array includes the element, otherwise `false`\n\t */\n\texports.includes = has_1.default('es7-array-includes')\n\t    ? util_1.wrapNative(Array.prototype.includes)\n\t    : Shim.includes;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Helper function to generate a value property descriptor\n\t *\n\t * @param value        The value the property descriptor should be set to\n\t * @param enumerable   If the property should be enumberable, defaults to false\n\t * @param writable     If the property should be writable, defaults to true\n\t * @param configurable If the property should be configurable, defaults to true\n\t * @return             The property descriptor object\n\t */\n\tfunction getValueDescriptor(value, enumerable, writable, configurable) {\n\t    if (enumerable === void 0) { enumerable = false; }\n\t    if (writable === void 0) { writable = true; }\n\t    if (configurable === void 0) { configurable = true; }\n\t    return {\n\t        value: value,\n\t        enumerable: enumerable,\n\t        writable: writable,\n\t        configurable: configurable\n\t    };\n\t}\n\texports.getValueDescriptor = getValueDescriptor;\n\t/**\n\t * A helper function which wraps a function where the first argument becomes the scope\n\t * of the call\n\t *\n\t * @param nativeFunction The source function to be wrapped\n\t */\n\tfunction wrapNative(nativeFunction) {\n\t    return function (target) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        return nativeFunction.apply(target, args);\n\t    };\n\t}\n\texports.wrapNative = wrapNative;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar string_1 = __webpack_require__(28);\n\t__webpack_require__(29);\n\tvar staticDone = { done: true, value: undefined };\n\t/**\n\t * A class that provides \"shims\" an iterator interface on array like\n\t * objects.\n\t */\n\tvar ShimIterator = (function () {\n\t    function ShimIterator(list) {\n\t        this._nextIndex = -1;\n\t        if (isIterable(list)) {\n\t            this._nativeIterator = list[Symbol.iterator]();\n\t        }\n\t        else {\n\t            this._list = list;\n\t        }\n\t    }\n\t    ;\n\t    /**\n\t     * Return the next iteration result for the Iterator\n\t     */\n\t    ShimIterator.prototype.next = function () {\n\t        if (this._nativeIterator) {\n\t            return this._nativeIterator.next();\n\t        }\n\t        if (!this._list) {\n\t            return staticDone;\n\t        }\n\t        if (++this._nextIndex < this._list.length) {\n\t            return {\n\t                done: false,\n\t                value: this._list[this._nextIndex]\n\t            };\n\t        }\n\t        return staticDone;\n\t    };\n\t    ;\n\t    ShimIterator.prototype[Symbol.iterator] = function () {\n\t        return this;\n\t    };\n\t    return ShimIterator;\n\t}());\n\texports.ShimIterator = ShimIterator;\n\t/**\n\t * A type guard for checking if something has an Iterable interface\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isIterable(value) {\n\t    return value && typeof value[Symbol.iterator] === 'function';\n\t}\n\texports.isIterable = isIterable;\n\t/**\n\t * A type guard for checking if something is ArrayLike\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t}\n\texports.isArrayLike = isArrayLike;\n\t/**\n\t * Returns the iterator for an object\n\t *\n\t * @param iterable The iterable object to return the iterator for\n\t */\n\tfunction get(iterable) {\n\t    if (isIterable(iterable)) {\n\t        return iterable[Symbol.iterator]();\n\t    }\n\t    else if (isArrayLike(iterable)) {\n\t        return new ShimIterator(iterable);\n\t    }\n\t}\n\texports.get = get;\n\t/**\n\t * Shims the functionality of `for ... of` blocks\n\t *\n\t * @param iterable The object the provides an interator interface\n\t * @param callback The callback which will be called for each item of the iterable\n\t * @param thisArg Optional scope to pass the callback\n\t */\n\tfunction forOf(iterable, callback, thisArg) {\n\t    var broken = false;\n\t    function doBreak() {\n\t        broken = true;\n\t    }\n\t    /* We need to handle iteration of double byte strings properly */\n\t    if (!isIterable(iterable) && typeof iterable === 'string') {\n\t        var l = iterable.length;\n\t        for (var i = 0; i < l; ++i) {\n\t            var char = iterable[i];\n\t            if ((i + 1) < l) {\n\t                var code = char.charCodeAt(0);\n\t                if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n\t                    char += iterable[++i];\n\t                }\n\t            }\n\t            callback.call(thisArg, char, iterable, doBreak);\n\t            if (broken) {\n\t                return;\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        var iterator = get(iterable);\n\t        if (iterator) {\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callback.call(thisArg, result.value, iterable, doBreak);\n\t                if (broken) {\n\t                    return;\n\t                }\n\t                result = iterator.next();\n\t            }\n\t        }\n\t    }\n\t}\n\texports.forOf = forOf;\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(20);\n\tvar util_1 = __webpack_require__(26);\n\t/**\n\t * The minimum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MIN = 0xD800;\n\t/**\n\t * The maximum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MAX = 0xDBFF;\n\t/**\n\t * The minimum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MIN = 0xDC00;\n\t/**\n\t * The maximum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MAX = 0xDFFF;\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t     * Used by startsWith, includes, and endsWith.\n\t     *\n\t     * @return Normalized position.\n\t     */\n\t    function normalizeSubstringArgs(name, text, search, position, isEnd) {\n\t        if (isEnd === void 0) { isEnd = false; }\n\t        if (text == null) {\n\t            throw new TypeError('string.' + name + ' requires a valid string to search against.');\n\t        }\n\t        var length = text.length;\n\t        position = position !== position ? (isEnd ? length : 0) : position;\n\t        return [text, String(search), Math.min(Math.max(position, 0), length)];\n\t    }\n\t    function raw(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        var rawStrings = callSite.raw;\n\t        var result = '';\n\t        var numSubstitutions = substitutions.length;\n\t        if (callSite == null || callSite.raw == null) {\n\t            throw new TypeError('string.raw requires a valid callSite object with a raw value');\n\t        }\n\t        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n\t            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n\t        }\n\t        return result;\n\t    }\n\t    Shim.raw = raw;\n\t    function fromCodePoint() {\n\t        var codePoints = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            codePoints[_i - 0] = arguments[_i];\n\t        }\n\t        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t        var length = arguments.length;\n\t        if (!length) {\n\t            return '';\n\t        }\n\t        var fromCharCode = String.fromCharCode;\n\t        var MAX_SIZE = 0x4000;\n\t        var codeUnits = [];\n\t        var index = -1;\n\t        var result = '';\n\t        while (++index < length) {\n\t            var codePoint = Number(arguments[index]);\n\t            // Code points must be finite integers within the valid range\n\t            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t                codePoint >= 0 && codePoint <= 0x10FFFF;\n\t            if (!isValid) {\n\t                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t            }\n\t            if (codePoint <= 0xFFFF) {\n\t                // BMP code point\n\t                codeUnits.push(codePoint);\n\t            }\n\t            else {\n\t                // Astral code point; split in surrogate halves\n\t                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t                codePoint -= 0x10000;\n\t                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n\t                var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n\t                codeUnits.push(highSurrogate, lowSurrogate);\n\t            }\n\t            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t                result += fromCharCode.apply(null, codeUnits);\n\t                codeUnits.length = 0;\n\t            }\n\t        }\n\t        return result;\n\t    }\n\t    Shim.fromCodePoint = fromCodePoint;\n\t    function codePointAt(text, position) {\n\t        if (position === void 0) { position = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t        if (text == null) {\n\t            throw new TypeError('string.codePointAt requries a valid string.');\n\t        }\n\t        var length = text.length;\n\t        if (position !== position) {\n\t            position = 0;\n\t        }\n\t        if (position < 0 || position >= length) {\n\t            return undefined;\n\t        }\n\t        // Get the first code unit\n\t        var first = text.charCodeAt(position);\n\t        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n\t            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t            var second = text.charCodeAt(position + 1);\n\t            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n\t                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n\t            }\n\t        }\n\t        return first;\n\t    }\n\t    Shim.codePointAt = codePointAt;\n\t    /* TODO: Missing normalize */\n\t    function repeat(text, count) {\n\t        if (count === void 0) { count = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t        if (text == null) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (count !== count) {\n\t            count = 0;\n\t        }\n\t        if (count < 0 || count === Infinity) {\n\t            throw new RangeError('string.repeat requires a non-negative finite count.');\n\t        }\n\t        var result = '';\n\t        while (count) {\n\t            if (count % 2) {\n\t                result += text;\n\t            }\n\t            if (count > 1) {\n\t                text += text;\n\t            }\n\t            count >>= 1;\n\t        }\n\t        return result;\n\t    }\n\t    Shim.repeat = repeat;\n\t    function startsWith(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        search = String(search);\n\t        _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        var end = position + search.length;\n\t        if (end > text.length) {\n\t            return false;\n\t        }\n\t        return text.slice(position, end) === search;\n\t        var _a;\n\t    }\n\t    Shim.startsWith = startsWith;\n\t    function endsWith(text, search, endPosition) {\n\t        if (endPosition == null) {\n\t            endPosition = text.length;\n\t        }\n\t        _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n\t        var start = endPosition - search.length;\n\t        if (start < 0) {\n\t            return false;\n\t        }\n\t        return text.slice(start, endPosition) === search;\n\t        var _a;\n\t    }\n\t    Shim.endsWith = endsWith;\n\t    function includes(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        return text.indexOf(search, position) !== -1;\n\t        var _a;\n\t    }\n\t    Shim.includes = includes;\n\t    function padEnd(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padEnd requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padEnd = padEnd;\n\t    function padStart(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padStart requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padStart = padStart;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/**\n\t * A tag function for template strings to get the template string's raw string form.\n\t *\n\t * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n\t * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n\t * @return String containing the raw template string with variables substituted\n\t *\n\t * @example\n\t * // Within TypeScript; logs 'The answer is:\\\\n42'\n\t * let answer = 42;\n\t * console.log(string.raw`The answer is:\\n${answer}`);\n\t *\n\t * @example\n\t * // The same example as above, but directly specifying a JavaScript object and substitution\n\t * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n\t */\n\texports.raw = has_1.default('es6-string-raw')\n\t    ? String.raw\n\t    : Shim.raw;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n\t    ? String.fromCodePoint\n\t    : Shim.fromCodePoint;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.codePointAt = has_1.default('es6-string-codepointat')\n\t    ? util_1.wrapNative(String.prototype.codePointAt)\n\t    : Shim.codePointAt;\n\t/**\n\t * Returns a string containing the given string repeated the specified number of times.\n\t *\n\t * @param text The string to repeat\n\t * @param count The number of times to repeat the string\n\t * @return A string containing the input string repeated count times\n\t */\n\texports.repeat = has_1.default('es6-string-repeat')\n\t    ? util_1.wrapNative(String.prototype.repeat)\n\t    : Shim.repeat;\n\t/**\n\t * Determines whether a string begins with the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found at the beginning of the given string\n\t */\n\texports.startsWith = has_1.default('es6-string-startswith')\n\t    ? util_1.wrapNative(String.prototype.startsWith)\n\t    : Shim.startsWith;\n\t/**\n\t * Determines whether a string ends with the given substring.\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param endPosition The index searching should stop before (defaults to text.length)\n\t * @return Boolean indicating if the search string was found at the end of the given string\n\t */\n\texports.endsWith = has_1.default('es6-string-endswith')\n\t    ? util_1.wrapNative(String.prototype.endsWith)\n\t    : Shim.endsWith;\n\t/**\n\t * Determines whether a string includes the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found within the given string\n\t */\n\texports.includes = has_1.default('es6-string-includes')\n\t    ? util_1.wrapNative(String.prototype.includes)\n\t    : Shim.includes;\n\t/**\n\t * Pads the beginning of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded in the front if necessary.\n\t */\n\texports.padStart = has_1.default('es6-string-padstart')\n\t    ? util_1.wrapNative(String.prototype.padStart)\n\t    : Shim.padStart;\n\t/**\n\t * Pads the end of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded at the end if necessary.\n\t */\n\texports.padEnd = has_1.default('es6-string-padend')\n\t    ? util_1.wrapNative(String.prototype.padEnd)\n\t    : Shim.padEnd;\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(20);\n\tvar global_1 = __webpack_require__(21);\n\tvar util_1 = __webpack_require__(26);\n\tvar Shim;\n\t(function (Shim) {\n\t    /* tslint:disable-next-line:variable-name */\n\t    var Symbol;\n\t    /* tslint:disable-next-line:variable-name */\n\t    var InternalSymbol;\n\t    var defineProperties = Object.defineProperties;\n\t    var defineProperty = Object.defineProperty;\n\t    var create = Object.create;\n\t    var objPrototype = Object.prototype;\n\t    var globalSymbols = {};\n\t    var getSymbolName = (function () {\n\t        var created = create(null);\n\t        return function (desc) {\n\t            var postfix = 0;\n\t            var name;\n\t            while (created[String(desc) + (postfix || '')]) {\n\t                ++postfix;\n\t            }\n\t            desc += String(postfix || '');\n\t            created[desc] = true;\n\t            name = '@@' + desc;\n\t            // FIXME: Temporary guard until the duplicate execution when testing can be\n\t            // pinned down.\n\t            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t                defineProperty(objPrototype, name, {\n\t                    set: function (value) {\n\t                        defineProperty(this, name, util_1.getValueDescriptor(value));\n\t                    }\n\t                });\n\t            }\n\t            return name;\n\t        };\n\t    }());\n\t    InternalSymbol = function Symbol(description) {\n\t        if (this instanceof InternalSymbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        return Symbol(description);\n\t    };\n\t    Symbol = function Symbol(description) {\n\t        if (this instanceof Symbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        var sym = Object.create(InternalSymbol.prototype);\n\t        description = (description === undefined ? '' : String(description));\n\t        return defineProperties(sym, {\n\t            __description__: util_1.getValueDescriptor(description),\n\t            __name__: util_1.getValueDescriptor(getSymbolName(description))\n\t        });\n\t    };\n\t    /**\n\t     * A custom guard function that determines if an object is a symbol or not\n\t     * @param  {any}       value The value to check to see if it is a symbol or not\n\t     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t     */\n\t    function isSymbol(value) {\n\t        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t    }\n\t    Shim.isSymbol = isSymbol;\n\t    /**\n\t     * Throws if the value is not a symbol, used internally within the Shim\n\t     * @param  {any}    value The value to check\n\t     * @return {symbol}       Returns the symbol or throws\n\t     */\n\t    function validateSymbol(value) {\n\t        if (!isSymbol(value)) {\n\t            throw new TypeError(value + ' is not a symbol');\n\t        }\n\t        return value;\n\t    }\n\t    /* Decorate the Symbol function with the appropriate properties */\n\t    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n\t        if (globalSymbols[key]) {\n\t            return globalSymbols[key];\n\t        }\n\t        return (globalSymbols[key] = Symbol(String(key)));\n\t    }));\n\t    defineProperties(Symbol, {\n\t        keyFor: util_1.getValueDescriptor(function (sym) {\n\t            var key;\n\t            validateSymbol(sym);\n\t            for (key in globalSymbols) {\n\t                if (globalSymbols[key] === sym) {\n\t                    return key;\n\t                }\n\t            }\n\t        }),\n\t        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n\t        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n\t        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),\n\t        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n\t        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n\t        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n\t        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n\t        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t    });\n\t    /* Decorate the InternalSymbol object */\n\t    defineProperties(InternalSymbol.prototype, {\n\t        constructor: util_1.getValueDescriptor(Symbol),\n\t        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n\t    });\n\t    /* Decorate the Symbol.prototype */\n\t    defineProperties(Symbol.prototype, {\n\t        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\t        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n\t    });\n\t    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n\t    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\t    /* tslint:disable-next-line:variable-name */\n\t    Shim.Exposed = Symbol;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/* tslint:disable-next-line:variable-name */\n\tvar SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n\t/**\n\t * Fill any missing well known symbols if the native Symbol is missing them\n\t */\n\t['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t    'toStringTag', 'unscopables', 'observable'].forEach(function (wellKnown) {\n\t    if (!Symbol[wellKnown]) {\n\t        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t    }\n\t});\n\texports.isSymbol = Shim.isSymbol;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = SymbolShim;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(21);\n\t/**\n\t * The smallest interval between two representable numbers.\n\t */\n\texports.EPSILON = 1;\n\t/**\n\t * The maximum safe integer in JavaScript\n\t */\n\texports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t/**\n\t * The minimum safe integer in JavaScript\n\t */\n\texports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n\t/**\n\t * Determines whether the passed value is NaN without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is NaN, false if it is not\n\t */\n\tfunction isNaN(value) {\n\t    return typeof value === 'number' && global_1.default.isNaN(value);\n\t}\n\texports.isNaN = isNaN;\n\t/**\n\t * Determines whether the passed value is a finite number without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is finite, false if it is not\n\t */\n\tfunction isFinite(value) {\n\t    return typeof value === 'number' && global_1.default.isFinite(value);\n\t}\n\texports.isFinite = isFinite;\n\t/**\n\t * Determines whether the passed value is an integer.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isInteger(value) {\n\t    return isFinite(value) && Math.floor(value) === value;\n\t}\n\texports.isInteger = isInteger;\n\t/**\n\t * Determines whether the passed value is an integer that is 'safe,' meaning:\n\t *   1. it can be expressed as an IEEE-754 double precision number\n\t *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n\t *      IEEE-754 representation cannot be the result of rounding any other\n\t *      integer to fit the IEEE-754 representation\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isSafeInteger(value) {\n\t    return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n\t}\n\texports.isSafeInteger = isSafeInteger;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(32);\n\tvar global_1 = __webpack_require__(21);\n\tvar iterator_1 = __webpack_require__(27);\n\t__webpack_require__(29);\n\tvar Shim;\n\t(function (Shim) {\n\t    var DELETED = {};\n\t    function getUID() {\n\t        return Math.floor(Math.random() * 100000000);\n\t    }\n\t    var generateName = (function () {\n\t        var startId = Math.floor(Date.now() % 100000000);\n\t        return function generateName() {\n\t            return '__wm' + getUID() + (startId++ + '__');\n\t        };\n\t    })();\n\t    var WeakMap = (function () {\n\t        function WeakMap(iterable) {\n\t            var _this = this;\n\t            this[Symbol.toStringTag] = 'WeakMap';\n\t            Object.defineProperty(this, '_name', {\n\t                value: generateName()\n\t            });\n\t            this._frozenEntries = [];\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (_a) {\n\t                    var key = _a[0], value = _a[1];\n\t                    return _this.set(key, value);\n\t                });\n\t            }\n\t        }\n\t        WeakMap.prototype._getFrozenEntryIndex = function (key) {\n\t            for (var i = 0; i < this._frozenEntries.length; i++) {\n\t                if (this._frozenEntries[i].key === key) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        WeakMap.prototype.delete = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                entry.value = DELETED;\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                this._frozenEntries.splice(frozenIndex, 1);\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.get = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return undefined;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                return entry.value;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return this._frozenEntries[frozenIndex].value;\n\t            }\n\t        };\n\t        WeakMap.prototype.has = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.set = function (key, value) {\n\t            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t                throw new TypeError('Invalid value used as weak map key');\n\t            }\n\t            var entry = key[this._name];\n\t            if (!entry || entry.key !== key) {\n\t                entry = Object.create(null, {\n\t                    key: { value: key }\n\t                });\n\t                if (Object.isFrozen(key)) {\n\t                    this._frozenEntries.push(entry);\n\t                }\n\t                else {\n\t                    Object.defineProperty(key, this._name, {\n\t                        value: entry\n\t                    });\n\t                }\n\t            }\n\t            entry.value = value;\n\t            return this;\n\t        };\n\t        return WeakMap;\n\t    }());\n\t    Shim.WeakMap = WeakMap;\n\t})(Shim || (Shim = {}));\n\tvar WeakMap = (function () {\n\t    /* istanbul ignore next */\n\t    function WeakMap(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'WeakMap';\n\t    }\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.delete = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.get = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.has = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.set = function (key, value) { throw new Error(); };\n\t    WeakMap = __decorate([\n\t        decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n\t    ], WeakMap);\n\t    return WeakMap;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = WeakMap;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(20);\n\t/**\n\t * A class decorator that provides either a native class or a shimmed class based on a feature\n\t * test\n\t * @param feature The has feature to check\n\t * @param trueClass The class to use if feature test returns `true`\n\t * @param falseClass The class to use if the feature test returns `false` or is not defined\n\t */\n\tfunction hasClass(feature, trueClass, falseClass) {\n\t    return function (target) {\n\t        return has_1.default(feature) ? trueClass : falseClass;\n\t    };\n\t}\n\texports.hasClass = hasClass;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(31);\n\t/**\n\t * Types of advice\n\t */\n\t(function (AdviceType) {\n\t    AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n\t    AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n\t    AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n\t})(exports.AdviceType || (exports.AdviceType = {}));\n\tvar AdviceType = exports.AdviceType;\n\t/**\n\t * A weak map of dispatchers used to apply the advice\n\t */\n\tvar dispatchAdviceMap = new WeakMap_1.default();\n\t/**\n\t * Returns the dispatcher function for a given joinPoint (method/function)\n\t *\n\t * @param joinPoint The function that is to be advised\n\t */\n\tfunction getDispatcher(joinPoint) {\n\t    function dispatcher() {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n\t        if (before) {\n\t            args = before.reduce(function (previousArgs, advice) {\n\t                var currentArgs = advice.apply(_this, previousArgs);\n\t                return currentArgs || previousArgs;\n\t            }, args);\n\t        }\n\t        var result = joinPoint.apply(this, args);\n\t        if (after) {\n\t            result = after.reduce(function (previousResult, advice) {\n\t                return advice.apply(_this, [previousResult].concat(args));\n\t            }, result);\n\t        }\n\t        return result;\n\t    }\n\t    /* We want to \"clone\" the advice that has been applied already, if this\n\t     * joinPoint is already advised */\n\t    if (dispatchAdviceMap.has(joinPoint)) {\n\t        var adviceMap = dispatchAdviceMap.get(joinPoint);\n\t        var before_1 = adviceMap.before, after_1 = adviceMap.after;\n\t        if (before_1) {\n\t            before_1 = before_1.slice(0);\n\t        }\n\t        if (after_1) {\n\t            after_1 = after_1.slice(0);\n\t        }\n\t        dispatchAdviceMap.set(dispatcher, {\n\t            joinPoint: adviceMap.joinPoint,\n\t            before: before_1,\n\t            after: after_1\n\t        });\n\t    }\n\t    else {\n\t        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Advise a join point (function) with supplied advice\n\t *\n\t * @param joinPoint The function to be advised\n\t * @param type The type of advice to be applied\n\t * @param advice The advice to apply\n\t */\n\tfunction advise(joinPoint, type, advice) {\n\t    var dispatcher;\n\t    if (type === AdviceType.Around) {\n\t        dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n\t    }\n\t    else {\n\t        dispatcher = getDispatcher(joinPoint);\n\t        var adviceMap = dispatchAdviceMap.get(dispatcher);\n\t        if (type === AdviceType.Before) {\n\t            (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n\t        }\n\t        else {\n\t            (adviceMap.after || (adviceMap.after = [])).push(advice);\n\t        }\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Apply advice *before* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The before advice\n\t */\n\tfunction before(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Before, advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Apply advice *after* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The after advice\n\t */\n\tfunction after(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.After, advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Apply advice *around* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The around advice\n\t */\n\tfunction around(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Around, advice);\n\t}\n\texports.around = around;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\t/**\n\t * Parses a query string, returning a ParamList object.\n\t */\n\tfunction parseQueryString(input) {\n\t    var query = {};\n\t    for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n\t        var entry = _a[_i];\n\t        var indexOfFirstEquals = entry.indexOf('=');\n\t        var key = void 0;\n\t        var value = '';\n\t        if (indexOfFirstEquals >= 0) {\n\t            key = entry.slice(0, indexOfFirstEquals);\n\t            value = entry.slice(indexOfFirstEquals + 1);\n\t        }\n\t        else {\n\t            key = entry;\n\t        }\n\t        key = key ? decodeURIComponent(key) : '';\n\t        value = value ? decodeURIComponent(value) : '';\n\t        if (key in query) {\n\t            query[key].push(value);\n\t        }\n\t        else {\n\t            query[key] = [value];\n\t        }\n\t    }\n\t    return query;\n\t}\n\t/**\n\t * Represents a set of URL query search parameters.\n\t */\n\tvar UrlSearchParams = (function () {\n\t    /**\n\t     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t     * UrlSearchParams.\n\t     */\n\t    function UrlSearchParams(input) {\n\t        var list;\n\t        if (input instanceof UrlSearchParams) {\n\t            // Copy the incoming UrlSearchParam's internal list\n\t            list = lang_1.duplicate(input._list);\n\t        }\n\t        else if (typeof input === 'object') {\n\t            // Copy the incoming object, assuming its property values are either arrays or strings\n\t            list = {};\n\t            for (var key in input) {\n\t                var value = input[key];\n\t                if (Array.isArray(value)) {\n\t                    list[key] = value.length ? value.slice() : [''];\n\t                }\n\t                else if (value == null) {\n\t                    list[key] = [''];\n\t                }\n\t                else {\n\t                    list[key] = [value];\n\t                }\n\t            }\n\t        }\n\t        else if (typeof input === 'string') {\n\t            // Parse the incoming string as a query string\n\t            list = parseQueryString(input);\n\t        }\n\t        else {\n\t            list = {};\n\t        }\n\t        Object.defineProperty(this, '_list', { value: list });\n\t    }\n\t    /**\n\t     * Appends a new value to the set of values for a key.\n\t     * @param key The key to add a value for\n\t     * @param value The value to add\n\t     */\n\t    UrlSearchParams.prototype.append = function (key, value) {\n\t        if (!this.has(key)) {\n\t            this.set(key, value);\n\t        }\n\t        else {\n\t            var values = this._list[key];\n\t            if (values) {\n\t                values.push(value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Deletes all values for a key.\n\t     * @param key The key whose values are to be removed\n\t     */\n\t    UrlSearchParams.prototype.delete = function (key) {\n\t        // Set to undefined rather than deleting the key, for better consistency across browsers.\n\t        // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t        // its original position.  This approach maintains the original position everywhere.\n\t        this._list[key] = undefined;\n\t    };\n\t    /**\n\t     * Returns the first value associated with a key.\n\t     * @param key The key to return the first value for\n\t     * @return The first string value for the key\n\t     */\n\t    UrlSearchParams.prototype.get = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        var value = this._list[key];\n\t        return value ? value[0] : undefined;\n\t    };\n\t    /**\n\t     * Returns all the values associated with a key.\n\t     * @param key The key to return all values for\n\t     * @return An array of strings containing all values for the key\n\t     */\n\t    UrlSearchParams.prototype.getAll = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        return this._list[key];\n\t    };\n\t    /**\n\t     * Returns true if a key has been set to any value, false otherwise.\n\t     * @param key The key to test for existence\n\t     * @return A boolean indicating if the key has been set\n\t     */\n\t    UrlSearchParams.prototype.has = function (key) {\n\t        return Array.isArray(this._list[key]);\n\t    };\n\t    /**\n\t     * Returns an array of all keys which have been set.\n\t     * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t     */\n\t    UrlSearchParams.prototype.keys = function () {\n\t        var keys = [];\n\t        for (var key in this._list) {\n\t            if (this.has(key)) {\n\t                keys.push(key);\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\t    /**\n\t     * Sets the value associated with a key.\n\t     * @param key The key to set the value of\n\t     */\n\t    UrlSearchParams.prototype.set = function (key, value) {\n\t        this._list[key] = [value];\n\t    };\n\t    /**\n\t     * Returns this object's data as an encoded query string.\n\t     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t     */\n\t    UrlSearchParams.prototype.toString = function () {\n\t        var query = [];\n\t        for (var key in this._list) {\n\t            if (!this.has(key)) {\n\t                continue;\n\t            }\n\t            var values = this._list[key];\n\t            if (values) {\n\t                var encodedKey = encodeURIComponent(key);\n\t                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n\t                    var value = values_1[_i];\n\t                    query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t                }\n\t            }\n\t        }\n\t        return query.join('&');\n\t    };\n\t    return UrlSearchParams;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = UrlSearchParams;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar Task_1 = __webpack_require__(45);\n\tvar on_1 = __webpack_require__(47);\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\tvar array_1 = __webpack_require__(25);\n\tvar Promise_1 = __webpack_require__(41);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar path_1 = __webpack_require__(48);\n\tvar parentMap = new WeakMap_1.default();\n\tfunction hasBeenAppended(route) {\n\t    return parentMap.has(route) || route.parent !== undefined;\n\t}\n\texports.hasBeenAppended = hasBeenAppended;\n\tvar privateStateMap = new WeakMap_1.default();\n\t// istanbul ignore next\n\tvar noop = function () { };\n\tfunction createDeferral() {\n\t    // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\t    var cancel = noop;\n\t    var resume = noop;\n\t    var promise = new Promise_1.default(function (resolve, reject) {\n\t        cancel = reject;\n\t        // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t        resume = function () { return resolve(); };\n\t    });\n\t    return { cancel: cancel, promise: promise, resume: resume };\n\t}\n\tfunction reportError(router, context, path, error) {\n\t    router.emit({\n\t        context: context,\n\t        error: error,\n\t        path: path,\n\t        target: router,\n\t        type: 'error'\n\t    });\n\t}\n\tfunction catchRejection(router, context, path, thenable) {\n\t    if (thenable) {\n\t        Promise_1.default.resolve(thenable).catch(function (error) {\n\t            reportError(router, context, path, error);\n\t        });\n\t    }\n\t}\n\tvar createRouter = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        append: function (add) {\n\t            var _this = this;\n\t            var routes = privateStateMap.get(this).routes;\n\t            var append = function (route) {\n\t                if (hasBeenAppended(route)) {\n\t                    throw new Error('Cannot append route that has already been appended');\n\t                }\n\t                routes.push(route);\n\t                parentMap.set(route, _this);\n\t            };\n\t            if (Array.isArray(add)) {\n\t                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                    var route = add_1[_i];\n\t                    append(route);\n\t                }\n\t            }\n\t            else {\n\t                append(add);\n\t            }\n\t        },\n\t        dispatch: function (context, path) {\n\t            var _this = this;\n\t            var state = privateStateMap.get(this);\n\t            var dispatchFromStart = state.dispatchFromStart;\n\t            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t            // may call dispatch() themselves.\n\t            state.dispatchFromStart = false;\n\t            var canceled = false;\n\t            var cancel = function () {\n\t                canceled = true;\n\t            };\n\t            var deferrals = [];\n\t            this.emit({\n\t                cancel: cancel,\n\t                defer: function () {\n\t                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n\t                    deferrals.push(promise);\n\t                    return { cancel: cancel, resume: resume };\n\t                },\n\t                path: path,\n\t                target: this,\n\t                type: 'navstart'\n\t            });\n\t            // Synchronous cancelation.\n\t            if (canceled) {\n\t                return Task_1.default.resolve({ success: false });\n\t            }\n\t            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n\t            return new Task_1.default(function (resolve, reject) {\n\t                // *Always* start dispatching in a future turn, even if there were no deferrals.\n\t                Promise_1.default.all(deferrals).then(function () {\n\t                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t                    // manages to do so before this turn.\n\t                    if (canceled) {\n\t                        return { success: false };\n\t                    }\n\t                    var fallback = state.fallback, routes = state.routes;\n\t                    var redirect;\n\t                    var dispatched = routes.some(function (route) {\n\t                        var result = route.select(context, segments, trailingSlash, searchParams);\n\t                        if (typeof result === 'string') {\n\t                            redirect = result;\n\t                            return true;\n\t                        }\n\t                        if (result.length === 0) {\n\t                            return false;\n\t                        }\n\t                        // Update the selected routes after selecting new routes, but before invoking the handlers.\n\t                        // This means the original value is available to guard() and params() functions, and the\n\t                        // new value when the newly selected routes are executed.\n\t                        //\n\t                        // Reset selected routes if not dispatched from start().\n\t                        state.currentSelection = dispatchFromStart ? result : [];\n\t                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n\t                            var _a = result_1[_i], handler = _a.handler, params = _a.params;\n\t                            catchRejection(_this, context, path, handler({ context: context, params: params }));\n\t                        }\n\t                        return true;\n\t                    });\n\t                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t                    if (!dispatched || redirect !== undefined) {\n\t                        state.currentSelection = [];\n\t                    }\n\t                    if (!dispatched && fallback) {\n\t                        catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n\t                        return { success: false };\n\t                    }\n\t                    var result = { success: dispatched };\n\t                    if (redirect !== undefined) {\n\t                        result.redirect = redirect;\n\t                    }\n\t                    return result;\n\t                }, \n\t                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t                // with `false` instead of being rejected too.\n\t                function () {\n\t                    return { success: false };\n\t                }).then(resolve, function (error) {\n\t                    reportError(_this, context, path, error);\n\t                    reject(error);\n\t                });\n\t            }, cancel);\n\t        },\n\t        link: function (route, params) {\n\t            if (params === void 0) { params = {}; }\n\t            var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n\t            var hierarchy = [route];\n\t            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n\t                hierarchy.unshift(parent_1);\n\t            }\n\t            if (!array_1.includes(roots, hierarchy[0])) {\n\t                throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t            }\n\t            var addLeadingSlash = hierarchy[0].path.leadingSlash;\n\t            var addTrailingSlash = false;\n\t            var segments = [];\n\t            var searchParams = new UrlSearchParams_1.default();\n\t            hierarchy\n\t                .map(function (route, index) {\n\t                var path = route.path;\n\t                var currentPathValues;\n\t                var currentSearchParams;\n\t                var selection = currentSelection[index];\n\t                if (selection && selection.route === route) {\n\t                    currentPathValues = selection.rawPathValues;\n\t                    currentSearchParams = selection.rawSearchParams;\n\t                }\n\t                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n\t            })\n\t                .forEach(function (_a) {\n\t                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n\t                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n\t                addTrailingSlash = trailingSlash;\n\t                var namedOffset = 0;\n\t                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n\t                    var segment = expectedSegments_1[_i];\n\t                    if (path_1.isNamedSegment(segment)) {\n\t                        var value = params[segment.name];\n\t                        if (typeof value === 'string') {\n\t                            segments.push(value);\n\t                        }\n\t                        else if (Array.isArray(value)) {\n\t                            if (value.length === 1) {\n\t                                segments.push(value[0]);\n\t                            }\n\t                            else {\n\t                                throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n\t                            }\n\t                        }\n\t                        else if (currentPathValues) {\n\t                            segments.push(currentPathValues[namedOffset]);\n\t                        }\n\t                        else {\n\t                            throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n\t                        }\n\t                        namedOffset++;\n\t                    }\n\t                    else {\n\t                        segments.push(segment.literal);\n\t                    }\n\t                }\n\t                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n\t                    var key = searchParameters_1[_b];\n\t                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t                    // it.\n\t                    if (searchParams.has(key)) {\n\t                        continue;\n\t                    }\n\t                    var value = params[key];\n\t                    if (typeof value === 'string') {\n\t                        searchParams.append(key, value);\n\t                    }\n\t                    else if (Array.isArray(value)) {\n\t                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n\t                            var item = value_1[_c];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else if (currentSearchParams) {\n\t                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n\t                            var item = _e[_d];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else {\n\t                        throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n\t                    }\n\t                }\n\t            });\n\t            var pathname = segments.join('/');\n\t            if (addLeadingSlash) {\n\t                pathname = '/' + pathname;\n\t            }\n\t            if (addTrailingSlash) {\n\t                pathname += '/';\n\t            }\n\t            if (history) {\n\t                pathname = history.prefix(pathname);\n\t            }\n\t            var search = searchParams.toString();\n\t            var path = search ? pathname + \"?\" + search : pathname;\n\t            return path;\n\t        },\n\t        start: function (_a) {\n\t            var _this = this;\n\t            var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n\t            var state = privateStateMap.get(this);\n\t            if (state.started) {\n\t                throw new Error('start can only be called once');\n\t            }\n\t            state.started = true;\n\t            var contextFactory = state.contextFactory, history = state.history;\n\t            if (!history) {\n\t                return {\n\t                    pause: function () { },\n\t                    resume: function () { },\n\t                    destroy: function () { }\n\t                };\n\t            }\n\t            var lastDispatch;\n\t            var redirectCount = 0;\n\t            var redirecting = false;\n\t            var dispatch = function (path) {\n\t                if (lastDispatch) {\n\t                    lastDispatch.cancel();\n\t                }\n\t                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t                // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t                // redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t                if (!redirecting) {\n\t                    redirectCount = 0;\n\t                }\n\t                // Signal to dispatch() that it was called from here.\n\t                state.dispatchFromStart = true;\n\t                var context = contextFactory();\n\t                lastDispatch = _this.dispatch(context, path).then(function (_a) {\n\t                    var redirect = _a.redirect, success = _a.success;\n\t                    if (success && redirect !== undefined) {\n\t                        redirectCount++;\n\t                        if (redirectCount > 20) {\n\t                            var error = new Error('More than 20 redirects, giving up');\n\t                            reportError(_this, context, path, error);\n\t                            throw error;\n\t                        }\n\t                        redirecting = true;\n\t                        // The history manager MUST emit the change event synchronously.\n\t                        history.replace(redirect);\n\t                        redirecting = false;\n\t                    }\n\t                });\n\t            };\n\t            var listener = on_1.pausable(history, 'change', function (event) {\n\t                dispatch(event.value);\n\t            });\n\t            this.own(listener);\n\t            if (dispatchCurrent) {\n\t                dispatch(history.current);\n\t            }\n\t            return listener;\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n\t        var contextFactory;\n\t        if (typeof context === 'function') {\n\t            contextFactory = context;\n\t        }\n\t        else if (typeof context === 'undefined') {\n\t            contextFactory = function () {\n\t                return {};\n\t            };\n\t        }\n\t        else {\n\t            // Assign to a constant since the context variable may be changed after the function is defined,\n\t            // which would violate its typing.\n\t            var sharedContext_1 = context;\n\t            contextFactory = function () { return sharedContext_1; };\n\t        }\n\t        if (history) {\n\t            instance.own(history);\n\t        }\n\t        privateStateMap.set(instance, {\n\t            contextFactory: contextFactory,\n\t            currentSelection: [],\n\t            dispatchFromStart: false,\n\t            fallback: fallback,\n\t            history: history,\n\t            routes: []\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRouter;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar aspect_1 = __webpack_require__(37);\n\tvar Map_1 = __webpack_require__(38);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar compose_1 = __webpack_require__(16);\n\tvar createDestroyable_1 = __webpack_require__(40);\n\t/**\n\t * A weak map that contains a map of the listeners for an `Evented`\n\t */\n\tvar listenersMap = new WeakMap_1.default();\n\t/**\n\t * A guard which determines if the value is `Actionable`\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isActionable(value) {\n\t    return Boolean(value && typeof value.do === 'function');\n\t}\n\t/**\n\t * An internal function that always returns an EventedCallback\n\t *\n\t * @param listener Either a `EventedCallback` or an `Actionable`\n\t */\n\tfunction resolveListener(listener) {\n\t    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n\t}\n\texports.resolveListener = resolveListener;\n\t/**\n\t * Internal function to convert an array of handles to a single handle\n\t *\n\t * @param handles The array of handles to convert into a signle handle\n\t * @return The single handle\n\t */\n\tfunction handlesArraytoHandle(handles) {\n\t    return {\n\t        destroy: function () {\n\t            handles.forEach(function (handle) { return handle.destroy(); });\n\t        }\n\t    };\n\t}\n\t/**\n\t * Creates a new instance of an `Evented`\n\t */\n\tvar createEvented = compose_1.default({\n\t    emit: function (event) {\n\t        var method = listenersMap.get(this).get(event.type);\n\t        if (method) {\n\t            method.call(this, event);\n\t        }\n\t    },\n\t    on: function () {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        var listenerMap = listenersMap.get(this);\n\t        if (args.length === 2) {\n\t            var _a = args, type_1 = _a[0], listeners = _a[1];\n\t            if (Array.isArray(listeners)) {\n\t                var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n\t                return handlesArraytoHandle(handles);\n\t            }\n\t            else {\n\t                return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n\t            }\n\t        }\n\t        else if (args.length === 1) {\n\t            var listenerMapArg_1 = args[0];\n\t            var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n\t            return handlesArraytoHandle(handles);\n\t        }\n\t        else {\n\t            throw new TypeError('Invalid arguments');\n\t        }\n\t    }\n\t})\n\t    .mixin({\n\t    className: 'Evented',\n\t    mixin: createDestroyable_1.default,\n\t    initialize: function (instance, options) {\n\t        /* Initialise listener map */\n\t        listenersMap.set(instance, new Map_1.default());\n\t        if (options && options.listeners) {\n\t            instance.own(instance.on(options.listeners));\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createEvented;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\t/**\n\t * An internal type guard that determines if an value is MapLike or not\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isMapLike(value) {\n\t    return value && typeof value.get === 'function' && typeof value.set === 'function';\n\t}\n\t/**\n\t * A UID for tracking advice ordering\n\t */\n\tvar nextId = 0;\n\t/**\n\t * Internal function that advises a join point\n\t *\n\t * @param dispatcher The current advice dispatcher\n\t * @param type The type of before or after advice to apply\n\t * @param advice The advice to apply\n\t * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n\t * @return The handle that will remove the advice\n\t */\n\tfunction advise(dispatcher, type, advice, receiveArguments) {\n\t    var previous = dispatcher && dispatcher[type];\n\t    var advised = {\n\t        id: nextId++,\n\t        advice: advice,\n\t        receiveArguments: receiveArguments\n\t    };\n\t    if (previous) {\n\t        if (type === 'after') {\n\t            // add the listener to the end of the list\n\t            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t            while (previous.next && (previous = previous.next)) { }\n\t            previous.next = advised;\n\t            advised.previous = previous;\n\t        }\n\t        else {\n\t            // add to the beginning\n\t            if (dispatcher) {\n\t                dispatcher.before = advised;\n\t            }\n\t            advised.next = previous;\n\t            previous.previous = advised;\n\t        }\n\t    }\n\t    else {\n\t        dispatcher && (dispatcher[type] = advised);\n\t    }\n\t    advice = previous = undefined;\n\t    return lang_1.createHandle(function () {\n\t        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n\t        if (dispatcher && !previous && !next) {\n\t            dispatcher[type] = undefined;\n\t        }\n\t        else {\n\t            if (previous) {\n\t                previous.next = next;\n\t            }\n\t            else {\n\t                dispatcher && (dispatcher[type] = next);\n\t            }\n\t            if (next) {\n\t                next.previous = previous;\n\t            }\n\t        }\n\t        if (advised) {\n\t            delete advised.advice;\n\t        }\n\t        dispatcher = advised = undefined;\n\t    });\n\t}\n\t/**\n\t * An internal function that resolves or creates the dispatcher for a given join point\n\t *\n\t * @param target The target object or map\n\t * @param methodName The name of the method that the dispatcher should be resolved for\n\t * @return The dispatcher\n\t */\n\tfunction getDispatcher(target, methodName) {\n\t    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\t    var dispatcher;\n\t    if (!existing || existing.target !== target) {\n\t        /* There is no existing dispatcher, therefore we will create one */\n\t        dispatcher = function () {\n\t            var executionId = nextId;\n\t            var args = arguments;\n\t            var results;\n\t            var before = dispatcher.before;\n\t            while (before) {\n\t                if (before.advice) {\n\t                    args = before.advice.apply(this, args) || args;\n\t                }\n\t                before = before.next;\n\t            }\n\t            if (dispatcher.around && dispatcher.around.advice) {\n\t                results = dispatcher.around.advice(this, args);\n\t            }\n\t            var after = dispatcher.after;\n\t            while (after && after.id < executionId) {\n\t                if (after.advice) {\n\t                    if (after.receiveArguments) {\n\t                        var newResults = after.advice.apply(this, args);\n\t                        results = newResults === undefined ? results : newResults;\n\t                    }\n\t                    else {\n\t                        results = after.advice.call(this, results, args);\n\t                    }\n\t                }\n\t                after = after.next;\n\t            }\n\t            return results;\n\t        };\n\t        if (isMapLike(target)) {\n\t            target.set(methodName, dispatcher);\n\t        }\n\t        else {\n\t            target && (target[methodName] = dispatcher);\n\t        }\n\t        if (existing) {\n\t            dispatcher.around = {\n\t                advice: function (target, args) {\n\t                    return existing.apply(target, args);\n\t                }\n\t            };\n\t        }\n\t        dispatcher.target = target;\n\t    }\n\t    else {\n\t        dispatcher = existing;\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Attaches \"after\" advice to be executed after the original method.\n\t * The advising function will receive the original method's return value and arguments object.\n\t * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original method's return value and arguments object\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction after(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Attaches \"around\" advice around the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original function\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction around(target, methodName, advice) {\n\t    var dispatcher = getDispatcher(target, methodName);\n\t    var previous = dispatcher.around;\n\t    var advised;\n\t    if (advice) {\n\t        advised = advice(function () {\n\t            if (previous && previous.advice) {\n\t                return previous.advice(this, arguments);\n\t            }\n\t        });\n\t    }\n\t    dispatcher.around = {\n\t        advice: function (target, args) {\n\t            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t        }\n\t    };\n\t    return lang_1.createHandle(function () {\n\t        advised = dispatcher = undefined;\n\t    });\n\t}\n\texports.around = around;\n\t/**\n\t * Attaches \"before\" advice to be executed before the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction before(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'before', advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Attaches advice to be executed after the original method.\n\t * The advising function will receive the same arguments as the original method.\n\t * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original method\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction on(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice, true);\n\t}\n\texports.on = on;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(32);\n\tvar global_1 = __webpack_require__(21);\n\tvar iterator_1 = __webpack_require__(27);\n\tvar object_1 = __webpack_require__(39);\n\t__webpack_require__(29);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * An implementation analogous to the Map specification in ES2015.\n\t     */\n\t    var Map = (function () {\n\t        /**\n\t         * Creates a new Map\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param iterator\n\t         * Array or iterator containing two-item tuples used to initially populate the map.\n\t         * The first item in each tuple corresponds to the key of the map entry.\n\t         * The second item corresponds to the value of the map entry.\n\t         */\n\t        function Map(iterable) {\n\t            var _this = this;\n\t            this._keys = [];\n\t            this._values = [];\n\t            this[Symbol.toStringTag] = 'Map';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    _this.set(value[0], value[1]);\n\t                });\n\t            }\n\t        }\n\t        /**\n\t         * An alternative to Array.prototype.indexOf using Object.is\n\t         * to check for equality. See http://mzl.la/1zuKO2V\n\t         */\n\t        Map.prototype._indexOfKey = function (keys, key) {\n\t            for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n\t                if (object_1.is(keys[i], key)) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        Object.defineProperty(Map.prototype, \"size\", {\n\t            /**\n\t             * Returns the number of key / value pairs in the Map.\n\t             *\n\t             * @return the number of key / value pairs in the Map\n\t             */\n\t            get: function () {\n\t                return this._keys.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Deletes all keys and their associated values.\n\t         */\n\t        Map.prototype.clear = function () {\n\t            this._keys.length = this._values.length = 0;\n\t        };\n\t        /**\n\t         * Deletes a given key and its associated value.\n\t         *\n\t         * @param key The key to delete\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.delete = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            if (index < 0) {\n\t                return false;\n\t            }\n\t            this._keys.splice(index, 1);\n\t            this._values.splice(index, 1);\n\t            return true;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key/value pair as an array.\n\t         *\n\t         * @return An iterator for each key/value pair in the instance.\n\t         */\n\t        Map.prototype.entries = function () {\n\t            var _this = this;\n\t            var values = this._keys.map(function (key, i) {\n\t                return [key, _this._values[i]];\n\t            });\n\t            return new iterator_1.ShimIterator(values);\n\t        };\n\t        /**\n\t         * Executes a given function for each map entry. The function\n\t         * is invoked with three arguments: the element value, the\n\t         * element key, and the associated Map instance.\n\t         *\n\t         * @param callback The function to execute for each map entry,\n\t         * @param context The value to use for `this` for each execution of the calback\n\t         */\n\t        Map.prototype.forEach = function (callback, context) {\n\t            var keys = this._keys;\n\t            var values = this._values;\n\t            for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n\t                callback.call(context, values[i], keys[i], this);\n\t            }\n\t        };\n\t        /**\n\t         * Returns the value associated with a given key.\n\t         *\n\t         * @param key The key to look up\n\t         * @return The value if one exists or undefined\n\t         */\n\t        Map.prototype.get = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            return index < 0 ? undefined : this._values[index];\n\t        };\n\t        /**\n\t         * Checks for the presence of a given key.\n\t         *\n\t         * @param key The key to check for\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.has = function (key) {\n\t            return this._indexOfKey(this._keys, key) > -1;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key in the map.\n\t         *\n\t         * @return An iterator containing the instance's keys.\n\t         */\n\t        Map.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._keys);\n\t        };\n\t        /**\n\t         * Sets the value associated with a given key.\n\t         *\n\t         * @param key The key to define a value to\n\t         * @param value The value to assign\n\t         * @return The Map instance\n\t         */\n\t        Map.prototype.set = function (key, value) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            index = index < 0 ? this._keys.length : index;\n\t            this._keys[index] = key;\n\t            this._values[index] = value;\n\t            return this;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each value in the map.\n\t         *\n\t         * @return An iterator containing the instance's values.\n\t         */\n\t        Map.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._values);\n\t        };\n\t        Map.prototype[Symbol.iterator] = function () {\n\t            return this.entries();\n\t        };\n\t        return Map;\n\t    }());\n\t    Shim.Map = Map;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Map = (function () {\n\t    /* istanbul ignore next */\n\t    function Map(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Map';\n\t    }\n\t    ;\n\t    Object.defineProperty(Map.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    Map = __decorate([\n\t        decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n\t    ], Map);\n\t    return Map;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Map;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(20);\n\tvar Symbol_1 = __webpack_require__(29);\n\tvar Shim;\n\t(function (Shim) {\n\t    function is(value1, value2) {\n\t        if (value1 === value2) {\n\t            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t        }\n\t        return value1 !== value1 && value2 !== value2; // NaN\n\t    }\n\t    Shim.is = is;\n\t    function getOwnPropertySymbols(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n\t            .map(function (key) { return Symbol.for(key.substring(2)); });\n\t    }\n\t    Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n\t    function getOwnPropertyNames(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.getOwnPropertyNames = getOwnPropertyNames;\n\t    function symbolAwareKeys(o) {\n\t        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.symbolAwareKeys = symbolAwareKeys;\n\t    function getOwnPropertyDescriptor(o, prop) {\n\t        if (Symbol_1.isSymbol(prop)) {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t        else {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t    }\n\t    Shim.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\n\t    function values(o) {\n\t        return exports.keys(o).map(function (key) { return o[key]; });\n\t    }\n\t    Shim.values = values;\n\t    function entries(o) {\n\t        return exports.keys(o).map(function (key) { return [key, o[key]]; });\n\t    }\n\t    Shim.entries = entries;\n\t})(Shim || (Shim = {}));\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param value1 The first value to compare\n\t * @param value2 The second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\texports.is = 'is' in Object\n\t    ? Object.is\n\t    : Shim.is;\n\t/**\n\t * Detect if there is native support for Symbol properties in Object\n\t */\n\tvar hasGetOwnPropertySymbols = has_1.default('es6-symbol') && 'getOwnPropertySymbols' in Object;\n\t/**\n\t * Returns an array of own properties who key is a symbol\n\t *\n\t * @param o The object to return the properties for\n\t */\n\texports.getOwnPropertySymbols = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertySymbols\n\t    : Shim.getOwnPropertySymbols;\n\t/**\n\t * Returns an array of own properties who key is a string\n\t *\n\t * @param o The object to return the properties for\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.getOwnPropertyNames = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyNames\n\t    : Shim.getOwnPropertyNames;\n\t/**\n\t * Returns the names of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.keys = hasGetOwnPropertySymbols\n\t    ? Object.keys\n\t    : Shim.symbolAwareKeys;\n\t/**\n\t * Returns the values of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.values = 'values' in Object\n\t    ? Object.values\n\t    : Shim.values;\n\t/**\n\t * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n\t * array holding the [key, value].\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.entries = 'entries' in Object\n\t    ? Object.entries\n\t    : Shim.entries;\n\texports.getOwnPropertyDescriptor = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyDescriptor\n\t    : Shim.getOwnPropertyDescriptor;\n\tfunction getOwnPropertyDescriptorsWrapper(o) {\n\t    var descriptors = exports.getOwnPropertyNames(o).reduce(function (descriptors, key) {\n\t        descriptors[key] = exports.getOwnPropertyDescriptor(o, key);\n\t        return descriptors;\n\t    }, {});\n\t    exports.getOwnPropertySymbols(o).forEach(function (sym) {\n\t        descriptors[sym] = exports.getOwnPropertyDescriptor(o, sym);\n\t    });\n\t    return descriptors;\n\t}\n\t/* Return descriptors for enumerable and non enumerable properties on an object */\n\texports.getOwnPropertyDescriptors = 'getOwnPropertyDescriptors' in Object\n\t    ? Object.getOwnPropertyDescriptors\n\t    : getOwnPropertyDescriptorsWrapper;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(41);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar compose_1 = __webpack_require__(16);\n\t/**\n\t * A reference to a function that always returns a promise which resolves to false\n\t */\n\tfunction noop() {\n\t    return Promise_1.default.resolve(false);\n\t}\n\t/**\n\t * A reference to a function that throws, used to replace the `own()` method after\n\t * destruction\n\t */\n\tfunction destroyed() {\n\t    throw new Error('Call made to destroyed method');\n\t}\n\t/**\n\t * A weak map for *owning* handles on instances\n\t */\n\tvar handlesWeakMap = new WeakMap_1.default();\n\t/**\n\t * A type guard that determines if the value is a Destroyable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isDestroyable(value) {\n\t    return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n\t}\n\texports.isDestroyable = isDestroyable;\n\t/**\n\t * A mixin which adds the concepts of being able to *destroy* handles which the instance\n\t * *owns*\n\t */\n\tvar createDestroyable = compose_1.default('Destroyable', {\n\t    own: function (handle) {\n\t        var handles = handlesWeakMap.get(this);\n\t        handles.push(handle);\n\t        return {\n\t            destroy: function () {\n\t                handles.splice(handles.indexOf(handle));\n\t                handle.destroy();\n\t            }\n\t        };\n\t    },\n\t    destroy: function () {\n\t        var _this = this;\n\t        return new Promise_1.default(function (resolve) {\n\t            handlesWeakMap.get(_this).forEach(function (handle) {\n\t                handle && handle.destroy && handle.destroy();\n\t            });\n\t            _this.destroy = noop;\n\t            _this.own = destroyed;\n\t            resolve(true);\n\t        });\n\t    }\n\t}, function (instance) {\n\t    handlesWeakMap.set(instance, []);\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createDestroyable;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(21);\n\tvar queue_1 = __webpack_require__(42);\n\tvar iterator_1 = __webpack_require__(27);\n\t__webpack_require__(29);\n\tvar decorators_1 = __webpack_require__(32);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Returns true if a given value has a `then` method.\n\t     * @param {any} value The value to check if is Thenable\n\t     * @returns {is Thenable<T>} A type guard if the value is thenable\n\t     */\n\t    function isThenable(value) {\n\t        return value && typeof value.then === 'function';\n\t    }\n\t    Shim.isThenable = isThenable;\n\t    /**\n\t     * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t     * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t     * not intended to be used directly.\n\t     *\n\t     * @borrows Promise.all as Promise.all\n\t     * @borrows Promise.race as Promise.race\n\t     * @borrows Promise.reject as Promise.reject\n\t     * @borrows Promise.resolve as Promise.resolve\n\t     * @borrows Promise#catch as Promise#catch\n\t     * @borrows Promise#then as Promise#then\n\t     */\n\t    var Promise = (function () {\n\t        /**\n\t         * Creates a new Promise.\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param executor\n\t         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t         * starting the asynchronous operation when it is invoked.\n\t         *\n\t         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t         * successfully, or the `reject` function when the operation fails.\n\t         */\n\t        function Promise(executor) {\n\t            var _this = this;\n\t            /**\n\t             * The current state of this promise.\n\t             */\n\t            this.state = 1 /* Pending */;\n\t            this[Symbol.toStringTag] = 'Promise';\n\t            /**\n\t             * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t             */\n\t            var isChained = false;\n\t            /**\n\t             * Whether or not this promise is in a resolved state.\n\t             */\n\t            var isResolved = function () {\n\t                return _this.state !== 1 /* Pending */ || isChained;\n\t            };\n\t            /**\n\t             * Callbacks that should be invoked once the asynchronous operation has completed.\n\t             */\n\t            var callbacks = [];\n\t            /**\n\t             * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t             * enqueues callbacks for execution on the next event loop turn.\n\t             */\n\t            var whenFinished = function (callback) {\n\t                if (callbacks) {\n\t                    callbacks.push(callback);\n\t                }\n\t            };\n\t            /**\n\t             * Settles this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var settle = function (newState, value) {\n\t                // A promise can only be settled once.\n\t                if (_this.state !== 1 /* Pending */) {\n\t                    return;\n\t                }\n\t                _this.state = newState;\n\t                _this.resolvedValue = value;\n\t                whenFinished = queue_1.queueMicroTask;\n\t                // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t                // wait an extra turn.\n\t                if (callbacks && callbacks.length > 0) {\n\t                    queue_1.queueMicroTask(function () {\n\t                        if (callbacks) {\n\t                            var count = callbacks.length;\n\t                            for (var i = 0; i < count; ++i) {\n\t                                callbacks[i].call(null);\n\t                            }\n\t                            callbacks = null;\n\t                        }\n\t                    });\n\t                }\n\t            };\n\t            /**\n\t             * Resolves this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var resolve = function (newState, value) {\n\t                if (isResolved()) {\n\t                    return;\n\t                }\n\t                if (isThenable(value)) {\n\t                    value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n\t                    isChained = true;\n\t                }\n\t                else {\n\t                    settle(newState, value);\n\t                }\n\t            };\n\t            this.then = function (onFulfilled, onRejected) {\n\t                return new Promise(function (resolve, reject) {\n\t                    // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t                    // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t                    // event loop.\n\t                    whenFinished(function () {\n\t                        var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n\t                        if (typeof callback === 'function') {\n\t                            try {\n\t                                resolve(callback(_this.resolvedValue));\n\t                            }\n\t                            catch (error) {\n\t                                reject(error);\n\t                            }\n\t                        }\n\t                        else if (_this.state === 2 /* Rejected */) {\n\t                            reject(_this.resolvedValue);\n\t                        }\n\t                        else {\n\t                            resolve(_this.resolvedValue);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t            try {\n\t                executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n\t            }\n\t            catch (error) {\n\t                settle(2 /* Rejected */, error);\n\t            }\n\t        }\n\t        Promise.all = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                var values = [];\n\t                var complete = 0;\n\t                var total = 0;\n\t                var populating = true;\n\t                function fulfill(index, value) {\n\t                    values[index] = value;\n\t                    ++complete;\n\t                    finish();\n\t                }\n\t                function finish() {\n\t                    if (populating || complete < total) {\n\t                        return;\n\t                    }\n\t                    resolve(values);\n\t                }\n\t                function processItem(index, item) {\n\t                    ++total;\n\t                    if (isThenable(item)) {\n\t                        // If an item Promise rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(fulfill.bind(null, index), reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(fulfill.bind(null, index));\n\t                    }\n\t                }\n\t                var i = 0;\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    processItem(i, value);\n\t                    i++;\n\t                });\n\t                populating = false;\n\t                finish();\n\t            });\n\t        };\n\t        Promise.race = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                iterator_1.forOf(iterable, function (item) {\n\t                    if (item instanceof Promise) {\n\t                        // If a Promise item rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(resolve, reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(resolve);\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Promise.reject = function (reason) {\n\t            return new this(function (resolve, reject) {\n\t                reject(reason);\n\t            });\n\t        };\n\t        Promise.resolve = function (value) {\n\t            return new this(function (resolve) {\n\t                resolve(value);\n\t            });\n\t        };\n\t        Promise.prototype.catch = function (onRejected) {\n\t            return this.then(undefined, onRejected);\n\t        };\n\t        return Promise;\n\t    }());\n\t    Shim.Promise = Promise;\n\t})(Shim || (Shim = {}));\n\tvar Promise = (function () {\n\t    /**\n\t     * Creates a new Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    /* istanbul ignore next */\n\t    function Promise(executor) {\n\t    }\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t     *     value[0] === 'foo'; // true\n\t     *     value[1] === 'bar'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.all({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: 'bar'\n\t     * }).then((value) => {\n\t     *     value.foo === 'foo'; // true\n\t     *     value.bar === 'bar'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.all = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    ;\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t     * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.race({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: Promise.resolve('bar')\n\t     * }).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.race = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    /**\n\t     * Creates a new promise that is rejected with the given error.\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.reject = function (reason) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.resolve = function (value) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.catch = function (onRejected) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.then = function (onFulfilled, onRejected) {\n\t        throw new Error();\n\t    };\n\t    Promise = __decorate([\n\t        decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n\t    ], Promise);\n\t    return Promise;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Promise;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate, process) {\"use strict\";\n\tvar global_1 = __webpack_require__(21);\n\tvar has_1 = __webpack_require__(20);\n\t/**\n\t * Executes a task\n\t * @param item The task to execute\n\t */\n\tfunction executeTask(item) {\n\t    if (item && item.isActive) {\n\t        item.callback();\n\t    }\n\t}\n\t/**\n\t * Get a handle to be able to remove an item from the queue\n\t */\n\tfunction getQueueHandle(item, destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            if (item) {\n\t                item.isActive = false;\n\t            }\n\t            if (destructor) {\n\t                destructor();\n\t            }\n\t        }\n\t    };\n\t}\n\tvar microTasks = [];\n\tvar microTaskQueued = false;\n\tvar checkMicroTaskQueue = function () { };\n\t/**\n\t * Schedules a callback to the macrotask queue.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueTask = (function () {\n\t    var destructor;\n\t    var enqueue;\n\t    /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\t    if (has_1.default('postmessage')) {\n\t        var queue_1 = [];\n\t        addEventListener('message', function (event) {\n\t            // Confirm that the event was triggered by the current window and by this particular implementation.\n\t            if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n\t                event.stopPropagation();\n\t                if (queue_1.length) {\n\t                    executeTask(queue_1.shift());\n\t                }\n\t            }\n\t        });\n\t        enqueue = function (item) {\n\t            queue_1.push(item);\n\t            postMessage('dojo-queue-message', '*');\n\t        };\n\t    }\n\t    else if (has_1.default('setimmediate')) {\n\t        destructor = clearImmediate;\n\t        enqueue = function (item) {\n\t            return setImmediate(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else {\n\t        destructor = clearTimeout;\n\t        enqueue = function (item) {\n\t            return setTimeout(executeTask.bind(null, item), 0);\n\t        };\n\t    }\n\t    function queueTask(callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        var id = enqueue(item);\n\t        return getQueueHandle(item, destructor && function () {\n\t            destructor(id);\n\t        });\n\t    }\n\t    ;\n\t    // TODO: Use aspect.before when it is available.\n\t    return has_1.default('microtasks') ? queueTask : function (callback) {\n\t        checkMicroTaskQueue();\n\t        return queueTask(callback);\n\t    };\n\t})();\n\tcheckMicroTaskQueue = !has_1.default('microtasks')\n\t    ? function () {\n\t        if (!microTaskQueued) {\n\t            microTaskQueued = true;\n\t            exports.queueTask(function () {\n\t                microTaskQueued = false;\n\t                if (microTasks.length) {\n\t                    var item = void 0;\n\t                    while (item = microTasks.shift()) {\n\t                        executeTask(item);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    } : checkMicroTaskQueue;\n\t/**\n\t * Schedules a callback to the microtask queue.\n\t *\n\t * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n\t * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n\t * registered with `queueTask` or `queueAnimationTask`.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueMicroTask = (function () {\n\t    var enqueue;\n\t    if (has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            process.nextTick(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            global_1.default.Promise.resolve(item).then(executeTask);\n\t        };\n\t    }\n\t    else if (has_1.default('dom-mutationobserver')) {\n\t        /* tslint:disable-next-line:variable-name */\n\t        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n\t        var node_1 = document.createElement('div');\n\t        var queue_2 = [];\n\t        var observer = new HostMutationObserver(function () {\n\t            while (queue_2.length > 0) {\n\t                var item = queue_2.shift();\n\t                if (item && item.isActive) {\n\t                    item.callback();\n\t                }\n\t            }\n\t        });\n\t        observer.observe(node_1, { attributes: true });\n\t        enqueue = function (item) {\n\t            queue_2.push(item);\n\t            node_1.setAttribute('queueStatus', '1');\n\t        };\n\t    }\n\t    else {\n\t        enqueue = function (item) {\n\t            checkMicroTaskQueue();\n\t            microTasks.push(item);\n\t        };\n\t    }\n\t    return function (callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        enqueue(item);\n\t        return getQueueHandle(item);\n\t    };\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(43).clearImmediate, __webpack_require__(43).setImmediate, __webpack_require__(23)))\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(44);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 68\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(23)))\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t\"use strict\";\n\tvar ExtensiblePromise_1 = __webpack_require__(46);\n\t/**\n\t * A type guard that determines if `value` is a `Task`\n\t * @param value The value to guard\n\t */\n\tfunction isTask(value) {\n\t    return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n\t}\n\texports.isTask = isTask;\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\tfunction isThenable(value) {\n\t    return value && typeof value.then === 'function';\n\t}\n\texports.isThenable = isThenable;\n\t/**\n\t * Task is an extension of Promise that supports cancellation and the Task#finally method.\n\t */\n\tvar Task = (function (_super) {\n\t    __extends(Task, _super);\n\t    /**\n\t     * @constructor\n\t     *\n\t     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t     *\n\t     * @param executor Method that initiates some task\n\t     * @param canceler Method to call when the task is canceled\n\t     *\n\t     */\n\t    function Task(executor, canceler) {\n\t        var _this = this;\n\t        // we have to initialize these to avoid a compiler error of using them before they are initialized\n\t        var superResolve = function () { };\n\t        var superReject = function () { };\n\t        _super.call(this, function (resolve, reject) {\n\t            superResolve = resolve;\n\t            superReject = reject;\n\t        });\n\t        this._state = 1 /* Pending */;\n\t        this.children = [];\n\t        this.canceler = function () {\n\t            if (canceler) {\n\t                canceler();\n\t            }\n\t            _this._cancel();\n\t        };\n\t        // Don't let the Task resolve if it's been canceled\n\t        try {\n\t            executor(function (value) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 0 /* Fulfilled */;\n\t                superResolve(value);\n\t            }, function (reason) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 2 /* Rejected */;\n\t                superReject(reason);\n\t            });\n\t        }\n\t        catch (reason) {\n\t            this._state = 2 /* Rejected */;\n\t            superReject(reason);\n\t        }\n\t    }\n\t    Task.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    Object.defineProperty(Task.prototype, \"state\", {\n\t        get: function () {\n\t            return this._state;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /**\n\t     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t     */\n\t    Task.prototype._cancel = function (finallyTask) {\n\t        var _this = this;\n\t        this._state = 3 /* Canceled */;\n\t        var runFinally = function () {\n\t            try {\n\t                return _this._finally();\n\t            }\n\t            catch (error) {\n\t            }\n\t        };\n\t        if (this._finally) {\n\t            if (isThenable(finallyTask)) {\n\t                finallyTask = finallyTask.then(runFinally, runFinally);\n\t            }\n\t            else {\n\t                finallyTask = runFinally();\n\t            }\n\t        }\n\t        this.children.forEach(function (child) {\n\t            child._cancel(finallyTask);\n\t        });\n\t    };\n\t    /**\n\t     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t     */\n\t    Task.prototype.cancel = function () {\n\t        if (this._state === 1 /* Pending */) {\n\t            this.canceler();\n\t        }\n\t    };\n\t    /**\n\t     * Allows for cleanup actions to be performed after resolution of a Promise.\n\t     */\n\t    Task.prototype.finally = function (callback) {\n\t        // if this task is already canceled, call the task\n\t        if (this._state === 3 /* Canceled */) {\n\t            return Task.resolve(callback());\n\t        }\n\t        var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n\t            throw reason;\n\t        }); });\n\t        // Keep a reference to the callback; it will be called if the Task is canceled\n\t        task._finally = callback;\n\t        return task;\n\t    };\n\t    /**\n\t     * Adds a callback to be invoked when the Task resolves or is rejected.\n\t     *\n\t     * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t     * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t     *\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    Task.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        // FIXME\n\t        // tslint:disable-next-line:no-var-keyword\n\t        var task = _super.prototype.then.call(this, \n\t        // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t        function (value) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onFulfilled) {\n\t                return onFulfilled(value);\n\t            }\n\t            return value;\n\t        }, function (error) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onRejected) {\n\t                return onRejected(error);\n\t            }\n\t            throw error;\n\t        });\n\t        task.canceler = function () {\n\t            // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t            // unresolved parent\n\t            if (_this._state === 1 /* Pending */) {\n\t                _this.cancel();\n\t            }\n\t            else {\n\t                task._cancel();\n\t            }\n\t        };\n\t        // Keep track of child Tasks for propogating cancelation back down the chain\n\t        this.children.push(task);\n\t        return task;\n\t    };\n\t    return Task;\n\t}(ExtensiblePromise_1.default));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Task;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar iterator_1 = __webpack_require__(27);\n\tvar Promise_1 = __webpack_require__(41);\n\t/**\n\t * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n\t * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n\t *\n\t * @param iterable    The list of objects to iterate over\n\t * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n\t */\n\tfunction unwrapPromises(iterable) {\n\t    var unwrapped = [];\n\t    iterator_1.forOf(iterable, function (item) {\n\t        unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t    });\n\t    return unwrapped;\n\t}\n\t/**\n\t * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n\t * giving an API like a native promise.\n\t */\n\tvar ExtensiblePromise = (function () {\n\t    /**\n\t     * Creates a new extended Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    function ExtensiblePromise(executor) {\n\t        this._promise = new Promise_1.default(executor);\n\t    }\n\t    /**\n\t     * Return a rejected promise wrapped in an ExtensiblePromise\n\t     *\n\t     * @param {Error?} reason    The reason for the rejection\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.reject = function (reason) {\n\t        return new this(function (resolve, reject) { return reject(reason); });\n\t    };\n\t    ExtensiblePromise.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    /**\n\t     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.all = function (iterable) {\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    /**\n\t     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.race = function (iterable) {\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    ExtensiblePromise.prototype.catch = function (onRejected) {\n\t        return this.then(undefined, onRejected);\n\t    };\n\t    ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        var e = function (resolve, reject) {\n\t            function handler(rejected, valueOrError) {\n\t                var callback = rejected ? onRejected : onFulfilled;\n\t                if (typeof callback === 'function') {\n\t                    try {\n\t                        resolve(callback(valueOrError));\n\t                    }\n\t                    catch (error) {\n\t                        reject(error);\n\t                    }\n\t                }\n\t                else if (rejected) {\n\t                    reject(valueOrError);\n\t                }\n\t                else {\n\t                    resolve(valueOrError);\n\t                }\n\t            }\n\t            _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t        };\n\t        return new this.constructor(e);\n\t    };\n\t    return ExtensiblePromise;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = ExtensiblePromise;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\tfunction emit(target, event) {\n\t    if (target.dispatchEvent &&\n\t        ((target.ownerDocument && target.ownerDocument.createEvent) ||\n\t            (target.document && target.document.createEvent) ||\n\t            target.createEvent) /* matches document */) {\n\t        var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n\t        for (var key in event) {\n\t            if (!(key in nativeEvent)) {\n\t                nativeEvent[key] = event[key];\n\t            }\n\t        }\n\t        return target.dispatchEvent(nativeEvent);\n\t    }\n\t    if (target.emit) {\n\t        if (target.removeListener) {\n\t            // Node.js EventEmitter\n\t            target.emit(event.type, event);\n\t            return false;\n\t        }\n\t        else if (target.on) {\n\t            // Dojo Evented or similar\n\t            target.emit(event);\n\t            return false;\n\t        }\n\t    }\n\t    throw new Error('Target must be an event emitter');\n\t}\n\texports.emit = emit;\n\tfunction on(target, type, listener, capture) {\n\t    if (Array.isArray(type)) {\n\t        var handles = type.map(function (type) {\n\t            return on(target, type, listener, capture);\n\t        });\n\t        return lang_1.createCompositeHandle.apply(void 0, handles);\n\t    }\n\t    var callback = function () {\n\t        listener.apply(this, arguments);\n\t    };\n\t    // DOM EventTarget\n\t    if (target.addEventListener && target.removeEventListener) {\n\t        target.addEventListener(type, callback, capture);\n\t        return lang_1.createHandle(function () {\n\t            target.removeEventListener(type, callback, capture);\n\t        });\n\t    }\n\t    if (target.on) {\n\t        // EventEmitter\n\t        if (target.removeListener) {\n\t            target.on(type, callback);\n\t            return lang_1.createHandle(function () {\n\t                target.removeListener(type, callback);\n\t            });\n\t        }\n\t        else if (target.emit) {\n\t            return target.on(type, listener);\n\t        }\n\t    }\n\t    throw new TypeError('Unknown event emitter object');\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = on;\n\tfunction once(target, type, listener, capture) {\n\t    // FIXME\n\t    // tslint:disable-next-line:no-var-keyword\n\t    var handle = on(target, type, function () {\n\t        handle.destroy();\n\t        return listener.apply(this, arguments);\n\t    }, capture);\n\t    return handle;\n\t}\n\texports.once = once;\n\tfunction pausable(target, type, listener, capture) {\n\t    var paused;\n\t    var handle = on(target, type, function () {\n\t        if (!paused) {\n\t            return listener.apply(this, arguments);\n\t        }\n\t    }, capture);\n\t    handle.pause = function () {\n\t        paused = true;\n\t    };\n\t    handle.resume = function () {\n\t        paused = false;\n\t    };\n\t    return handle;\n\t}\n\texports.pausable = pausable;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\t/**\n\t * Parses a path\n\t * @param path The path to parse.\n\t * @return The search params, pathname segments, and whether it ended with a trailing slash.\n\t */\n\tfunction parse(path) {\n\t    var tokens = path.split(/([/?#])/).filter(Boolean);\n\t    var pathnameTokens = tokens;\n\t    var searchParams;\n\t    var searchStart = tokens.indexOf('?');\n\t    var hashStart = tokens.indexOf('#');\n\t    if (searchStart >= 0) {\n\t        if (hashStart >= 0) {\n\t            // Either `/foo?bar#baz` or `/foo#bar?baz`\n\t            pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n\t        }\n\t        else {\n\t            // `/foo?bar`\n\t            pathnameTokens = tokens.slice(0, searchStart);\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n\t        }\n\t    }\n\t    else {\n\t        searchParams = new UrlSearchParams_1.default();\n\t        if (hashStart >= 0) {\n\t            // `/foo#bar`\n\t            pathnameTokens = tokens.slice(0, hashStart);\n\t        }\n\t    }\n\t    var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n\t    var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\t    return {\n\t        searchParams: searchParams,\n\t        segments: segments,\n\t        trailingSlash: trailingSlash\n\t    };\n\t}\n\texports.parse = parse;\n\t/**\n\t * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n\t * @param expectedSegments Part of a DeconstructedPath object.\n\t * @param segments Pathname segments as returned by `parse()`\n\t * @return A result object.\n\t */\n\tfunction match(_a, segments) {\n\t    var expectedSegments = _a.expectedSegments;\n\t    if (expectedSegments.length === 0) {\n\t        return {\n\t            hasRemaining: segments.length > 0,\n\t            offset: 0,\n\t            values: []\n\t        };\n\t    }\n\t    if (expectedSegments.length > segments.length) {\n\t        return null;\n\t    }\n\t    var isMatch = true;\n\t    var values = [];\n\t    for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n\t        var value = segments[i];\n\t        var expected = expectedSegments[i];\n\t        if (isNamedSegment(expected)) {\n\t            values.push(value);\n\t        }\n\t        else if (expected.literal !== value) {\n\t            isMatch = false;\n\t        }\n\t    }\n\t    if (!isMatch) {\n\t        return null;\n\t    }\n\t    return {\n\t        hasRemaining: expectedSegments.length < segments.length,\n\t        offset: expectedSegments.length,\n\t        values: values\n\t    };\n\t}\n\texports.match = match;\n\t/**\n\t * Determine whether the segment is a NamedSegment.\n\t *\n\t * @param segment The segment to be checked\n\t * @return true if the segment is a NamedSegment, false otherwise\n\t */\n\tfunction isNamedSegment(segment) {\n\t    return segment.name !== undefined;\n\t}\n\texports.isNamedSegment = isNamedSegment;\n\t/**\n\t * Deconstruct a route path into its constituent parts.\n\t * @param path The path to deconstruct.\n\t * @return An object describing the path's constituent parts.\n\t */\n\tfunction deconstruct(path) {\n\t    var expectedSegments = [];\n\t    var parameters = [];\n\t    var searchParameters = [];\n\t    var trailingSlash = false;\n\t    var tokens = path.split(/([/{}?&])/).filter(Boolean);\n\t    var leadingSlash = tokens[0] === '/';\n\t    var i = 0;\n\t    var consume = function () { return tokens[i++]; };\n\t    var peek = function () { return tokens[i]; };\n\t    var inSearchComponent = false;\n\t    while (i < tokens.length) {\n\t        var t = consume();\n\t        switch (t) {\n\t            case '{': {\n\t                var name_1 = consume();\n\t                if (!name_1 || name_1 === '}') {\n\t                    throw new TypeError('Parameter must have a name');\n\t                }\n\t                // Reserve : for future use, e.g. including type data in the parameter declaration.\n\t                if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n\t                    throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t                }\n\t                if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n\t                    throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n\t                }\n\t                var closing = consume();\n\t                if (!closing || closing !== '}') {\n\t                    throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n\t                }\n\t                var separator = peek();\n\t                if (separator) {\n\t                    if (inSearchComponent) {\n\t                        if (separator !== '&') {\n\t                            throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n\t                        }\n\t                    }\n\t                    else if (separator !== '/' && separator !== '?') {\n\t                        throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n\t                    }\n\t                }\n\t                if (inSearchComponent) {\n\t                    searchParameters.push(name_1);\n\t                }\n\t                else {\n\t                    parameters.push(name_1);\n\t                    expectedSegments.push(Object.freeze({ name: name_1 }));\n\t                }\n\t                break;\n\t            }\n\t            case '?':\n\t            case '/':\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                if (t === '?') {\n\t                    inSearchComponent = true;\n\t                    if (expectedSegments.length === 0) {\n\t                        throw new TypeError('Path must contain at least one segment');\n\t                    }\n\t                }\n\t                if (t === '/') {\n\t                    var next_1 = peek();\n\t                    if (next_1 === '/') {\n\t                        throw new TypeError('Path segment must not be empty');\n\t                    }\n\t                    if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n\t                        trailingSlash = true;\n\t                    }\n\t                }\n\t                break;\n\t            case '&':\n\t                if (!inSearchComponent) {\n\t                    throw new TypeError('Path segment must not contain \\'&\\'');\n\t                }\n\t                var next = peek();\n\t                if (next === '&') {\n\t                    throw new TypeError('Expected parameter in search component, got \\'&\\'');\n\t                }\n\t                break;\n\t            default:\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                expectedSegments.push(Object.freeze({ literal: t }));\n\t        }\n\t    }\n\t    return Object.freeze({\n\t        expectedSegments: Object.freeze(expectedSegments),\n\t        leadingSlash: leadingSlash,\n\t        parameters: Object.freeze(parameters),\n\t        searchParameters: Object.freeze(searchParameters),\n\t        trailingSlash: trailingSlash\n\t    });\n\t}\n\texports.deconstruct = deconstruct;\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar global_1 = __webpack_require__(19);\n\tvar on_1 = __webpack_require__(47);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar privateStateMap = new WeakMap_1.default();\n\tvar createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        get current() {\n\t            return privateStateMap.get(this).current;\n\t        },\n\t        prefix: function (path) {\n\t            return \"#\" + path;\n\t        },\n\t        set: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            privateState.browserLocation.hash = this.prefix(path);\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        },\n\t        replace: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n\t            privateState.browserLocation.replace(pathname + search + this.prefix(path));\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n\t        var browserLocation = window.location;\n\t        var privateState = {\n\t            current: browserLocation.hash.slice(1),\n\t            browserLocation: browserLocation\n\t        };\n\t        privateStateMap.set(instance, privateState);\n\t        instance.own(on_1.default(window, 'hashchange', function () {\n\t            var path = browserLocation.hash.slice(1);\n\t            // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t            // manager sets the hash.\n\t            if (path !== privateState.current) {\n\t                privateState.current = path;\n\t                instance.emit({\n\t                    type: 'change',\n\t                    value: path\n\t                });\n\t            }\n\t        }));\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createHashHistory;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createAction_1 = __webpack_require__(51);\n\tvar widgetStore_1 = __webpack_require__(54);\n\tvar cardStore_1 = __webpack_require__(72);\n\texports.gotoCardDetails = createAction_1.default({\n\t    do: function (_a) {\n\t        var id = _a.id;\n\t        return cardStore_1.default.get(id).then(function (cardDescription) {\n\t            return cardStore_1.pickRandomCards(2, [id]).then(function (seenWith) {\n\t                return Promise.all([\n\t                    widgetStore_1.default.patch({ id: 'cardDetails', cardDescription: cardDescription, seenWith: seenWith }),\n\t                    widgetStore_1.default.patch({ id: 'app', route: 'cardDetails' })\n\t                ]);\n\t            });\n\t        });\n\t    }\n\t});\n\texports.gotoCards = createAction_1.default({\n\t    do: function () {\n\t        return widgetStore_1.default.patch({ id: 'app', route: 'cards' });\n\t    }\n\t});\n\texports.gotoHome = createAction_1.default({\n\t    do: function () {\n\t        return widgetStore_1.default.patch({ id: 'app', route: 'home' });\n\t    }\n\t});\n\texports.gotoAbout = createAction_1.default({\n\t    do: function () {\n\t        return widgetStore_1.default.patch({ id: 'app', route: 'about' });\n\t    }\n\t});\n\texports.gotoGameplay = createAction_1.default({\n\t    do: function () {\n\t        return widgetStore_1.default.patch({ id: 'app', route: 'gameplay' });\n\t    }\n\t});\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar createStateful_1 = __webpack_require__(52);\n\tvar Task_1 = __webpack_require__(45);\n\tvar WeakMap_1 = __webpack_require__(31);\n\t/**\n\t * A type guard that validates the object passed is an Action\n\t */\n\tfunction isAction(value) {\n\t    return typeof value === 'object' && typeof value.do === 'function';\n\t}\n\texports.isAction = isAction;\n\t/**\n\t * A weak map of `do` methods\n\t */\n\tvar doFunctions = new WeakMap_1.default();\n\t/**\n\t * A weak map of `configure` methods\n\t */\n\tvar configureFunctions = new WeakMap_1.default();\n\t/**\n\t * A factory which creates instances of Action\n\t */\n\tvar createAction = compose_1.default({\n\t    do: function (options) {\n\t        var doFn = doFunctions.get(this);\n\t        if (doFn && this.state.enabled) {\n\t            var result = doFn.call(this, options);\n\t            return Task_1.isTask(result) ? result : Task_1.default.resolve(result);\n\t        }\n\t        return Task_1.default.resolve();\n\t    },\n\t    enable: function () {\n\t        if (!this.state.enabled) {\n\t            this.setState({ enabled: true });\n\t        }\n\t    },\n\t    disable: function () {\n\t        if (this.state.enabled) {\n\t            this.setState({ enabled: false });\n\t        }\n\t    },\n\t    configure: function (configuration) {\n\t        var configureFn = configureFunctions.get(this);\n\t        if (configureFn) {\n\t            return configureFn.call(this, configuration);\n\t        }\n\t    }\n\t})\n\t    .mixin({\n\t    mixin: createStateful_1.default,\n\t    initialize: function (instance, _a) {\n\t        var doFn = _a.do, _b = _a.enabled, enabled = _b === void 0 ? true : _b, configure = _a.configure;\n\t        if (!doFn) {\n\t            throw new TypeError(\"'options.do' required during creation.\");\n\t        }\n\t        doFunctions.set(instance, doFn);\n\t        instance.setState({ enabled: enabled });\n\t        if (configure) {\n\t            configureFunctions.set(instance, configure);\n\t        }\n\t        instance.own({\n\t            destroy: function () {\n\t                doFunctions.delete(instance);\n\t                configureFunctions.delete(instance);\n\t            }\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createAction;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar createCancelableEvent_1 = __webpack_require__(53);\n\t/**\n\t * A weak map of stateful instances to their obseved state references\n\t */\n\tvar observedStateMap = new WeakMap_1.default();\n\t/**\n\t * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n\t * cancelled.\n\t *\n\t * @param stateful The `Stateful` object to unobserve\n\t */\n\tfunction unobserve(stateful) {\n\t    var observedState = observedStateMap.get(stateful);\n\t    if (observedState) {\n\t        observedState.handle.destroy();\n\t        var statecomplete = createCancelableEvent_1.default({\n\t            type: 'statecomplete',\n\t            target: stateful\n\t        });\n\t        stateful.emit(statecomplete);\n\t        if (!statecomplete.defaultPrevented) {\n\t            stateful.destroy();\n\t        }\n\t    }\n\t}\n\t/**\n\t * Internal function that actually applies the state to the Stateful's state and\n\t * emits the `statechange` event.\n\t *\n\t * @param stateful The Stateful instance\n\t * @param state The State to be set\n\t */\n\tfunction setStatefulState(stateful, state) {\n\t    state = lang_1.deepAssign(stateWeakMap.get(stateful), state);\n\t    stateful.emit({\n\t        type: 'statechange',\n\t        state: state,\n\t        target: stateful\n\t    });\n\t}\n\t/**\n\t * A weak map that contains the stateful's state\n\t */\n\tvar stateWeakMap = new WeakMap_1.default();\n\t/**\n\t * Create an instance of a stateful object\n\t */\n\tvar createStateful = createEvented_1.default\n\t    .mixin({\n\t    className: 'Stateful',\n\t    mixin: {\n\t        get state() {\n\t            return stateWeakMap.get(this);\n\t        },\n\t        setState: function (value) {\n\t            var observedState = observedStateMap.get(this);\n\t            if (observedState) {\n\t                observedState.observable.patch(value, { id: observedState.id });\n\t            }\n\t            else {\n\t                setStatefulState(this, value);\n\t            }\n\t        },\n\t        observeState: function (id, observable) {\n\t            var observedState = observedStateMap.get(this);\n\t            if (observedState) {\n\t                if (observedState.id === id && observedState.observable === observable) {\n\t                    return observedState.handle;\n\t                }\n\t                throw new Error(\"Already observing state with ID '\" + observedState.id + \"'\");\n\t            }\n\t            var stateful = this;\n\t            observedState = {\n\t                id: id,\n\t                observable: observable,\n\t                subscription: observable\n\t                    .observe(id)\n\t                    .subscribe(function (item) { return setStatefulState(stateful, item); }, /* next handler */ function (err) {\n\t                    /* TODO: Should we emit an error, instead of throwing? */\n\t                    throw err;\n\t                }, /* error handler */ function () { return unobserve(stateful); }),\n\t                handle: {\n\t                    destroy: function () {\n\t                        var observedState = observedStateMap.get(stateful);\n\t                        if (observedState) {\n\t                            observedState.subscription.unsubscribe();\n\t                            observedStateMap.delete(stateful);\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t            observedStateMap.set(stateful, observedState);\n\t            return observedState.handle;\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        /* Using Object.create(null) will improve performance when looking up properties in state */\n\t        stateWeakMap.set(instance, Object.create(null));\n\t        instance.own({\n\t            destroy: function () {\n\t                stateWeakMap.delete(instance);\n\t            }\n\t        });\n\t        if (options) {\n\t            var id = options.id, stateFrom = options.stateFrom, state = options.state;\n\t            if (typeof id !== 'undefined' && stateFrom) {\n\t                instance.own(instance.observeState(id, stateFrom));\n\t            }\n\t            else if (stateFrom) {\n\t                throw new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t            }\n\t            if (state) {\n\t                instance.setState(state);\n\t            }\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStateful;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A simple factory that creates an event object which can be cancelled\n\t *\n\t * @param options The options for the event\n\t */\n\tfunction createCancelableEvent(options) {\n\t    var type = options.type, target = options.target;\n\t    var event = Object.defineProperties({}, {\n\t        type: { value: type, enumerable: true },\n\t        target: { value: target, enumerable: true },\n\t        cancelable: { value: true, enumerable: true },\n\t        defaultPrevented: { value: false, enumerable: true, configurable: true },\n\t        preventDefault: { value: function () {\n\t                Object.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n\t            }, enumerable: true }\n\t    });\n\t    return event;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCancelableEvent;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createMemoryStore_1 = __webpack_require__(55);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createMemoryStore_1.default({\n\t    data: [\n\t        {\n\t            id: 'navbar',\n\t            sections: [\n\t                { text: 'the cards', href: '#cards' },\n\t                { text: 'gameplay', href: '#gameplay' },\n\t                { text: 'about', href: '#about' }\n\t            ]\n\t        },\n\t        {\n\t            id: 'app',\n\t            route: 'home'\n\t        },\n\t        {\n\t            id: 'cardDetails',\n\t            enterAnimation: 'fadeInSlideDown',\n\t            exitAnimation: 'fadeOutSlideUp'\n\t        },\n\t        {\n\t            id: 'cards',\n\t            enterAnimation: 'fadeIn',\n\t            exitAnimation: 'fadeOut'\n\t        },\n\t        {\n\t            id: 'home',\n\t            enterAnimation: 'fadeIn',\n\t            exitAnimation: 'fadeOut'\n\t        },\n\t        {\n\t            id: 'about',\n\t            enterAnimation: 'fadeIn',\n\t            exitAnimation: 'fadeOut'\n\t        },\n\t        {\n\t            id: 'gameplay',\n\t            enterAnimation: 'fadeIn',\n\t            exitAnimation: 'fadeOut'\n\t        }\n\t    ]\n\t});\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar immutable_1 = __webpack_require__(56);\n\tvar Observable_1 = __webpack_require__(57);\n\tvar lang_1 = __webpack_require__(24);\n\tvar Promise_1 = __webpack_require__(41);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar compose_1 = __webpack_require__(16);\n\tvar createDestroyable_1 = __webpack_require__(40);\n\t/**\n\t * The weak map that contains the data for the stores\n\t */\n\tvar dataWeakMap = new WeakMap_1.default();\n\t/**\n\t * The weak map that contains any observers for the stores\n\t */\n\tvar itemObserverWeakMap = new WeakMap_1.default();\n\t/**\n\t *\n\t */\n\tvar storeObserverWeakMap = new WeakMap_1.default();\n\t/**\n\t * The methods to decorate the MemoryStorePromise with\n\t */\n\tvar storeMethods = ['get', 'put', 'add', 'patch', 'delete', 'fromArray'];\n\t/**\n\t    * Returns true if a given value has a `then` method.\n\t    * @param {any} value The value to check if is Thenable\n\t    * @returns {is Thenable<T>} A type guard if the value is thenable\n\t    */\n\tfunction isThenable(value) {\n\t    return value && typeof value.then === 'function';\n\t}\n\t/**\n\t * Utility function that takes a result and generates a MemoryStorePromise\n\t * @param store The store to use as a reference when decorating the Promise\n\t * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n\t */\n\tfunction wrapResult(store, result) {\n\t    /* TODO: this all seems pretty expensive, there has to be a better way */\n\t    var p = (isThenable(result) ? result : Promise_1.default.resolve(result));\n\t    storeMethods.forEach(function (method) {\n\t        p[method] = function () {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            return p.then(function () {\n\t                return store[method].apply(store, args);\n\t            });\n\t        };\n\t    });\n\t    return p;\n\t}\n\t/**\n\t * Utility function that takes an error and generates a rejected MemoryStorePromise\n\t * @param store The store to use as a reference when decorating the Promise\n\t * @param result The result to wrap\n\t */\n\tfunction wrapError(store, result) {\n\t    var p = (isThenable(result) ? result : Promise_1.default.reject(result));\n\t    storeMethods.forEach(function (method) {\n\t        p[method] = function () {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            return p.then(function () {\n\t                return store[method].apply(store, args);\n\t            });\n\t        };\n\t    });\n\t    return p;\n\t}\n\t/**\n\t * Create a new instance of a MemoryStore\n\t */\n\tvar createMemoryStore = compose_1.default({\n\t    idProperty: 'id',\n\t    get: function (id) {\n\t        var data = dataWeakMap.get(this);\n\t        if (id) {\n\t            return wrapResult(this, data && data.get(String(id)));\n\t        }\n\t        else {\n\t            return wrapResult(this, data.values());\n\t        }\n\t    },\n\t    observe: function (id) {\n\t        var store = this;\n\t        if (id) {\n\t            return new Observable_1.Observable(function subscribe(observer) {\n\t                store.get(String(id)).then(function (item) {\n\t                    if (item) {\n\t                        observer.next(item);\n\t                        var observers = itemObserverWeakMap.get(store);\n\t                        var observerArray = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t                        observerArray.push(observer);\n\t                        itemObserverWeakMap.set(store, (observers ? observers : immutable_1.Map()).set(String(id), observerArray));\n\t                    }\n\t                    else {\n\t                        observer.error(new Error(\"ID \\\"\" + id + \"\\\" not found in store\"));\n\t                    }\n\t                });\n\t            });\n\t        }\n\t        else {\n\t            return new Observable_1.Observable(function subscribe(observer) {\n\t                var data = dataWeakMap.get(store);\n\t                var observers = storeObserverWeakMap.get(store) || [];\n\t                var values = data.values();\n\t                var items = Array.from(values);\n\t                var payload = {\n\t                    puts: items,\n\t                    deletes: [],\n\t                    beforeAll: [],\n\t                    afterAll: items\n\t                };\n\t                observer.next(payload);\n\t                observers.push(observer);\n\t                storeObserverWeakMap.set(store, observers);\n\t            });\n\t        }\n\t    },\n\t    put: function (item, options) {\n\t        var store = this;\n\t        var data = dataWeakMap.get(store);\n\t        var beforeAll = data ? data.values() : [];\n\t        var idProperty = store.idProperty;\n\t        var id = options && 'id' in options ? options.id :\n\t            idProperty in item ? item[idProperty] :\n\t                data ? data.size : 0;\n\t        if (options && options.replace === false && data && data.has(String(id))) {\n\t            return wrapError(store, Error(\"Duplicate ID \\\"\" + id + \"\\\" when pragma \\\"replace\\\" is false\"));\n\t        }\n\t        item[idProperty] = id;\n\t        dataWeakMap.set(store, (data ? data : immutable_1.OrderedMap()).set(String(id), item));\n\t        var observers = itemObserverWeakMap.get(store);\n\t        if (observers && observers.has(String(id))) {\n\t            observers.get(String(id)).forEach(function (observer) { return observer.next(item); });\n\t        }\n\t        var storeObservers = storeObserverWeakMap.get(store);\n\t        if (storeObservers) {\n\t            var afterData = dataWeakMap.get(store);\n\t            var afterAll = afterData.values();\n\t            var payload_1 = {\n\t                puts: [item],\n\t                deletes: [],\n\t                beforeAll: Array.from(beforeAll),\n\t                afterAll: Array.from(afterAll)\n\t            };\n\t            storeObservers.forEach(function (observer) {\n\t                observer.next(payload_1);\n\t            });\n\t        }\n\t        return wrapResult(store, item);\n\t    },\n\t    add: function (item, options) {\n\t        return this.put(item, lang_1.assign(options ? options : {}, { replace: false }));\n\t    },\n\t    patch: function (partial, options) {\n\t        var _this = this;\n\t        var idProperty = this.idProperty;\n\t        var id = options && 'id' in options ? options.id : partial[idProperty];\n\t        if (!id) {\n\t            return wrapError(this, new Error(\"Object ID must either be passed in \\\"partial.\" + idProperty + \"\\\" or \\\"options.id\\\"\"));\n\t        }\n\t        return wrapResult(this, this.get(id).then(function (item) {\n\t            if (item === void 0) { item = {}; }\n\t            options = options || {};\n\t            options.id = id;\n\t            return _this.put(lang_1.assign(item, partial), options);\n\t        }));\n\t    },\n\t    delete: function (item) {\n\t        var store = this;\n\t        var idProperty = store.idProperty;\n\t        var data = dataWeakMap.get(store);\n\t        var beforeAll = data ? data.values() : [];\n\t        /**\n\t         * Complete any observers associated with this items id\n\t         */\n\t        function completeObservable(id) {\n\t            var observers = itemObserverWeakMap.get(store);\n\t            if (observers && observers.has(String(id))) {\n\t                observers.get(String(id)).forEach(function (observer) { return observer.complete(); });\n\t                itemObserverWeakMap.set(store, observers.delete(id));\n\t            }\n\t        }\n\t        function completeStoreObservers() {\n\t            var storeObservers = storeObserverWeakMap.get(store);\n\t            if (storeObservers) {\n\t                var afterData = dataWeakMap.get(store);\n\t                var afterAll = afterData.values();\n\t                var payload_2 = {\n\t                    puts: [],\n\t                    deletes: [item],\n\t                    beforeAll: Array.from(beforeAll),\n\t                    afterAll: Array.from(afterAll)\n\t                };\n\t                storeObservers.forEach(function (observer) {\n\t                    observer.next(payload_2);\n\t                });\n\t            }\n\t        }\n\t        if (typeof item === 'object') {\n\t            if (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t                dataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t                completeObservable(item[idProperty]);\n\t                completeStoreObservers();\n\t                return wrapResult(store, true);\n\t            }\n\t        }\n\t        else {\n\t            if (data && data.has(String(item))) {\n\t                dataWeakMap.set(store, data.delete(String(item)));\n\t                completeObservable(item);\n\t                completeStoreObservers();\n\t                return wrapResult(store, true);\n\t            }\n\t        }\n\t        return wrapResult(store, false);\n\t    },\n\t    fromArray: function (items) {\n\t        var store = this;\n\t        var map = {};\n\t        var idProperty = store.idProperty;\n\t        items.forEach(function (item, idx) {\n\t            var id = idProperty in item ? item[idProperty] : idx;\n\t            item[idProperty] = id;\n\t            map[id] = item;\n\t        });\n\t        dataWeakMap.set(store, immutable_1.OrderedMap(map));\n\t        return wrapResult(store, undefined);\n\t    }\n\t}, function (instance, options) {\n\t    if (options) {\n\t        if (options.idProperty) {\n\t            instance.idProperty = options.idProperty;\n\t        }\n\t        if (options.data) {\n\t            instance.fromArray(options.data);\n\t        }\n\t    }\n\t})\n\t    .mixin(createDestroyable_1.default)\n\t    .static({\n\t    fromArray: function (data) {\n\t        return createMemoryStore({ data: data });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createMemoryStore;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014-2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Immutable = factory());\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    // This implements \"is array index\" which the ECMAString spec defines as:\n\t    //\n\t    //     A String property name P is an array index if and only if\n\t    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n\t    //     to 2^321.\n\t    //\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n\t    if (typeof index !== 'number') {\n\t      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\t      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t        return NaN;\n\t      }\n\t      index = uint32Index;\n\t    }\n\t    return index < 0 ? ensureSize(iter) + index : index;\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && (value.constructor === Object || value.constructor === undefined);\n\t  }\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t        return true;\n\t      }\n\t      if (!valueA || !valueB) {\n\t        return false;\n\t      }\n\t    }\n\t    if (typeof valueA.equals === 'function' &&\n\t        typeof valueB.equals === 'function' &&\n\t        valueA.equals(valueB)) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        if (typeof a.cacheResult === 'function') {\n\t          a.cacheResult();\n\t        }\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.includes = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step !== 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.includes = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  var imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      if (o !== o || o === Infinity) {\n\t        return 0;\n\t      }\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    if (type === 'object') {\n\t      return hashJSObj(o);\n\t    }\n\t    if (typeof o.toString === 'function') {\n\t      return hashString(o.toString());\n\t    }\n\t    throw new Error('Value type ' + type + ' cannot be hashed.');\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash;\n\t    if (usingWeakMap) {\n\t      hash = weakMap.get(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash !== undefined) {\n\t      return hash;\n\t    }\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (usingWeakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable !== undefined &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType !== undefined) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // Get references to ES5 object methods.\n\t  var isExtensible = Object.isExtensible;\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, '@', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var usingWeakMap = typeof WeakMap === 'function';\n\t  var weakMap;\n\t  if (usingWeakMap) {\n\t    weakMap = new WeakMap();\n\t  }\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) && !isOrdered(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n\t      return emptyMap().withMutations(function(map ) {\n\t        for (var i = 0; i < keyValues.length; i += 2) {\n\t          if (i + 1 >= keyValues.length) {\n\t            throw new Error('Missing value for key: ' + keyValues[i]);\n\t          }\n\t          map.set(keyValues[i], keyValues[i + 1]);\n\t        }\n\t      });\n\t    };\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.merge === 'function' ?\n\t          m.merge.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.mergeDeep === 'function' ?\n\t          m.mergeDeep.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(existing, value, key) {\n\t    return existing && existing.mergeDeep && isIterable(value) ?\n\t      existing.mergeDeep(value) :\n\t      is(existing, value) ? existing : value;\n\t  }\n\t\n\t  function deepMergerWith(merger) {\n\t    return function(existing, value, key)  {\n\t      if (existing && existing.mergeDeepWith && isIterable(value)) {\n\t        return existing.mergeDeepWith(merger, value);\n\t      }\n\t      var nextValue = merger(existing, value, key);\n\t      return is(existing, nextValue) ? existing : nextValue;\n\t    };\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value, key)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index >= 0 && index < this.size) {\n\t        index += this._origin;\n\t        var node = listNodeFor(this, index);\n\t        return node && node.array[index & MASK];\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.insert = function(index, value) {\n\t      return this.splice(index, 0, value);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t          return this;\n\t        }\n\t      }\n\t\n\t      var editable = editableVNode(this, ownerID);\n\t      editable.array.splice(sizeIndex + 1);\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index !== index) {\n\t      return list;\n\t    }\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      end = end | 0;\n\t    }\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might need creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might need creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.includes = function(value) {\n\t      return this._iter.includes(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.includes(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          var indexedIterable = isIterable(entry);\n\t          return fn(\n\t            indexedIterable ? entry.get(1) : entry[1],\n\t            indexedIterable ? entry.get(0) : entry[0],\n\t            this$0\n\t          );\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            var indexedIterable = isIterable(entry);\n\t            return iteratorValue(\n\t              type,\n\t              indexedIterable ? entry.get(0) : entry[0],\n\t              indexedIterable ? entry.get(1) : entry[1],\n\t              step\n\t            );\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.includes(key)};\n\t    flipSequence.includes = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      if (end === Infinity) {\n\t        end = originalSize;\n\t      } else {\n\t        end = end | 0;\n\t      }\n\t    }\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size and these do not resolve to NaN.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    // Note: resolvedEnd is undefined when the original sequence's length is\n\t    // unknown and this slice did not supply an end and should contain all\n\t    // elements after resolvedBegin.\n\t    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\t    var resolvedSize = resolvedEnd - resolvedBegin;\n\t    var sliceSize;\n\t    if (resolvedSize === resolvedSize) {\n\t      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    // If iterable.size is undefined, the size of the realized sliceSeq is\n\t    // unknown at this point unless the number of items to slice is 0\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize !== 0 && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ < resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var hasInitialized;\n\t\n\t      var RecordType = function Record(values) {\n\t        if (values instanceof RecordType) {\n\t          return values;\n\t        }\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        if (!hasInitialized) {\n\t          hasInitialized = true;\n\t          var keys = Object.keys(defaultValues);\n\t          setProps(RecordTypePrototype, keys);\n\t          RecordTypePrototype.size = keys.length;\n\t          RecordTypePrototype._name = name;\n\t          RecordTypePrototype._keys = keys;\n\t          RecordTypePrototype._defaultValues = defaultValues;\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var RecordType = this.constructor;\n\t      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      if (this._map && !this._map.has(k)) {\n\t        var defaultVal = this._defaultValues[k];\n\t        if (v === defaultVal) {\n\t          return this;\n\t        }\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name || 'Record';\n\t  }\n\t\n\t  function setProps(prototype, names) {\n\t    try {\n\t      names.forEach(setProp.bind(undefined, prototype));\n\t    } catch (error) {\n\t      // Object.defineProperty failed. Probably IE8.\n\t    }\n\t  }\n\t\n\t  function setProp(prototype, name) {\n\t    Object.defineProperty(prototype, name, {\n\t      get: function() {\n\t        return this.get(name);\n\t      },\n\t      set: function(value) {\n\t        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t        this.set(name, value);\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) && !isOrdered(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      index = wrapIndex(this, index);\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterate(fn);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterator(type);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    includes: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v.toString() : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findEntry: function(predicate, context, notSetValue) {\n\t      var found = notSetValue;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastEntry: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toKeyedSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.includes(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.toKeyedSeq().reverse().keyOf(searchValue);\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    }\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t  IterablePrototype.contains = IterablePrototype.includes;\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    }\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      var key = this.lastKeyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      // If index is negative, it should resolve relative to the size of the\n\t      // collection. However size may be expensive to compute if not cached, so\n\t      // only call count() if the number is in fact negative.\n\t      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var entry = this.findLastEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return Range(0, this.size);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    }\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    includes: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    }\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.includes;\n\t  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = imul(h, 0xCC9E2D51);\n\t    h = imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(58), __webpack_require__(60), __webpack_require__(61)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1, observable_1, toSubscriber_1) {\n\t    \"use strict\";\n\t    /**\n\t     * A representation of any set of values over any amount of time. This the most basic building block\n\t     * of RxJS.\n\t     *\n\t     * @class Observable<T>\n\t     */\n\t    var Observable = (function () {\n\t        /**\n\t         * @constructor\n\t         * @param {Function} subscribe the function that is  called when the Observable is\n\t         * initially subscribed to. This function is given a Subscriber, to which new values\n\t         * can be `next`ed, or an `error` method can be called to raise an error, or\n\t         * `complete` can be called to notify of a successful completion.\n\t         */\n\t        function Observable(subscribe) {\n\t            this._isScalar = false;\n\t            if (subscribe) {\n\t                this._subscribe = subscribe;\n\t            }\n\t        }\n\t        /**\n\t         * Creates a new Observable, with this Observable as the source, and the passed\n\t         * operator defined as the new observable's operator.\n\t         * @method lift\n\t         * @param {Operator} operator the operator defining the operation to take on the observable\n\t         * @return {Observable} a new observable with the Operator applied\n\t         */\n\t        Observable.prototype.lift = function (operator) {\n\t            var observable = new Observable();\n\t            observable.source = this;\n\t            observable.operator = operator;\n\t            return observable;\n\t        };\n\t        /**\n\t         * Registers handlers for handling emitted values, error and completions from the observable, and\n\t         *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n\t         * @method subscribe\n\t         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n\t         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n\t         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n\t         *  the error will be thrown as unhandled\n\t         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n\t         * @return {ISubscription} a subscription reference to the registered handlers\n\t         */\n\t        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t            var operator = this.operator;\n\t            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t            sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n\t            if (sink.syncErrorThrowable) {\n\t                sink.syncErrorThrowable = false;\n\t                if (sink.syncErrorThrown) {\n\t                    throw sink.syncErrorValue;\n\t                }\n\t            }\n\t            return sink;\n\t        };\n\t        /**\n\t         * @method forEach\n\t         * @param {Function} next a handler for each value emitted by the observable\n\t         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t         * @return {Promise} a promise that either resolves on observable completion or\n\t         *  rejects with the handled error\n\t         */\n\t        Observable.prototype.forEach = function (next, PromiseCtor) {\n\t            var _this = this;\n\t            if (!PromiseCtor) {\n\t                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                    PromiseCtor = root_1.root.Rx.config.Promise;\n\t                }\n\t                else if (root_1.root.Promise) {\n\t                    PromiseCtor = root_1.root.Promise;\n\t                }\n\t            }\n\t            if (!PromiseCtor) {\n\t                throw new Error('no Promise impl found');\n\t            }\n\t            return new PromiseCtor(function (resolve, reject) {\n\t                var subscription = _this.subscribe(function (value) {\n\t                    if (subscription) {\n\t                        // if there is a subscription, then we can surmise\n\t                        // the next handling is asynchronous. Any errors thrown\n\t                        // need to be rejected explicitly and unsubscribe must be\n\t                        // called manually\n\t                        try {\n\t                            next(value);\n\t                        }\n\t                        catch (err) {\n\t                            reject(err);\n\t                            subscription.unsubscribe();\n\t                        }\n\t                    }\n\t                    else {\n\t                        // if there is NO subscription, then we're getting a nexted\n\t                        // value synchronously during subscription. We can just call it.\n\t                        // If it errors, Observable's `subscribe` imple will ensure the\n\t                        // unsubscription logic is called, then synchronously rethrow the error.\n\t                        // After that, Promise will trap the error and send it\n\t                        // down the rejection path.\n\t                        next(value);\n\t                    }\n\t                }, reject, resolve);\n\t            });\n\t        };\n\t        Observable.prototype._subscribe = function (subscriber) {\n\t            return this.source.subscribe(subscriber);\n\t        };\n\t        /**\n\t         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t         * @method Symbol.observable\n\t         * @return {Observable} this instance of the observable\n\t         */\n\t        Observable.prototype[observable_1.$$observable] = function () {\n\t            return this;\n\t        };\n\t        // HACK: Since TypeScript inherits static properties too, we have to\n\t        // fight against TypeScript here so Subject can have a different static create signature\n\t        /**\n\t         * Creates a new cold Observable by calling the Observable constructor\n\t         * @static true\n\t         * @owner Observable\n\t         * @method create\n\t         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t         * @return {Observable} a new cold observable\n\t         */\n\t        Observable.create = function (subscribe) {\n\t            return new Observable(subscribe);\n\t        };\n\t        return Observable;\n\t    }());\n\t    exports.Observable = Observable;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    var objectTypes = {\n\t        'boolean': false,\n\t        'function': true,\n\t        'object': true,\n\t        'number': false,\n\t        'string': false,\n\t        'undefined': false\n\t    };\n\t    exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\t    /* tslint:disable:no-unused-variable */\n\t    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\t    var freeGlobal = objectTypes[typeof global] && global;\n\t    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n\t        exports.root = freeGlobal;\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)(module), (function() { return this; }())))\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(58)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1) {\n\t    \"use strict\";\n\t    var Symbol = root_1.root.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (Symbol.observable) {\n\t            exports.$$observable = Symbol.observable;\n\t        }\n\t        else {\n\t            if (typeof Symbol.for === 'function') {\n\t                exports.$$observable = Symbol.for('observable');\n\t            }\n\t            else {\n\t                exports.$$observable = Symbol('observable');\n\t            }\n\t            Symbol.observable = exports.$$observable;\n\t        }\n\t    }\n\t    else {\n\t        exports.$$observable = '@@observable';\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=observable.js.map\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(62), __webpack_require__(70)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, Subscriber_1, rxSubscriber_1) {\n\t    \"use strict\";\n\t    function toSubscriber(nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver === 'object') {\n\t            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t                return nextOrObserver;\n\t            }\n\t            else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n\t                return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t            }\n\t        }\n\t        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t    }\n\t    exports.toSubscriber = toSubscriber;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(63), __webpack_require__(64), __webpack_require__(70), __webpack_require__(71)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, isFunction_1, Subscription_1, rxSubscriber_1, Observer_1) {\n\t    \"use strict\";\n\t    /**\n\t     * Implements the {@link Observer} interface and extends the\n\t     * {@link Subscription} class. While the {@link Observer} is the public API for\n\t     * consuming the values of an {@link Observable}, all Observers get converted to\n\t     * a Subscriber, in order to provide Subscription-like capabilities such as\n\t     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t     * implementing operators, but it is rarely used as a public API.\n\t     *\n\t     * @class Subscriber<T>\n\t     */\n\t    var Subscriber = (function (_super) {\n\t        __extends(Subscriber, _super);\n\t        /**\n\t         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t         * defined Observer or a `next` callback function.\n\t         * @param {function(e: ?any): void} [error] The `error` callback of an\n\t         * Observer.\n\t         * @param {function(): void} [complete] The `complete` callback of an\n\t         * Observer.\n\t         */\n\t        function Subscriber(destinationOrNext, error, complete) {\n\t            _super.call(this);\n\t            this.syncErrorValue = null;\n\t            this.syncErrorThrown = false;\n\t            this.syncErrorThrowable = false;\n\t            this.isStopped = false;\n\t            switch (arguments.length) {\n\t                case 0:\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                case 1:\n\t                    if (!destinationOrNext) {\n\t                        this.destination = Observer_1.empty;\n\t                        break;\n\t                    }\n\t                    if (typeof destinationOrNext === 'object') {\n\t                        if (destinationOrNext instanceof Subscriber) {\n\t                            this.destination = destinationOrNext;\n\t                            this.destination.add(this);\n\t                        }\n\t                        else {\n\t                            this.syncErrorThrowable = true;\n\t                            this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                        }\n\t                        break;\n\t                    }\n\t                default:\n\t                    this.syncErrorThrowable = true;\n\t                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                    break;\n\t            }\n\t        }\n\t        /**\n\t         * A static factory for a Subscriber, given a (potentially partial) definition\n\t         * of an Observer.\n\t         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t         * @param {function(e: ?any): void} [error] The `error` callback of an\n\t         * Observer.\n\t         * @param {function(): void} [complete] The `complete` callback of an\n\t         * Observer.\n\t         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t         * Observer represented by the given arguments.\n\t         */\n\t        Subscriber.create = function (next, error, complete) {\n\t            var subscriber = new Subscriber(next, error, complete);\n\t            subscriber.syncErrorThrowable = false;\n\t            return subscriber;\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive notifications of type `next` from\n\t         * the Observable, with a value. The Observable may call this method 0 or more\n\t         * times.\n\t         * @param {T} [value] The `next` value.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.next = function (value) {\n\t            if (!this.isStopped) {\n\t                this._next(value);\n\t            }\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive notifications of type `error` from\n\t         * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t         * the Observable has experienced an error condition.\n\t         * @param {any} [err] The `error` exception.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.error = function (err) {\n\t            if (!this.isStopped) {\n\t                this.isStopped = true;\n\t                this._error(err);\n\t            }\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive a valueless notification of type\n\t         * `complete` from the Observable. Notifies the Observer that the Observable\n\t         * has finished sending push-based notifications.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.complete = function () {\n\t            if (!this.isStopped) {\n\t                this.isStopped = true;\n\t                this._complete();\n\t            }\n\t        };\n\t        Subscriber.prototype.unsubscribe = function () {\n\t            if (this.isUnsubscribed) {\n\t                return;\n\t            }\n\t            this.isStopped = true;\n\t            _super.prototype.unsubscribe.call(this);\n\t        };\n\t        Subscriber.prototype._next = function (value) {\n\t            this.destination.next(value);\n\t        };\n\t        Subscriber.prototype._error = function (err) {\n\t            this.destination.error(err);\n\t            this.unsubscribe();\n\t        };\n\t        Subscriber.prototype._complete = function () {\n\t            this.destination.complete();\n\t            this.unsubscribe();\n\t        };\n\t        Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n\t            return this;\n\t        };\n\t        return Subscriber;\n\t    }(Subscription_1.Subscription));\n\t    exports.Subscriber = Subscriber;\n\t    /**\n\t     * We need this JSDoc comment for affecting ESDoc.\n\t     * @ignore\n\t     * @extends {Ignored}\n\t     */\n\t    var SafeSubscriber = (function (_super) {\n\t        __extends(SafeSubscriber, _super);\n\t        function SafeSubscriber(_parent, observerOrNext, error, complete) {\n\t            _super.call(this);\n\t            this._parent = _parent;\n\t            var next;\n\t            var context = this;\n\t            if (isFunction_1.isFunction(observerOrNext)) {\n\t                next = observerOrNext;\n\t            }\n\t            else if (observerOrNext) {\n\t                context = observerOrNext;\n\t                next = observerOrNext.next;\n\t                error = observerOrNext.error;\n\t                complete = observerOrNext.complete;\n\t                if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                    this.add(context.unsubscribe.bind(context));\n\t                }\n\t                context.unsubscribe = this.unsubscribe.bind(this);\n\t            }\n\t            this._context = context;\n\t            this._next = next;\n\t            this._error = error;\n\t            this._complete = complete;\n\t        }\n\t        SafeSubscriber.prototype.next = function (value) {\n\t            if (!this.isStopped && this._next) {\n\t                var _parent = this._parent;\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._next, value);\n\t                }\n\t                else if (this.__tryOrSetError(_parent, this._next, value)) {\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.error = function (err) {\n\t            if (!this.isStopped) {\n\t                var _parent = this._parent;\n\t                if (this._error) {\n\t                    if (!_parent.syncErrorThrowable) {\n\t                        this.__tryOrUnsub(this._error, err);\n\t                        this.unsubscribe();\n\t                    }\n\t                    else {\n\t                        this.__tryOrSetError(_parent, this._error, err);\n\t                        this.unsubscribe();\n\t                    }\n\t                }\n\t                else if (!_parent.syncErrorThrowable) {\n\t                    this.unsubscribe();\n\t                    throw err;\n\t                }\n\t                else {\n\t                    _parent.syncErrorValue = err;\n\t                    _parent.syncErrorThrown = true;\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.complete = function () {\n\t            if (!this.isStopped) {\n\t                var _parent = this._parent;\n\t                if (this._complete) {\n\t                    if (!_parent.syncErrorThrowable) {\n\t                        this.__tryOrUnsub(this._complete);\n\t                        this.unsubscribe();\n\t                    }\n\t                    else {\n\t                        this.__tryOrSetError(_parent, this._complete);\n\t                        this.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t            try {\n\t                fn.call(this._context, value);\n\t            }\n\t            catch (err) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t            try {\n\t                fn.call(this._context, value);\n\t            }\n\t            catch (err) {\n\t                parent.syncErrorValue = err;\n\t                parent.syncErrorThrown = true;\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        SafeSubscriber.prototype._unsubscribe = function () {\n\t            var _parent = this._parent;\n\t            this._context = null;\n\t            this._parent = null;\n\t            _parent.unsubscribe();\n\t        };\n\t        return SafeSubscriber;\n\t    }(Subscriber));\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    function isFunction(x) {\n\t        return typeof x === 'function';\n\t    }\n\t    exports.isFunction = isFunction;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(65), __webpack_require__(66), __webpack_require__(63), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n\t    \"use strict\";\n\t    /**\n\t     * Represents a disposable resource, such as the execution of an Observable. A\n\t     * Subscription has one important method, `unsubscribe`, that takes no argument\n\t     * and just disposes the resource held by the subscription.\n\t     *\n\t     * Additionally, subscriptions may be grouped together through the `add()`\n\t     * method, which will attach a child Subscription to the current Subscription.\n\t     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t     * will be unsubscribed as well.\n\t     *\n\t     * @class Subscription\n\t     */\n\t    var Subscription = (function () {\n\t        /**\n\t         * @param {function(): void} [unsubscribe] A function describing how to\n\t         * perform the disposal of resources when the `unsubscribe` method is called.\n\t         */\n\t        function Subscription(unsubscribe) {\n\t            /**\n\t             * A flag to indicate whether this Subscription has already been unsubscribed.\n\t             * @type {boolean}\n\t             */\n\t            this.isUnsubscribed = false;\n\t            if (unsubscribe) {\n\t                this._unsubscribe = unsubscribe;\n\t            }\n\t        }\n\t        /**\n\t         * Disposes the resources held by the subscription. May, for instance, cancel\n\t         * an ongoing Observable execution or cancel any other type of work that\n\t         * started when the Subscription was created.\n\t         * @return {void}\n\t         */\n\t        Subscription.prototype.unsubscribe = function () {\n\t            var hasErrors = false;\n\t            var errors;\n\t            if (this.isUnsubscribed) {\n\t                return;\n\t            }\n\t            this.isUnsubscribed = true;\n\t            var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t            this._subscriptions = null;\n\t            if (isFunction_1.isFunction(_unsubscribe)) {\n\t                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t                if (trial === errorObject_1.errorObject) {\n\t                    hasErrors = true;\n\t                    (errors = errors || []).push(errorObject_1.errorObject.e);\n\t                }\n\t            }\n\t            if (isArray_1.isArray(_subscriptions)) {\n\t                var index = -1;\n\t                var len = _subscriptions.length;\n\t                while (++index < len) {\n\t                    var sub = _subscriptions[index];\n\t                    if (isObject_1.isObject(sub)) {\n\t                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                        if (trial === errorObject_1.errorObject) {\n\t                            hasErrors = true;\n\t                            errors = errors || [];\n\t                            var err = errorObject_1.errorObject.e;\n\t                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                                errors = errors.concat(err.errors);\n\t                            }\n\t                            else {\n\t                                errors.push(err);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if (hasErrors) {\n\t                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t            }\n\t        };\n\t        /**\n\t         * Adds a tear down to be called during the unsubscribe() of this\n\t         * Subscription.\n\t         *\n\t         * If the tear down being added is a subscription that is already\n\t         * unsubscribed, is the same reference `add` is being called on, or is\n\t         * `Subscription.EMPTY`, it will not be added.\n\t         *\n\t         * If this subscription is already in an `isUnsubscribed` state, the passed\n\t         * tear down logic will be executed immediately.\n\t         *\n\t         * @param {TeardownLogic} teardown The additional logic to execute on\n\t         * teardown.\n\t         * @return {Subscription} Returns the Subscription used or created to be\n\t         * added to the inner subscriptions list. This Subscription can be used with\n\t         * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t         * list.\n\t         */\n\t        Subscription.prototype.add = function (teardown) {\n\t            if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n\t                return;\n\t            }\n\t            var sub = teardown;\n\t            switch (typeof teardown) {\n\t                case 'function':\n\t                    sub = new Subscription(teardown);\n\t                case 'object':\n\t                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n\t                        break;\n\t                    }\n\t                    else if (this.isUnsubscribed) {\n\t                        sub.unsubscribe();\n\t                    }\n\t                    else {\n\t                        (this._subscriptions || (this._subscriptions = [])).push(sub);\n\t                    }\n\t                    break;\n\t                default:\n\t                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n\t            }\n\t            return sub;\n\t        };\n\t        /**\n\t         * Removes a Subscription from the internal list of subscriptions that will\n\t         * unsubscribe during the unsubscribe process of this Subscription.\n\t         * @param {Subscription} subscription The subscription to remove.\n\t         * @return {void}\n\t         */\n\t        Subscription.prototype.remove = function (subscription) {\n\t            // HACK: This might be redundant because of the logic in `add()`\n\t            if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t                return;\n\t            }\n\t            var subscriptions = this._subscriptions;\n\t            if (subscriptions) {\n\t                var subscriptionIndex = subscriptions.indexOf(subscription);\n\t                if (subscriptionIndex !== -1) {\n\t                    subscriptions.splice(subscriptionIndex, 1);\n\t                }\n\t            }\n\t        };\n\t        Subscription.EMPTY = (function (empty) {\n\t            empty.isUnsubscribed = true;\n\t            return empty;\n\t        }(new Subscription()));\n\t        return Subscription;\n\t    }());\n\t    exports.Subscription = Subscription;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    function isObject(x) {\n\t        return x != null && typeof x === 'object';\n\t    }\n\t    exports.isObject = isObject;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(68)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, errorObject_1) {\n\t    \"use strict\";\n\t    var tryCatchTarget;\n\t    function tryCatcher() {\n\t        try {\n\t            return tryCatchTarget.apply(this, arguments);\n\t        }\n\t        catch (e) {\n\t            errorObject_1.errorObject.e = e;\n\t            return errorObject_1.errorObject;\n\t        }\n\t    }\n\t    function tryCatch(fn) {\n\t        tryCatchTarget = fn;\n\t        return tryCatcher;\n\t    }\n\t    exports.tryCatch = tryCatch;\n\t    ;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    // typeof any so that it we don't have to cast when comparing a result to the error object\n\t    exports.errorObject = { e: {} };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * An error thrown when one or more errors have occurred during the\n\t     * `unsubscribe` of a {@link Subscription}.\n\t     */\n\t    var UnsubscriptionError = (function (_super) {\n\t        __extends(UnsubscriptionError, _super);\n\t        function UnsubscriptionError(errors) {\n\t            _super.call(this);\n\t            this.errors = errors;\n\t            this.name = 'UnsubscriptionError';\n\t            this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n\t        }\n\t        return UnsubscriptionError;\n\t    }(Error));\n\t    exports.UnsubscriptionError = UnsubscriptionError;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(58)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1) {\n\t    \"use strict\";\n\t    var Symbol = root_1.root.Symbol;\n\t    exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    exports.empty = {\n\t        isUnsubscribed: true,\n\t        next: function (value) { },\n\t        error: function (err) { throw err; },\n\t        complete: function () { }\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createMemoryStore_1 = __webpack_require__(55);\n\tvar widgetStoreActions_1 = __webpack_require__(73);\n\tvar array_1 = __webpack_require__(25);\n\tvar cardStore = createMemoryStore_1.default({\n\t    data: [\n\t        { id: 'card-1', cardType: 'momentum', name: 'Brainstorming', description: 'People\\'s best ideas often come to them when they\\'re alone, but so do their worst. Your team brainstorms to build on each other\\'s great ideas.', score: 1, tagline: '', imageClass: 'Cards-Momentum1', favouriteCount: 0 },\n\t        { id: 'card-2', cardType: 'momentum', name: 'Clear Objectives', description: 'You tell your team that knowing the goal of the task is far more important than understanding the specific words of the request.', score: 3, tagline: '', imageClass: 'Cards-Momentum2', favouriteCount: 0 },\n\t        { id: 'card-3', cardType: 'momentum', name: 'Code Conventions', description: 'While tabs are superior to spaces in every way, the most important thing is that everyone on the project is structuring their code the same way.', score: 1, tagline: '', imageClass: 'Cards-Momentum3', favouriteCount: 0 },\n\t        { id: 'card-4', cardType: 'momentum', name: 'Code Reviews', description: 'The major benefit of your code review initiative wasn\\'t reducing errors, but in the camaraderie it built between engineers.', score: 4, tagline: '', imageClass: 'Cards-Momentum4', favouriteCount: 0 },\n\t        { id: 'card-5', cardType: 'momentum', name: 'Collaboration', description: 'Through collaboration, your team sees more of the big picture then most, enabling them to make better decisions.', score: 1, tagline: '', imageClass: 'Cards-Momentum5', favouriteCount: 0 },\n\t        { id: 'card-6', cardType: 'momentum', name: 'Communication', description: 'Your team communicates effectively, helping to avoid last minute scrambles and missed milestones.', score: 3, tagline: '', imageClass: 'Cards-Momentum6', favouriteCount: 0 },\n\t        { id: 'card-7', cardType: 'momentum', name: 'Decision Makers', description: 'Your team feels empowered to make important real-time decisions, removing minor roadblocks before they impact the entire project.', score: 4, tagline: '', imageClass: 'Cards-Momentum7', favouriteCount: 0 },\n\t        { id: 'card-8', cardType: 'momentum', name: 'Delegation', description: 'You let your team know that you don\\'t have to be involved in every decision. You trust them to use their judgement.', score: 2, tagline: '', imageClass: 'Cards-Momentum8', favouriteCount: 0 },\n\t        { id: 'card-9', cardType: 'momentum', name: 'Design Iteration', description: 'Your designers and developers iterate together to make sure that what\\'s being designed and built delivers the best possible experience', score: 2, tagline: '', imageClass: 'Cards-Momentum9', favouriteCount: 0 },\n\t        { id: 'card-10', cardType: 'momentum', name: 'Donuts!', description: 'Let\\'s be honest, we all revert to a childlike state when in the presence of sprinkled donuts.', score: 3, tagline: '', imageClass: 'Cards-Momentum10', favouriteCount: 0 },\n\t        { id: 'card-11', cardType: 'momentum', name: 'Feedback', description: 'You encourage the team to raise issues as they see them instead of letting them fester, even if the issue is you.', score: 2, tagline: '', imageClass: 'Cards-Momentum11', favouriteCount: 0 },\n\t        { id: 'card-12', cardType: 'momentum', name: 'Focused Meetings', description: 'You convinced \"The Inviter\" that the entire development team didn\\'t need to attend the weekly marketing meeting.', score: 1, tagline: '', imageClass: 'Cards-Momentum12', favouriteCount: 0 },\n\t        { id: 'card-13', cardType: 'momentum', name: 'Future Proofing', description: 'Your team not only solves the immediate problem, but works hard to ensure they aren\\'t creating new ones down the road.', score: 1, tagline: '', imageClass: 'Cards-Momentum13', favouriteCount: 0 },\n\t        { id: 'card-14', cardType: 'momentum', name: 'Hackathon', description: 'At the monthly hackathon you organized, the team came up with a clever way to improve the performance of your app.', score: 3, tagline: '', imageClass: 'Cards-Momentum14', favouriteCount: 0 },\n\t        { id: 'card-15', cardType: 'momentum', name: 'Integrated Teams', description: 'The project really started humming when you created small integrated teams of designers and engineers focused on specific features of the project.', score: 1, tagline: '', imageClass: 'Cards-Momentum15', favouriteCount: 0 },\n\t        { id: 'card-16', cardType: 'momentum', name: 'Leadership', description: 'You have built a team that believes leadership is a quality present in everyone and not inhereted from the top-down.', score: 4, tagline: '', imageClass: 'Cards-Momentum16', favouriteCount: 0 },\n\t        { id: 'card-17', cardType: 'momentum', name: 'Modern Tools', description: 'Moving to a modern toolchain cut down your build & deploy step from 12 minutes to 15 seconds.', score: 1, tagline: '', imageClass: 'Cards-Momentum17', favouriteCount: 0 },\n\t        { id: 'card-18', cardType: 'momentum', name: 'Open Source', description: 'Despite the Legal team\\'s fears of exploits and foreign hackers, they finally agreed to let you use \"Open Software\", as long as you \"close it up\".', score: 2, tagline: '', imageClass: 'Cards-Momentum18', favouriteCount: 0 },\n\t        { id: 'card-19', cardType: 'momentum', name: 'Planning', description: 'Knowing you could not control the other team, you influenced them by leading by example and demonstrating you had a viable plan to follow.', score: 2, tagline: '', imageClass: 'Cards-Momentum19', favouriteCount: 0 },\n\t        { id: 'card-20', cardType: 'momentum', name: 'Prioritization', description: 'You looked the VP right in the eye and told him that if everything is a top priority, nothing is.', score: 2, tagline: '', imageClass: 'Cards-Momentum20', favouriteCount: 0 },\n\t        { id: 'card-21', cardType: 'momentum', name: 'Recognition', description: 'When a VP thanked you for your good work on the latest demo, you asked the VP to thank your team in person, as well.', score: 4, tagline: '', imageClass: 'Cards-Momentum21', favouriteCount: 0 },\n\t        { id: 'card-22', cardType: 'momentum', name: 'Recruiting', description: 'Hiring a great team has become your best recruiting tool. Smart people want to work with other smart people.', score: 1, tagline: '', imageClass: 'Cards-Momentum22', favouriteCount: 0 },\n\t        { id: 'card-23', cardType: 'momentum', name: 'Requirements', description: 'Your team reviews each requirement in detail before starting each milestone to identify any gray areas that can be quickly clarified.', score: 3, tagline: '', imageClass: 'Cards-Momentum23', favouriteCount: 0 },\n\t        { id: 'card-24', cardType: 'momentum', name: 'Reusable Code', description: 'You save the orginization months of development hours by setting up a shared code repository', score: 2, tagline: '', imageClass: 'Cards-Momentum24', favouriteCount: 0 },\n\t        { id: 'card-25', cardType: 'momentum', name: 'Solid Architecture', description: 'Your architecture weathered the storm of changing business needs, letting your team focus on quickly delivering business value.', score: 1, tagline: '', imageClass: 'Cards-Momentum25', favouriteCount: 0 },\n\t        { id: 'card-26', cardType: 'momentum', name: 'Testing Plan', description: 'Your team \\'miraculously\\' knew if their code was working before they shipped it, avoiding rework.', score: 4, tagline: '', imageClass: 'Cards-Momentum26', favouriteCount: 0 },\n\t        { id: 'card-27', cardType: 'momentum', name: 'The A-Team', description: 'Your team has been called in to save the day in a flailing project, and they turn it around, but you still \\'don\\'t pity the fool!', score: 1, tagline: '', imageClass: 'Cards-Momentum27', favouriteCount: 0 },\n\t        { id: 'card-28', cardType: 'momentum', name: 'Unit Testing', description: 'Woah! The new developer on the team made their first commit in under a day, and the unit tests saved them from breaking the build.', score: 1, tagline: '', imageClass: 'Cards-Momentum28', favouriteCount: 0 },\n\t        { id: 'card-29', cardType: 'momentum', name: 'Work/Life Balance', description: 'Your team offered to work the weekend to get ahead of the game, but you let them know that personal time was more important.', score: 1, tagline: '', imageClass: 'Cards-Momentum29', favouriteCount: 0 },\n\t        { id: 'card-30', cardType: 'momentum', name: 'Workshops', description: 'Technology moves fast, but you\\'ve invested in your team by providing ongoing education. Your team is up to speed while others are stagnating.', score: 2, tagline: '', imageClass: 'Cards-Momentum30', favouriteCount: 0 },\n\t        { id: 'card-31', cardType: 'mayhem', name: 'Blunderer', description: 'The build broke...again! Some people on your team know just enough to be dangerous.', score: 1, tagline: '', imageClass: 'Cards-Mayhem1', favouriteCount: 0 },\n\t        { id: 'card-32', cardType: 'mayhem', name: 'Brain Drain', description: 'The only person who understands how your legacy app works just left for a hot, new startup.', score: 3, tagline: '', imageClass: 'Cards-Mayhem2', favouriteCount: 0 },\n\t        { id: 'card-33', cardType: 'mayhem', name: 'Dead-Line', description: 'The VP of Sales informs you that your project will need to be finished a few weeks early. No biggie, right?', score: 1, tagline: '', imageClass: 'Cards-Mayhem3', favouriteCount: 0 },\n\t        { id: 'card-34', cardType: 'mayhem', name: 'Dr. Deflector', description: 'Features were announced that aren\\'t even on the roadmap. Somehow, it\\'s your fault they won\\'t be included.', score: 4, tagline: '', imageClass: 'Cards-Mayhem4', favouriteCount: 0 },\n\t        { id: 'card-35', cardType: 'mayhem', name: 'Gen. Death March', description: 'Despite your plea for more time, the only thing you received was permission to work harder.', score: 1, tagline: '', imageClass: 'Cards-Mayhem5', favouriteCount: 0 },\n\t        { id: 'card-36', cardType: 'mayhem', name: 'Grim Repo', description: 'The wrong branch was merged into production. Untangling this mess is going to be a nightmare.', score: 3, tagline: '', imageClass: 'Cards-Mayhem6', favouriteCount: 0 },\n\t        { id: 'card-37', cardType: 'mayhem', name: 'King of Confusion', description: 'At a recent meeting to get everyone on the same page, it turned out that nobody was even in the same book.', score: 4, tagline: '', imageClass: 'Cards-Mayhem7', favouriteCount: 0 },\n\t        { id: 'card-38', cardType: 'mayhem', name: 'Landmine', description: 'Half of the requirements say \"TBD Later\". It\\'s well past later and nobody has determined anything.', score: 2, tagline: '', imageClass: 'Cards-Mayhem8', favouriteCount: 0 },\n\t        { id: 'card-39', cardType: 'mayhem', name: 'Pet Pony', description: 'Just like a six-year-old who wants a pony, stakeholders want their new ideas implemented NOW!', score: 2, tagline: '', imageClass: 'Cards-Mayhem9', favouriteCount: 0 },\n\t        { id: 'card-40', cardType: 'mayhem', name: 'Scope Creep', description: 'Apparently, a \"few small changes\" means 17 new user stories.', score: 3, tagline: '', imageClass: 'Cards-Mayhem10', favouriteCount: 0 },\n\t        { id: 'card-41', cardType: 'mayhem', name: 'Slingshot', description: 'DevOps changed the authentication scheme but how it affects your project is \"not their problem\".', score: 2, tagline: '', imageClass: 'Cards-Mayhem11', favouriteCount: 0 },\n\t        { id: 'card-42', cardType: 'mayhem', name: 'The Eraser', description: 'The only thing complete about the UI design is how completely lacking it is in detail.', score: 1, tagline: '', imageClass: 'Cards-Mayhem12', favouriteCount: 0 },\n\t        { id: 'card-43', cardType: 'mayhem', name: 'The Gambler', description: 'The closer the deadline gets, the more liberal your team becomes with the definition of \"done\".', score: 1, tagline: '', imageClass: 'Cards-Mayhem13', favouriteCount: 0 },\n\t        { id: 'card-44', cardType: 'mayhem', name: 'The Horde', description: 'Instead of more time to meet your requirements, you got a dozen untrained interns to \"help\".', score: 3, tagline: '', imageClass: 'Cards-Mayhem14', favouriteCount: 0 },\n\t        { id: 'card-45', cardType: 'mayhem', name: 'The Inventor', description: 'When discussing what framework to use, an enthusiastic voice says, \"We\\'ll just roll our own!\"', score: 1, tagline: '', imageClass: 'Cards-Mayhem15', favouriteCount: 0 },\n\t        { id: 'card-46', cardType: 'mayhem', name: 'The Inviter', description: 'You and your team have been invited to daily meetings to discuss your \"lack of progress\".', score: 4, tagline: '', imageClass: 'Cards-Mayhem16', favouriteCount: 0 },\n\t        { id: 'card-47', cardType: 'mayhem', name: 'The Juggler', description: 'Flimsy dates, changing priorities and bad assumptions are the pillars of your project manager\\'s master plan!', score: 1, tagline: '', imageClass: 'Cards-Mayhem17', favouriteCount: 0 },\n\t        { id: 'card-48', cardType: 'mayhem', name: 'Sigh-Low', description: 'While on a conference call it becomes painfully clear...two different teams just completed the same work.', score: 2, tagline: '', imageClass: 'Cards-Mayhem18', favouriteCount: 0 },\n\t        { id: 'card-49', cardType: 'mayhem', name: 'Caveman Coder', description: 'You brought in a contractor, who smashed your code until it \"worked\" and then he committed it to master.', score: 2, tagline: '', imageClass: 'Cards-Mayhem19', favouriteCount: 0 }\n\t    ]\n\t});\n\tfunction bindActions() {\n\t    return cardStore.observe().subscribe(function (options) {\n\t        var changeRecord = options;\n\t        return widgetStoreActions_1.putCard.do(changeRecord);\n\t    });\n\t}\n\texports.bindActions = bindActions;\n\tfunction getShuffledCards() {\n\t    return cardStore.get().then(function (cards) {\n\t        var shuffledArray = array_1.from(cards);\n\t        var i = 0;\n\t        var j = 0;\n\t        var temp;\n\t        for (i = shuffledArray.length - 1; i > 0; i -= 1) {\n\t            j = Math.floor(Math.random() * (i + 1));\n\t            temp = shuffledArray[i];\n\t            shuffledArray[i] = shuffledArray[j];\n\t            shuffledArray[j] = temp;\n\t        }\n\t        return shuffledArray;\n\t    });\n\t}\n\texports.getShuffledCards = getShuffledCards;\n\tfunction pickRandomCards(numberToPick, exclude) {\n\t    if (exclude === void 0) { exclude = []; }\n\t    return getShuffledCards().then(function (cards) {\n\t        var filteredCards = cards.filter(function (card) { return exclude.indexOf(card.id) < 0; });\n\t        return filteredCards.slice(0, Math.min(filteredCards.length, numberToPick));\n\t    });\n\t}\n\texports.pickRandomCards = pickRandomCards;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = cardStore;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createAction_1 = __webpack_require__(51);\n\tvar widgetStore_1 = __webpack_require__(54);\n\tfunction getStates(cards) {\n\t    var cardStates = [];\n\t    var cardSummaryStates = [];\n\t    cards.forEach(function (_a) {\n\t        var id = _a.id, name = _a.name, imageClass = _a.imageClass, score = _a.score;\n\t        cardStates.push({ id: id, imageClass: imageClass });\n\t        cardSummaryStates.push({ name: name, imageClass: imageClass, score: score, id: id });\n\t    });\n\t    return [cardStates, cardSummaryStates];\n\t}\n\texports.putCard = createAction_1.default({\n\t    do: function (_a) {\n\t        var afterAll = _a.afterAll, puts = _a.puts;\n\t        if (puts.length) {\n\t            var _b = getStates(afterAll), cardStates = _b[0], cardSummaryStates = _b[1];\n\t            widgetStore_1.default.patch({ id: 'cards', cards: cardSummaryStates });\n\t            widgetStore_1.default.patch({ id: 'cardDetails', cards: cardStates });\n\t        }\n\t    }\n\t});\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar d_1 = __webpack_require__(75);\n\tvar createProjector_1 = __webpack_require__(78);\n\tvar createNavbar_1 = __webpack_require__(86);\n\tvar createHomePage_1 = __webpack_require__(88);\n\tvar createCardDetailsPage_1 = __webpack_require__(90);\n\tvar createCardsPage_1 = __webpack_require__(95);\n\tvar createGameplayPage_1 = __webpack_require__(98);\n\tvar createAboutPage_1 = __webpack_require__(99);\n\tvar previousRouteDNode;\n\tfunction getPageFromRoute(instance) {\n\t    var state = instance.state;\n\t    var routeDNode;\n\t    var options = {\n\t        id: state.route,\n\t        stateFrom: instance.stateFrom\n\t    };\n\t    switch (state.route) {\n\t        case 'home':\n\t            routeDNode = d_1.w(createHomePage_1.default, options);\n\t            break;\n\t        case 'cards':\n\t            routeDNode = d_1.w(createCardsPage_1.default, options);\n\t            break;\n\t        case 'cardDetails':\n\t            routeDNode = d_1.w(createCardDetailsPage_1.default, options);\n\t            break;\n\t        case 'gameplay':\n\t            routeDNode = d_1.w(createGameplayPage_1.default, options);\n\t            break;\n\t        case 'about':\n\t            routeDNode = d_1.w(createAboutPage_1.default, options);\n\t            break;\n\t        default:\n\t            if (previousRouteDNode) {\n\t                routeDNode = previousRouteDNode;\n\t            }\n\t            else {\n\t                routeDNode = d_1.w(createHomePage_1.default, options);\n\t            }\n\t    }\n\t    previousRouteDNode = routeDNode;\n\t    return routeDNode;\n\t}\n\tvar createApp = createProjector_1.default.mixin({\n\t    mixin: {\n\t        getChildrenNodes: function () {\n\t            var stateFrom = this.stateFrom;\n\t            if (this.state.route) {\n\t                return [\n\t                    d_1.w(createNavbar_1.default, { id: 'navbar', stateFrom: stateFrom }),\n\t                    getPageFromRoute(this)\n\t                ];\n\t            }\n\t            return [];\n\t        },\n\t        tagName: 'main'\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createApp;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\tvar maquette_1 = __webpack_require__(76);\n\tvar FactoryRegistry_1 = __webpack_require__(77);\n\texports.registry = new FactoryRegistry_1.default();\n\tfunction w(factory, options, children) {\n\t    if (children === void 0) { children = []; }\n\t    return {\n\t        children: children,\n\t        factory: factory,\n\t        options: options\n\t    };\n\t}\n\texports.w = w;\n\tfunction v(tag, optionsOrChildren, children) {\n\t    if (optionsOrChildren === void 0) { optionsOrChildren = {}; }\n\t    if (children === void 0) { children = []; }\n\t    if (Array.isArray(optionsOrChildren)) {\n\t        children = optionsOrChildren;\n\t        optionsOrChildren = {};\n\t    }\n\t    return {\n\t        children: children,\n\t        render: function (options) {\n\t            if (options === void 0) { options = {}; }\n\t            return maquette_1.h(tag, lang_1.assign(options, optionsOrChildren), this.children);\n\t        }\n\t    };\n\t}\n\texports.v = v;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n\t        // CommonJS\n\t        factory(exports);\n\t    } else {\n\t        // Browser globals\n\t        factory(root.maquette = {});\n\t    }\n\t}(this, function (exports) {\n\t    'use strict';\n\t    ;\n\t    ;\n\t    ;\n\t    ;\n\t    var NAMESPACE_W3 = 'http://www.w3.org/';\n\t    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n\t    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n\t    // Utilities\n\t    var emptyArray = [];\n\t    var extend = function (base, overrides) {\n\t        var result = {};\n\t        Object.keys(base).forEach(function (key) {\n\t            result[key] = base[key];\n\t        });\n\t        if (overrides) {\n\t            Object.keys(overrides).forEach(function (key) {\n\t                result[key] = overrides[key];\n\t            });\n\t        }\n\t        return result;\n\t    };\n\t    // Hyperscript helper functions\n\t    var same = function (vnode1, vnode2) {\n\t        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n\t            return false;\n\t        }\n\t        if (vnode1.properties && vnode2.properties) {\n\t            if (vnode1.properties.key !== vnode2.properties.key) {\n\t                return false;\n\t            }\n\t            return vnode1.properties.bind === vnode2.properties.bind;\n\t        }\n\t        return !vnode1.properties && !vnode2.properties;\n\t    };\n\t    var toTextVNode = function (data) {\n\t        return {\n\t            vnodeSelector: '',\n\t            properties: undefined,\n\t            children: undefined,\n\t            text: data.toString(),\n\t            domNode: null\n\t        };\n\t    };\n\t    var appendChildren = function (parentSelector, insertions, main) {\n\t        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n\t            var item = insertions[i];\n\t            if (Array.isArray(item)) {\n\t                appendChildren(parentSelector, item, main);\n\t            } else {\n\t                if (item !== null && item !== undefined) {\n\t                    if (!item.hasOwnProperty('vnodeSelector')) {\n\t                        item = toTextVNode(item);\n\t                    }\n\t                    main.push(item);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Render helper functions\n\t    var missingTransition = function () {\n\t        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n\t    };\n\t    var DEFAULT_PROJECTION_OPTIONS = {\n\t        namespace: undefined,\n\t        eventHandlerInterceptor: undefined,\n\t        styleApplyer: function (domNode, styleName, value) {\n\t            // Provides a hook to add vendor prefixes for browsers that still need it.\n\t            domNode.style[styleName] = value;\n\t        },\n\t        transitions: {\n\t            enter: missingTransition,\n\t            exit: missingTransition\n\t        }\n\t    };\n\t    var applyDefaultProjectionOptions = function (projectorOptions) {\n\t        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n\t    };\n\t    var checkStyleValue = function (styleValue) {\n\t        if (typeof styleValue !== 'string') {\n\t            throw new Error('Style values must be strings');\n\t        }\n\t    };\n\t    var setProperties = function (domNode, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            /* tslint:disable:no-var-keyword: edge case */\n\t            var propValue = properties[propName];\n\t            /* tslint:enable:no-var-keyword */\n\t            if (propName === 'className') {\n\t                throw new Error('Property \"className\" is not supported, use \"class\".');\n\t            } else if (propName === 'class') {\n\t                propValue.split(/\\s+/).forEach(function (token) {\n\t                    return domNode.classList.add(token);\n\t                });\n\t            } else if (propName === 'classes') {\n\t                // object with string keys and boolean values\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    if (propValue[className]) {\n\t                        domNode.classList.add(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                // object with string keys and string (!) values\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var styleValue = propValue[styleName];\n\t                    if (styleValue) {\n\t                        checkStyleValue(styleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n\t                    }\n\t                }\n\t            } else if (propName === 'key') {\n\t                continue;\n\t            } else if (propValue === null || propValue === undefined) {\n\t                continue;\n\t            } else {\n\t                var type = typeof propValue;\n\t                if (type === 'function') {\n\t                    if (propName.lastIndexOf('on', 0) === 0) {\n\t                        if (eventHandlerInterceptor) {\n\t                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n\t                        }\n\t                        if (propName === 'oninput') {\n\t                            (function () {\n\t                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n\t                                var oldPropValue = propValue;\n\t                                propValue = function (evt) {\n\t                                    evt.target['oninput-value'] = evt.target.value;\n\t                                    // may be HTMLTextAreaElement as well\n\t                                    oldPropValue.apply(this, [evt]);\n\t                                };\n\t                            }());\n\t                        }\n\t                        domNode[propName] = propValue;\n\t                    }\n\t                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n\t                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                    } else {\n\t                        domNode.setAttribute(propName, propValue);\n\t                    }\n\t                } else {\n\t                    domNode[propName] = propValue;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var propertiesUpdated = false;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            // assuming that properties will be nullified instead of missing is by design\n\t            var propValue = properties[propName];\n\t            var previousValue = previousProperties[propName];\n\t            if (propName === 'class') {\n\t                if (previousValue !== propValue) {\n\t                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n\t                }\n\t            } else if (propName === 'classes') {\n\t                var classList = domNode.classList;\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    var on = !!propValue[className];\n\t                    var previousOn = !!previousValue[className];\n\t                    if (on === previousOn) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (on) {\n\t                        classList.add(className);\n\t                    } else {\n\t                        classList.remove(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var newStyleValue = propValue[styleName];\n\t                    var oldStyleValue = previousValue[styleName];\n\t                    if (newStyleValue === oldStyleValue) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (newStyleValue) {\n\t                        checkStyleValue(newStyleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n\t                    } else {\n\t                        projectionOptions.styleApplyer(domNode, styleName, '');\n\t                    }\n\t                }\n\t            } else {\n\t                if (!propValue && typeof previousValue === 'string') {\n\t                    propValue = '';\n\t                }\n\t                if (propName === 'value') {\n\t                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n\t                        domNode[propName] = propValue;\n\t                        // Reset the value, even if the virtual DOM did not change\n\t                        domNode['oninput-value'] = undefined;\n\t                    }\n\t                    // else do not update the domNode, otherwise the cursor position would be changed\n\t                    if (propValue !== previousValue) {\n\t                        propertiesUpdated = true;\n\t                    }\n\t                } else if (propValue !== previousValue) {\n\t                    var type = typeof propValue;\n\t                    if (type === 'function') {\n\t                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n\t                    }\n\t                    if (type === 'string' && propName !== 'innerHTML') {\n\t                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                        } else {\n\t                            domNode.setAttribute(propName, propValue);\n\t                        }\n\t                    } else {\n\t                        if (domNode[propName] !== propValue) {\n\t                            domNode[propName] = propValue;\n\t                        }\n\t                    }\n\t                    propertiesUpdated = true;\n\t                }\n\t            }\n\t        }\n\t        return propertiesUpdated;\n\t    };\n\t    var findIndexOfChild = function (children, sameAs, start) {\n\t        if (sameAs.vnodeSelector !== '') {\n\t            // Never scan for text-nodes\n\t            for (var i = start; i < children.length; i++) {\n\t                if (same(children[i], sameAs)) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    var nodeAdded = function (vNode, transitions) {\n\t        if (vNode.properties) {\n\t            var enterAnimation = vNode.properties.enterAnimation;\n\t            if (enterAnimation) {\n\t                if (typeof enterAnimation === 'function') {\n\t                    enterAnimation(vNode.domNode, vNode.properties);\n\t                } else {\n\t                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var nodeToRemove = function (vNode, transitions) {\n\t        var domNode = vNode.domNode;\n\t        if (vNode.properties) {\n\t            var exitAnimation = vNode.properties.exitAnimation;\n\t            if (exitAnimation) {\n\t                domNode.style.pointerEvents = 'none';\n\t                var removeDomNode = function () {\n\t                    if (domNode.parentNode) {\n\t                        domNode.parentNode.removeChild(domNode);\n\t                    }\n\t                };\n\t                if (typeof exitAnimation === 'function') {\n\t                    exitAnimation(domNode, removeDomNode, vNode.properties);\n\t                    return;\n\t                } else {\n\t                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t        if (domNode.parentNode) {\n\t            domNode.parentNode.removeChild(domNode);\n\t        }\n\t    };\n\t    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n\t        var childNode = childNodes[indexToCheck];\n\t        if (childNode.vnodeSelector === '') {\n\t            return;    // Text nodes need not be distinguishable\n\t        }\n\t        var properties = childNode.properties;\n\t        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n\t        if (!key) {\n\t            for (var i = 0; i < childNodes.length; i++) {\n\t                if (i !== indexToCheck) {\n\t                    var node = childNodes[i];\n\t                    if (same(node, childNode)) {\n\t                        if (operation === 'added') {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n\t                        } else {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var createDom;\n\t    var updateDom;\n\t    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n\t        if (oldChildren === newChildren) {\n\t            return false;\n\t        }\n\t        oldChildren = oldChildren || emptyArray;\n\t        newChildren = newChildren || emptyArray;\n\t        var oldChildrenLength = oldChildren.length;\n\t        var newChildrenLength = newChildren.length;\n\t        var transitions = projectionOptions.transitions;\n\t        var oldIndex = 0;\n\t        var newIndex = 0;\n\t        var i;\n\t        var textUpdated = false;\n\t        while (newIndex < newChildrenLength) {\n\t            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n\t            var newChild = newChildren[newIndex];\n\t            if (oldChild !== undefined && same(oldChild, newChild)) {\n\t                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n\t                oldIndex++;\n\t            } else {\n\t                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n\t                if (findOldIndex >= 0) {\n\t                    // Remove preceding missing children\n\t                    for (i = oldIndex; i < findOldIndex; i++) {\n\t                        nodeToRemove(oldChildren[i], transitions);\n\t                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t                    }\n\t                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n\t                    oldIndex = findOldIndex + 1;\n\t                } else {\n\t                    // New child\n\t                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n\t                    nodeAdded(newChild, transitions);\n\t                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n\t                }\n\t            }\n\t            newIndex++;\n\t        }\n\t        if (oldChildrenLength > oldIndex) {\n\t            // Remove child fragments\n\t            for (i = oldIndex; i < oldChildrenLength; i++) {\n\t                nodeToRemove(oldChildren[i], transitions);\n\t                checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t            }\n\t        }\n\t        return textUpdated;\n\t    };\n\t    var addChildren = function (domNode, children, projectionOptions) {\n\t        if (!children) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < children.length; i++) {\n\t            createDom(children[i], domNode, undefined, projectionOptions);\n\t        }\n\t    };\n\t    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n\t        addChildren(domNode, vnode.children, projectionOptions);\n\t        // children before properties, needed for value property of <select>.\n\t        if (vnode.text) {\n\t            domNode.textContent = vnode.text;\n\t        }\n\t        setProperties(domNode, vnode.properties, projectionOptions);\n\t        if (vnode.properties && vnode.properties.afterCreate) {\n\t            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n\t                domNode,\n\t                projectionOptions,\n\t                vnode.vnodeSelector,\n\t                vnode.properties,\n\t                vnode.children\n\t            ]);\n\t        }\n\t    };\n\t    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n\t        var domNode, i, c, start = 0, type, found;\n\t        var vnodeSelector = vnode.vnodeSelector;\n\t        if (vnodeSelector === '') {\n\t            domNode = vnode.domNode = document.createTextNode(vnode.text);\n\t            if (insertBefore !== undefined) {\n\t                parentNode.insertBefore(domNode, insertBefore);\n\t            } else {\n\t                parentNode.appendChild(domNode);\n\t            }\n\t        } else {\n\t            for (i = 0; i <= vnodeSelector.length; ++i) {\n\t                c = vnodeSelector.charAt(i);\n\t                if (i === vnodeSelector.length || c === '.' || c === '#') {\n\t                    type = vnodeSelector.charAt(start - 1);\n\t                    found = vnodeSelector.slice(start, i);\n\t                    if (type === '.') {\n\t                        domNode.classList.add(found);\n\t                    } else if (type === '#') {\n\t                        domNode.id = found;\n\t                    } else {\n\t                        if (found === 'svg') {\n\t                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t                        }\n\t                        if (projectionOptions.namespace !== undefined) {\n\t                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n\t                        } else {\n\t                            domNode = vnode.domNode = document.createElement(found);\n\t                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n\t                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n\t                                domNode.setAttribute('type', vnode.properties.type);\n\t                            }\n\t                        }\n\t                        if (insertBefore !== undefined) {\n\t                            parentNode.insertBefore(domNode, insertBefore);\n\t                        } else {\n\t                            parentNode.appendChild(domNode);\n\t                        }\n\t                    }\n\t                    start = i + 1;\n\t                }\n\t            }\n\t            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n\t        }\n\t    };\n\t    updateDom = function (previous, vnode, projectionOptions) {\n\t        var domNode = previous.domNode;\n\t        var textUpdated = false;\n\t        if (previous === vnode) {\n\t            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n\t        }\n\t        var updated = false;\n\t        if (vnode.vnodeSelector === '') {\n\t            if (vnode.text !== previous.text) {\n\t                var newVNode = document.createTextNode(vnode.text);\n\t                domNode.parentNode.replaceChild(newVNode, domNode);\n\t                vnode.domNode = newVNode;\n\t                textUpdated = true;\n\t                return textUpdated;\n\t            }\n\t        } else {\n\t            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n\t                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t            }\n\t            if (previous.text !== vnode.text) {\n\t                updated = true;\n\t                if (vnode.text === undefined) {\n\t                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n\t                } else {\n\t                    domNode.textContent = vnode.text;\n\t                }\n\t            }\n\t            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n\t            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n\t            if (vnode.properties && vnode.properties.afterUpdate) {\n\t                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n\t                    domNode,\n\t                    projectionOptions,\n\t                    vnode.vnodeSelector,\n\t                    vnode.properties,\n\t                    vnode.children\n\t                ]);\n\t            }\n\t        }\n\t        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n\t            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n\t        }\n\t        vnode.domNode = previous.domNode;\n\t        return textUpdated;\n\t    };\n\t    var createProjection = function (vnode, projectionOptions) {\n\t        return {\n\t            update: function (updatedVnode) {\n\t                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n\t                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n\t                }\n\t                updateDom(vnode, updatedVnode, projectionOptions);\n\t                vnode = updatedVnode;\n\t            },\n\t            domNode: vnode.domNode\n\t        };\n\t    };\n\t    ;\n\t    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n\t    exports.h = function (selector) {\n\t        var properties = arguments[1];\n\t        if (typeof selector !== 'string') {\n\t            throw new Error();\n\t        }\n\t        var childIndex = 1;\n\t        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n\t            childIndex = 2;\n\t        } else {\n\t            // Optional properties argument was omitted\n\t            properties = undefined;\n\t        }\n\t        var text = undefined;\n\t        var children = undefined;\n\t        var argsLength = arguments.length;\n\t        // Recognize a common special case where there is only a single text node\n\t        if (argsLength === childIndex + 1) {\n\t            var onlyChild = arguments[childIndex];\n\t            if (typeof onlyChild === 'string') {\n\t                text = onlyChild;\n\t            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n\t                text = onlyChild[0];\n\t            }\n\t        }\n\t        if (text === undefined) {\n\t            children = [];\n\t            for (; childIndex < argsLength; childIndex++) {\n\t                var child = arguments[childIndex];\n\t                if (child === null || child === undefined) {\n\t                    continue;\n\t                } else if (Array.isArray(child)) {\n\t                    appendChildren(selector, child, children);\n\t                } else if (child.hasOwnProperty('vnodeSelector')) {\n\t                    children.push(child);\n\t                } else {\n\t                    children.push(toTextVNode(child));\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            vnodeSelector: selector,\n\t            properties: properties,\n\t            children: children,\n\t            text: text === '' ? undefined : text,\n\t            domNode: null\n\t        };\n\t    };\n\t    /**\n\t * Contains simple low-level utility functions to manipulate the real DOM.\n\t */\n\t    exports.dom = {\n\t        /**\n\t     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n\t     * its [[Projection.domNode|domNode]] property.\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection.\n\t     * @returns The [[Projection]] which also contains the DOM Node that was created.\n\t     */\n\t        create: function (vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param parentNode - The parent node for the new childNode.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        append: function (parentNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, parentNode, undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Inserts a new DOM node which is generated from a [[VNode]].\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param beforeNode - The node that the DOM Node is inserted before.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n\t     * NOTE: [[VNode]] objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        insertBefore: function (beforeNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n\t     * This means that the virtual DOM and the real DOM will have one overlapping element.\n\t     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n\t     * may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        merge: function (element, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            vnode.domNode = element;\n\t            initPropertiesAndChildren(element, vnode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        }\n\t    };\n\t    /**\n\t * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n\t * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n\t * For more information, see [[CalculationCache]].\n\t *\n\t * @param <Result> The type of the value that is cached.\n\t */\n\t    exports.createCache = function () {\n\t        var cachedInputs = undefined;\n\t        var cachedOutcome = undefined;\n\t        var result = {\n\t            invalidate: function () {\n\t                cachedOutcome = undefined;\n\t                cachedInputs = undefined;\n\t            },\n\t            result: function (inputs, calculation) {\n\t                if (cachedInputs) {\n\t                    for (var i = 0; i < inputs.length; i++) {\n\t                        if (cachedInputs[i] !== inputs[i]) {\n\t                            cachedOutcome = undefined;\n\t                        }\n\t                    }\n\t                }\n\t                if (!cachedOutcome) {\n\t                    cachedOutcome = calculation();\n\t                    cachedInputs = inputs;\n\t                }\n\t                return cachedOutcome;\n\t            }\n\t        };\n\t        return result;\n\t    };\n\t    /**\n\t * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n\t * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n\t *\n\t * @param <Source>       The type of source items. A database-record for instance.\n\t * @param <Target>       The type of target items. A [[Component]] for instance.\n\t * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n\t * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n\t *                       to the `callback` argument in `Array.map(callback)`.\n\t * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n\t */\n\t    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n\t        var keys = [];\n\t        var results = [];\n\t        return {\n\t            results: results,\n\t            map: function (newSources) {\n\t                var newKeys = newSources.map(getSourceKey);\n\t                var oldTargets = results.slice();\n\t                var oldIndex = 0;\n\t                for (var i = 0; i < newSources.length; i++) {\n\t                    var source = newSources[i];\n\t                    var sourceKey = newKeys[i];\n\t                    if (sourceKey === keys[oldIndex]) {\n\t                        results[i] = oldTargets[oldIndex];\n\t                        updateResult(source, oldTargets[oldIndex], i);\n\t                        oldIndex++;\n\t                    } else {\n\t                        var found = false;\n\t                        for (var j = 1; j < keys.length + 1; j++) {\n\t                            var searchIndex = (oldIndex + j) % keys.length;\n\t                            if (keys[searchIndex] === sourceKey) {\n\t                                results[i] = oldTargets[searchIndex];\n\t                                updateResult(newSources[i], oldTargets[searchIndex], i);\n\t                                oldIndex = searchIndex + 1;\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                        if (!found) {\n\t                            results[i] = createResult(source, i);\n\t                        }\n\t                    }\n\t                }\n\t                results.length = newSources.length;\n\t                keys = newKeys;\n\t            }\n\t        };\n\t    };\n\t    /**\n\t * Creates a [[Projector]] instance using the provided projectionOptions.\n\t *\n\t * For more information, see [[Projector]].\n\t *\n\t * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n\t */\n\t    exports.createProjector = function (projectorOptions) {\n\t        var projector;\n\t        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n\t        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n\t            return function () {\n\t                // intercept function calls (event handlers) to do a render afterwards.\n\t                projector.scheduleRender();\n\t                return eventHandler.apply(properties.bind || this, arguments);\n\t            };\n\t        };\n\t        var renderCompleted = true;\n\t        var scheduled;\n\t        var stopped = false;\n\t        var projections = [];\n\t        var renderFunctions = [];\n\t        // matches the projections array\n\t        var doRender = function () {\n\t            scheduled = undefined;\n\t            if (!renderCompleted) {\n\t                return;    // The last render threw an error, it should be logged in the browser console.\n\t            }\n\t            renderCompleted = false;\n\t            for (var i = 0; i < projections.length; i++) {\n\t                var updatedVnode = renderFunctions[i]();\n\t                projections[i].update(updatedVnode);\n\t            }\n\t            renderCompleted = true;\n\t        };\n\t        projector = {\n\t            renderNow: doRender,\n\t            scheduleRender: function () {\n\t                if (!scheduled && !stopped) {\n\t                    scheduled = requestAnimationFrame(doRender);\n\t                }\n\t            },\n\t            stop: function () {\n\t                if (scheduled) {\n\t                    cancelAnimationFrame(scheduled);\n\t                    scheduled = undefined;\n\t                }\n\t                stopped = true;\n\t            },\n\t            resume: function () {\n\t                stopped = false;\n\t                renderCompleted = true;\n\t                projector.scheduleRender();\n\t            },\n\t            append: function (parentNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            insertBefore: function (beforeNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            merge: function (domNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            replace: function (domNode, renderMaquetteFunction) {\n\t                var vnode = renderMaquetteFunction();\n\t                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n\t                domNode.parentNode.removeChild(domNode);\n\t                projections.push(createProjection(vnode, projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            detach: function (renderMaquetteFunction) {\n\t                for (var i = 0; i < renderFunctions.length; i++) {\n\t                    if (renderFunctions[i] === renderMaquetteFunction) {\n\t                        renderFunctions.splice(i, 1);\n\t                        return projections.splice(i, 1)[0];\n\t                    }\n\t                }\n\t                throw new Error('renderMaquetteFunction was not found');\n\t            }\n\t        };\n\t        return projector;\n\t    };\n\t}));\n\t//# sourceMappingURL=maquette.js.map\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar Promise_1 = __webpack_require__(41);\n\tvar Map_1 = __webpack_require__(38);\n\tvar FactoryRegistry = (function () {\n\t    function FactoryRegistry() {\n\t        this.registry = new Map_1.default();\n\t    }\n\t    FactoryRegistry.prototype.has = function (factoryLabel) {\n\t        return this.registry.has(factoryLabel);\n\t    };\n\t    FactoryRegistry.prototype.define = function (factoryLabel, registryItem) {\n\t        if (this.registry.has(factoryLabel)) {\n\t            throw new Error(\"factory has already been registered for '\" + factoryLabel + \"'\");\n\t        }\n\t        this.registry.set(factoryLabel, registryItem);\n\t    };\n\t    FactoryRegistry.prototype.get = function (factoryLabel) {\n\t        var _this = this;\n\t        if (!this.has(factoryLabel)) {\n\t            return null;\n\t        }\n\t        var item = this.registry.get(factoryLabel);\n\t        if (compose_1.isComposeFactory(item) || item instanceof Promise_1.default) {\n\t            return item;\n\t        }\n\t        var promise = item();\n\t        this.registry.set(factoryLabel, promise);\n\t        return promise.then(function (factory) {\n\t            _this.registry.set(factoryLabel, factory);\n\t            return factory;\n\t        }, function (error) {\n\t            throw error;\n\t        });\n\t    };\n\t    return FactoryRegistry;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = FactoryRegistry;\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar maquette_1 = __webpack_require__(76);\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar global_1 = __webpack_require__(19);\n\tvar Promise_1 = __webpack_require__(41);\n\t/**\n\t * Represents the state of the projector\n\t */\n\t(function (ProjectorState) {\n\t    ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n\t    ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n\t})(exports.ProjectorState || (exports.ProjectorState = {}));\n\tvar ProjectorState = exports.ProjectorState;\n\t/**\n\t * Attach type for the projector\n\t */\n\t(function (AttachType) {\n\t    AttachType[AttachType[\"Append\"] = 1] = \"Append\";\n\t    AttachType[AttachType[\"Merge\"] = 2] = \"Merge\";\n\t    AttachType[AttachType[\"Replace\"] = 3] = \"Replace\";\n\t})(exports.AttachType || (exports.AttachType = {}));\n\tvar AttachType = exports.AttachType;\n\t/**\n\t * Private state map keyed by instance.\n\t */\n\tvar projectorDataMap = new WeakMap_1.default();\n\t/**\n\t * Schedules a render.\n\t */\n\tfunction scheduleRender(event) {\n\t    var projector = event.target;\n\t    var projectorData = projectorDataMap.get(projector);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        projector.emit({\n\t            type: 'render:scheduled',\n\t            target: projector\n\t        });\n\t        projectorData.projector.scheduleRender();\n\t    }\n\t}\n\tfunction attach(instance, _a) {\n\t    var type = _a.type;\n\t    var projectorData = projectorDataMap.get(instance);\n\t    var render = instance.render.bind(instance);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        return projectorData.attachPromise || Promise_1.default.resolve({});\n\t    }\n\t    projectorData.state = ProjectorState.Attached;\n\t    projectorData.attachHandle = instance.own({\n\t        destroy: function () {\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                projectorData.projector.stop();\n\t                projectorData.projector.detach(render);\n\t                projectorData.state = ProjectorState.Detached;\n\t            }\n\t            projectorData.attachHandle = { destroy: function () { } };\n\t        }\n\t    });\n\t    projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n\t        projectorData.afterCreate = function () {\n\t            instance.emit({\n\t                type: 'projector:attached',\n\t                target: instance\n\t            });\n\t            resolve(projectorData.attachHandle);\n\t        };\n\t    });\n\t    switch (type) {\n\t        case AttachType.Append:\n\t            projectorData.projector.append(projectorData.root, render);\n\t            break;\n\t        case AttachType.Merge:\n\t            projectorData.projector.merge(projectorData.root, render);\n\t            break;\n\t        case AttachType.Replace:\n\t            projectorData.projector.replace(projectorData.root, render);\n\t            break;\n\t    }\n\t    return projectorData.attachPromise;\n\t}\n\t/**\n\t * Projector Factory\n\t */\n\tvar createProjector = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        append: function () {\n\t            var options = {\n\t                type: AttachType.Append\n\t            };\n\t            return attach(this, options);\n\t        },\n\t        merge: function () {\n\t            var options = {\n\t                type: AttachType.Merge\n\t            };\n\t            return attach(this, options);\n\t        },\n\t        replace: function () {\n\t            var options = {\n\t                type: AttachType.Replace\n\t            };\n\t            return attach(this, options);\n\t        },\n\t        set root(root) {\n\t            var projectorData = projectorDataMap.get(this);\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                throw new Error('Projector already attached, cannot change root element');\n\t            }\n\t            projectorData.root = root;\n\t        },\n\t        get root() {\n\t            var projectorData = projectorDataMap.get(this);\n\t            return projectorData && projectorData.root;\n\t        },\n\t        get projector() {\n\t            return projectorDataMap.get(this).projector;\n\t        },\n\t        get projectorState() {\n\t            var projectorData = projectorDataMap.get(this);\n\t            return projectorData && projectorData.state;\n\t        }\n\t    },\n\t    aspectAdvice: {\n\t        after: {\n\t            render: function (result) {\n\t                if (typeof result === 'string' || result === null) {\n\t                    throw new Error('Must provide a VNode at the root of a projector');\n\t                }\n\t                return result;\n\t            }\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var _a = options.root, root = _a === void 0 ? document.body : _a, _b = options.cssTransitions, cssTransitions = _b === void 0 ? false : _b;\n\t        var maquetteProjectorOptions = {};\n\t        if (cssTransitions) {\n\t            if (global_1.default.cssTransitions) {\n\t                maquetteProjectorOptions.transitions = global_1.default.cssTransitions;\n\t            }\n\t            else {\n\t                throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t            }\n\t        }\n\t        instance.own(instance.on('widget:children', instance.invalidate));\n\t        instance.own(instance.on('invalidated', scheduleRender));\n\t        var projector = maquette_1.createProjector(maquetteProjectorOptions);\n\t        projectorDataMap.set(instance, {\n\t            projector: projector,\n\t            root: root,\n\t            state: ProjectorState.Detached\n\t        });\n\t    }\n\t})\n\t    .mixin({\n\t    mixin: {\n\t        nodeAttributes: [\n\t            function () {\n\t                var afterCreate = projectorDataMap.get(this).afterCreate;\n\t                return { afterCreate: afterCreate };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createProjector;\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar createStateful_1 = __webpack_require__(80);\n\tvar lang_1 = __webpack_require__(24);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar Map_1 = __webpack_require__(38);\n\tvar d_1 = __webpack_require__(75);\n\tvar FactoryRegistry_1 = __webpack_require__(77);\n\tvar createVNodeEvented_1 = __webpack_require__(84);\n\t/**\n\t * Internal state map for widget instances\n\t */\n\tvar widgetInternalStateMap = new WeakMap_1.default();\n\t/**\n\t * The counter for generating a unique ID\n\t */\n\tvar widgetCount = 0;\n\tfunction generateID(instance) {\n\t    var id = \"widget-\" + ++widgetCount;\n\t    instance.setState({ id: id });\n\t    return id;\n\t}\n\tfunction isWNode(child) {\n\t    return Boolean(child && child.factory !== undefined);\n\t}\n\tfunction getFromRegistry(instance, factoryLabel) {\n\t    if (instance.registry.has(factoryLabel)) {\n\t        return instance.registry.get(factoryLabel);\n\t    }\n\t    return d_1.registry.get(factoryLabel);\n\t}\n\tfunction dNodeToVNode(instance, dNode) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    if (typeof dNode === 'string' || dNode === null) {\n\t        return dNode;\n\t    }\n\t    if (isWNode(dNode)) {\n\t        var children = dNode.children, _a = dNode.options, id = _a.id, state = _a.state;\n\t        var factory = dNode.factory;\n\t        var child = void 0;\n\t        if (typeof factory === 'string') {\n\t            var item = getFromRegistry(instance, factory);\n\t            if (compose_1.isComposeFactory(item)) {\n\t                factory = item;\n\t            }\n\t            else {\n\t                if (item && !internalState.initializedFactoryMap.has(factory)) {\n\t                    var promise = item.then(function (factory) {\n\t                        instance.invalidate();\n\t                        return factory;\n\t                    });\n\t                    internalState.initializedFactoryMap.set(factory, promise);\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t        var childrenMapKey = id || factory;\n\t        var cachedChild = internalState.historicChildrenMap.get(childrenMapKey);\n\t        if (cachedChild) {\n\t            child = cachedChild;\n\t            if (state) {\n\t                child.setState(state);\n\t            }\n\t        }\n\t        else {\n\t            child = factory(dNode.options);\n\t            child.own(child.on('invalidated', function () {\n\t                instance.invalidate();\n\t            }));\n\t            internalState.historicChildrenMap.set(childrenMapKey, child);\n\t            instance.own(child);\n\t        }\n\t        if (!id && internalState.currentChildrenMap.has(factory)) {\n\t            var errorMsg = 'must provide unique keys when using the same widget factory multiple times';\n\t            console.error(errorMsg);\n\t            instance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n\t        }\n\t        child.children = children;\n\t        internalState.currentChildrenMap.set(childrenMapKey, child);\n\t        return child.render();\n\t    }\n\t    dNode.children = dNode.children\n\t        .filter(function (child) { return child !== null; })\n\t        .map(function (child) {\n\t        return dNodeToVNode(instance, child);\n\t    });\n\t    return dNode.render({ bind: instance });\n\t}\n\tfunction manageDetachedChildren(instance) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    internalState.historicChildrenMap.forEach(function (child, key) {\n\t        if (!internalState.currentChildrenMap.has(key)) {\n\t            internalState.historicChildrenMap.delete(key);\n\t            child.destroy();\n\t        }\n\t    });\n\t    internalState.currentChildrenMap.clear();\n\t}\n\tfunction formatTagNameAndClasses(tagName, classes) {\n\t    if (classes.length) {\n\t        return tagName + \".\" + classes.join('.');\n\t    }\n\t    return tagName;\n\t}\n\tvar createWidget = createStateful_1.default\n\t    .mixin(createVNodeEvented_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: [],\n\t        getNode: function () {\n\t            var tag = formatTagNameAndClasses(this.tagName, this.classes);\n\t            return d_1.v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n\t        },\n\t        set children(children) {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.children = children;\n\t            this.emit({\n\t                type: 'widget:children',\n\t                target: this\n\t            });\n\t        },\n\t        get children() {\n\t            return widgetInternalStateMap.get(this).children;\n\t        },\n\t        getChildrenNodes: function () {\n\t            return this.children;\n\t        },\n\t        getNodeAttributes: function (overrides) {\n\t            var _this = this;\n\t            var props = {};\n\t            this.nodeAttributes.forEach(function (fn) {\n\t                var newProps = fn.call(_this);\n\t                if (newProps) {\n\t                    lang_1.assign(props, newProps);\n\t                }\n\t            });\n\t            return props;\n\t        },\n\t        invalidate: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.dirty = true;\n\t            this.emit({\n\t                type: 'invalidated',\n\t                target: this\n\t            });\n\t        },\n\t        get id() {\n\t            var id = widgetInternalStateMap.get(this).id;\n\t            return id || (this.state && this.state.id) || generateID(this);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n\t                var _a = this.state.styles, styles = _a === void 0 ? {} : _a;\n\t                var classes = {};\n\t                var internalState = widgetInternalStateMap.get(this);\n\t                internalState.widgetClasses.forEach(function (c) { return classes[c] = false; });\n\t                if (this.state && this.state.classes) {\n\t                    this.state.classes.forEach(function (c) { return classes[c] = true; });\n\t                    internalState.widgetClasses = this.state.classes;\n\t                }\n\t                return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n\t            }\n\t        ],\n\t        render: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            if (internalState.dirty || !internalState.cachedVNode) {\n\t                var widget = dNodeToVNode(this, this.getNode());\n\t                manageDetachedChildren(this);\n\t                if (widget) {\n\t                    internalState.cachedVNode = widget;\n\t                }\n\t                internalState.dirty = false;\n\t                return widget;\n\t            }\n\t            return internalState.cachedVNode;\n\t        },\n\t        get registry() {\n\t            return widgetInternalStateMap.get(this).factoryRegistry;\n\t        },\n\t        tagName: 'div'\n\t    },\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var id = options.id, tagName = options.tagName;\n\t        instance.tagName = tagName || instance.tagName;\n\t        widgetInternalStateMap.set(instance, {\n\t            id: id,\n\t            dirty: true,\n\t            widgetClasses: [],\n\t            factoryRegistry: new FactoryRegistry_1.default(),\n\t            initializedFactoryMap: new Map_1.default(),\n\t            historicChildrenMap: new Map_1.default(),\n\t            currentChildrenMap: new Map_1.default(),\n\t            children: []\n\t        });\n\t        instance.own(instance.on('state:changed', function () {\n\t            instance.invalidate();\n\t        }));\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createWidget;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(24);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar createEvented_1 = __webpack_require__(81);\n\tvar createCancelableEvent_1 = __webpack_require__(83);\n\t/**\n\t * A weak map of stateful instances to their obseved state references\n\t */\n\tvar observedStateMap = new WeakMap_1.default();\n\t/**\n\t * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n\t * cancelled.\n\t *\n\t * @param stateful The `Stateful` object to unobserve\n\t */\n\tfunction completeStatefulState(stateful) {\n\t    var observedState = observedStateMap.get(stateful);\n\t    if (observedState) {\n\t        observedState.handle.destroy();\n\t        var statecomplete = createCancelableEvent_1.default({\n\t            type: 'state:completed',\n\t            target: stateful\n\t        });\n\t        stateful.emit(statecomplete);\n\t        if (!statecomplete.defaultPrevented) {\n\t            stateful.destroy();\n\t        }\n\t    }\n\t}\n\t/**\n\t * Internal function that actually applies the state to the Stateful's state and\n\t * emits the `statechange` event.\n\t *\n\t * @param stateful The Stateful instance\n\t * @param state The State to be set\n\t */\n\tfunction setStatefulState(target, state) {\n\t    var previousState = stateWeakMap.get(target);\n\t    if (!previousState) {\n\t        throw new Error('Unable to set destroyed state');\n\t    }\n\t    var type = 'state:changed';\n\t    state = lang_1.deepAssign(previousState, state);\n\t    var eventObject = {\n\t        type: type,\n\t        state: state,\n\t        target: target\n\t    };\n\t    target.emit(eventObject);\n\t}\n\t/**\n\t * A weak map that contains the stateful's state\n\t */\n\tvar stateWeakMap = new WeakMap_1.default();\n\t/**\n\t * Create an instance of a stateful object\n\t */\n\tvar createStateful = createEvented_1.default\n\t    .mixin({\n\t    className: 'Stateful',\n\t    mixin: {\n\t        get stateFrom() {\n\t            var observedState = observedStateMap.get(this);\n\t            if (observedState) {\n\t                return observedState.observable;\n\t            }\n\t        },\n\t        get state() {\n\t            return stateWeakMap.get(this);\n\t        },\n\t        setState: function (value) {\n\t            var observedState = observedStateMap.get(this);\n\t            if (observedState) {\n\t                observedState.observable.patch(value, { id: observedState.id });\n\t            }\n\t            else {\n\t                setStatefulState(this, value);\n\t            }\n\t        },\n\t        observeState: function (id, observable) {\n\t            var observedState = observedStateMap.get(this);\n\t            if (observedState) {\n\t                if (observedState.id === id && observedState.observable === observable) {\n\t                    return observedState.handle;\n\t                }\n\t                throw new Error(\"Already observing state with ID '\" + observedState.id + \"'\");\n\t            }\n\t            var stateful = this;\n\t            var handle = {\n\t                destroy: function () {\n\t                    var observedState = observedStateMap.get(stateful);\n\t                    if (observedState) {\n\t                        observedState.subscription.unsubscribe();\n\t                        observedStateMap.delete(stateful);\n\t                    }\n\t                }\n\t            };\n\t            var subscription = observable\n\t                .observe(id)\n\t                .subscribe(function (state) {\n\t                setStatefulState(stateful, state);\n\t            }, function (err) {\n\t                throw err;\n\t            }, function () {\n\t                completeStatefulState(stateful);\n\t            });\n\t            observedStateMap.set(stateful, { id: id, observable: observable, subscription: subscription, handle: handle });\n\t            return handle;\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        stateWeakMap.set(instance, Object.create(null));\n\t        instance.own({\n\t            destroy: function () {\n\t                stateWeakMap.delete(instance);\n\t            }\n\t        });\n\t        if (options) {\n\t            var id = options.id, stateFrom = options.stateFrom, state = options.state;\n\t            if (typeof id !== 'undefined' && stateFrom) {\n\t                instance.own(instance.observeState(id, stateFrom));\n\t            }\n\t            else if (stateFrom) {\n\t                throw new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t            }\n\t            if (state) {\n\t                instance.setState(state);\n\t            }\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStateful;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar aspect_1 = __webpack_require__(37);\n\tvar Map_1 = __webpack_require__(38);\n\tvar WeakMap_1 = __webpack_require__(31);\n\tvar createDestroyable_1 = __webpack_require__(82);\n\t/**\n\t * A weak map that contains a map of the listeners for an `Evented`\n\t */\n\tvar listenersMap = new WeakMap_1.default();\n\t/**\n\t * A guard which determines if the value is `Actionable`\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isActionable(value) {\n\t    return Boolean(value && typeof value.do === 'function');\n\t}\n\t/**\n\t * An internal function that always returns an EventedCallback\n\t *\n\t * @param listener Either a `EventedCallback` or an `Actionable`\n\t */\n\tfunction resolveListener(listener) {\n\t    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n\t}\n\texports.resolveListener = resolveListener;\n\t/**\n\t * Internal function to convert an array of handles to a single handle\n\t *\n\t * @param handles The array of handles to convert into a signle handle\n\t * @return The single handle\n\t */\n\tfunction handlesArraytoHandle(handles) {\n\t    return {\n\t        destroy: function () {\n\t            handles.forEach(function (handle) { return handle.destroy(); });\n\t        }\n\t    };\n\t}\n\t/**\n\t * Creates a new instance of an `Evented`\n\t */\n\tvar createEvented = createDestroyable_1.default\n\t    .mixin({\n\t    className: 'Evented',\n\t    mixin: {\n\t        emit: function (event) {\n\t            var method = listenersMap.get(this).get(event.type);\n\t            if (method) {\n\t                method.call(this, event);\n\t            }\n\t        },\n\t        on: function () {\n\t            var _this = this;\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            var listenerMap = listenersMap.get(this);\n\t            if (args.length === 2) {\n\t                var _a = args, type_1 = _a[0], listeners = _a[1];\n\t                if (Array.isArray(listeners)) {\n\t                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n\t                    return handlesArraytoHandle(handles);\n\t                }\n\t                else {\n\t                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n\t                }\n\t            }\n\t            else if (args.length === 1) {\n\t                var listenerMapArg_1 = args[0];\n\t                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n\t                return handlesArraytoHandle(handles);\n\t            }\n\t            else {\n\t                throw new TypeError('Invalid arguments');\n\t            }\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        listenersMap.set(instance, new Map_1.default());\n\t        if (options && options.listeners) {\n\t            instance.own(instance.on(options.listeners));\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createEvented;\n\n\n/***/ },\n/* 82 */\n40,\n/* 83 */\n53,\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar aspect_1 = __webpack_require__(37);\n\tvar lang_1 = __webpack_require__(24);\n\tvar createEvented_1 = __webpack_require__(81);\n\tvar Set_1 = __webpack_require__(85);\n\tvar vnodeEvents = new Set_1.default([\n\t    'touchcancel',\n\t    'touchend',\n\t    'touchmove',\n\t    'touchstart',\n\t    'blur',\n\t    'change',\n\t    'click',\n\t    'dblclick',\n\t    'focus',\n\t    'input',\n\t    'keydown',\n\t    'keypress',\n\t    'keyup',\n\t    'load',\n\t    'mousedown',\n\t    'mouseenter',\n\t    'mouseleave',\n\t    'mousemove',\n\t    'mouseout',\n\t    'mouseover',\n\t    'mouseup',\n\t    'mousewheel',\n\t    'scroll',\n\t    'submit'\n\t]);\n\t/**\n\t * Internal function to convert an array of handles to a single array\n\t *\n\t * TODO: This is used in a couple places, maybe should migrate to a better place\n\t *\n\t * @params handles An array of handles\n\t */\n\tfunction handlesArraytoHandle(handles) {\n\t    return {\n\t        destroy: function () {\n\t            handles.forEach(function (handle) { return handle.destroy(); });\n\t        }\n\t    };\n\t}\n\tvar UNINITIALIZED_LISTENERS = Object.freeze({});\n\tvar createVNodeEvented = createEvented_1.default\n\t    .mixin({\n\t    mixin: {\n\t        listeners: UNINITIALIZED_LISTENERS,\n\t        nodeAttributes: [\n\t            function () {\n\t                return lang_1.assign({}, this.listeners);\n\t            }\n\t        ]\n\t    },\n\t    aspectAdvice: {\n\t        around: {\n\t            on: function (origFn) {\n\t                return function () {\n\t                    var _this = this;\n\t                    var args = [];\n\t                    for (var _i = 0; _i < arguments.length; _i++) {\n\t                        args[_i - 0] = arguments[_i];\n\t                    }\n\t                    if (args.length === 2) {\n\t                        /* During initialization, sometimes the initialize functions occur out of order,\n\t                        * and Evented's initialize function could be called before this mixins, therefore\n\t                        * leaving this.listeners with an uninitiliazed value, therefore it is better to\n\t                        * determine if the value is unitialized here, ensuring that this.listeners is\n\t                        * always valid.\n\t                        */\n\t                        if (this.listeners === UNINITIALIZED_LISTENERS) {\n\t                            this.listeners = {};\n\t                        }\n\t                        var type_1;\n\t                        var listeners = void 0;\n\t                        type_1 = args[0], listeners = args[1];\n\t                        if (Array.isArray(listeners)) {\n\t                            var handles = listeners.map(function (listener) { return vnodeEvents.has(type_1) ?\n\t                                aspect_1.on(_this.listeners, 'on' + type_1, createEvented_1.resolveListener(listener)) :\n\t                                origFn.call(_this, type_1, listener); });\n\t                            return handlesArraytoHandle(handles);\n\t                        }\n\t                        else {\n\t                            return vnodeEvents.has(type_1) ?\n\t                                aspect_1.on(this.listeners, 'on' + type_1, createEvented_1.resolveListener(listeners)) :\n\t                                origFn.call(this, type_1, listeners);\n\t                        }\n\t                    }\n\t                    else if (args.length === 1) {\n\t                        var listenerMapArg_1 = args[0];\n\t                        return handlesArraytoHandle(Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); }));\n\t                    }\n\t                    else {\n\t                        throw new TypeError('Invalid arguments');\n\t                    }\n\t                };\n\t            },\n\t            emit: function (origFn) {\n\t                return function (event) {\n\t                    if (vnodeEvents.has(event.type)) {\n\t                        if (this.listeners === null) {\n\t                            this.listeners = {};\n\t                        }\n\t                        var method = this.listeners['on' + event.type];\n\t                        if (method) {\n\t                            method.call(this, event);\n\t                        }\n\t                    }\n\t                    else {\n\t                        origFn.call(this, event);\n\t                    }\n\t                };\n\t            }\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createVNodeEvented;\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(32);\n\tvar global_1 = __webpack_require__(21);\n\tvar iterator_1 = __webpack_require__(27);\n\t__webpack_require__(29);\n\tvar Shim;\n\t(function (Shim) {\n\t    var Set = (function () {\n\t        function Set(iterable) {\n\t            var _this = this;\n\t            this._setData = [];\n\t            this[Symbol.toStringTag] = 'Set';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n\t            }\n\t        }\n\t        ;\n\t        Set.prototype.add = function (value) {\n\t            if (this.has(value)) {\n\t                return this;\n\t            }\n\t            this._setData.push(value);\n\t            return this;\n\t        };\n\t        ;\n\t        Set.prototype.clear = function () {\n\t            this._setData.length = 0;\n\t        };\n\t        ;\n\t        Set.prototype.delete = function (value) {\n\t            var idx = this._setData.indexOf(value);\n\t            if (idx === -1) {\n\t                return false;\n\t            }\n\t            this._setData.splice(idx, 1);\n\t            return true;\n\t        };\n\t        ;\n\t        Set.prototype.entries = function () {\n\t            return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n\t        };\n\t        ;\n\t        Set.prototype.forEach = function (callbackfn, thisArg) {\n\t            var iterator = this.values();\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callbackfn.call(thisArg, result.value, result.value, this);\n\t                result = iterator.next();\n\t            }\n\t        };\n\t        ;\n\t        Set.prototype.has = function (value) {\n\t            return this._setData.indexOf(value) > -1;\n\t        };\n\t        ;\n\t        Set.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Object.defineProperty(Set.prototype, \"size\", {\n\t            get: function () {\n\t                return this._setData.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Set.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Set.prototype[Symbol.iterator] = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        return Set;\n\t    }());\n\t    Shim.Set = Set;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Set = (function () {\n\t    /* istanbul ignore next */\n\t    function Set(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Set';\n\t    }\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    Object.defineProperty(Set.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    Set = __decorate([\n\t        decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n\t    ], Set);\n\t    return Set;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Set;\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createSearchInput_1 = __webpack_require__(87);\n\tvar counter = 0;\n\tfunction listItem(childNode, key) {\n\t    var options = key ? { key: key } : {};\n\t    return d_1.v('li', options, [childNode]);\n\t}\n\tfunction createNavBarLink(_a) {\n\t    var innerHTML = _a.text, href = _a.href;\n\t    return listItem(d_1.v('a', { key: counter++, href: href, innerHTML: innerHTML }), innerHTML);\n\t}\n\tvar createNavbar = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'header',\n\t        classes: ['navbar'],\n\t        getChildrenNodes: function () {\n\t            var state = this.state;\n\t            var isReady = Object.keys(state).length > 0;\n\t            var homeLink = listItem(d_1.v('a', { href: '#' }, [\n\t                d_1.v('img', { src: 'images/navbar-app-icon.png' })\n\t            ]));\n\t            var sectionLinks = isReady ? this.state.sections.map(createNavBarLink) : [d_1.v('li', { key: 'dummy' })];\n\t            var searchAction = listItem(d_1.w(createSearchInput_1.default, {}));\n\t            var favouriteAction = listItem(d_1.v('i.fa.fa-2x.fa-heart-o'));\n\t            var pageLinks = d_1.v('ul.inline-list', {}, [homeLink].concat(sectionLinks));\n\t            var actionLinks = d_1.v('ul.inline-list.pull-right', {}, [searchAction, favouriteAction]);\n\t            return [pageLinks, actionLinks];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createNavbar;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createSearchInput = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        getChildrenNodes: function () {\n\t            var input = d_1.v('input', { type: 'search' });\n\t            var icon = d_1.v('i.fa.fa-2x.fa-search');\n\t            return [input, icon];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createSearchInput;\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar d_1 = __webpack_require__(75);\n\tvar createHomePage = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'pageHolder', 'home'],\n\t        getChildrenNodes: function () {\n\t            var mmLogo = d_1.v('img', { src: './images/mm_logo.png' });\n\t            var jumbotron = d_1.v('div.jumbotron', {}, [mmLogo]);\n\t            return [jumbotron];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createHomePage;\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(16);\n\tvar createStateful_1 = __webpack_require__(80);\n\tvar createCssTransitionMixin = compose_1.default({\n\t    nodeAttributes: [\n\t        function () {\n\t            var _a = this.state, enterAnimation = _a.enterAnimation, exitAnimation = _a.exitAnimation;\n\t            return { enterAnimation: enterAnimation, exitAnimation: exitAnimation };\n\t        }\n\t    ]\n\t})\n\t    .mixin(createStateful_1.default);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCssTransitionMixin;\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar createCardDescription_1 = __webpack_require__(91);\n\tvar createCardNavBar_1 = __webpack_require__(92);\n\tvar createSeenWith_1 = __webpack_require__(94);\n\tvar d_1 = __webpack_require__(75);\n\tvar lang_1 = __webpack_require__(24);\n\tvar createCardDetailsPage = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'pageHolder', 'cardDetails'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state, cards = _a.cards, cardDescription = _a.cardDescription, seenWith = _a.seenWith;\n\t            var cardNavBar = d_1.w(createCardNavBar_1.default, { state: { cards: cards } });\n\t            var descriptionState = lang_1.assign({\n\t                enterAnimation: 'slideInRight',\n\t                exitAnimation: 'slideOutLeft'\n\t            }, cardDescription);\n\t            var cardDescriptionView = cardDescription ? d_1.w(createCardDescription_1.default, {\n\t                id: \"card-details-description-\" + cardDescription.id,\n\t                state: descriptionState\n\t            }) : null;\n\t            var jumbotron = d_1.v('div.jumbotron', {}, [cardDescriptionView]);\n\t            var seenWithView = d_1.w(createSeenWith_1.default, { state: { cards: seenWith } });\n\t            return [cardNavBar, jumbotron, seenWithView];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardDetailsPage;\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tfunction createButtonLink(_a) {\n\t    var iconClass = _a.iconClass, href = _a.href, innerHTML = _a.text;\n\t    var icon = d_1.v(\"i.fa.\" + iconClass);\n\t    var buttonText = innerHTML ? d_1.v('span', { innerHTML: innerHTML }) : null;\n\t    return d_1.v('a.button', { href: href }, [icon, buttonText]);\n\t}\n\tvar shareButtonConfig = [\n\t    { href: '', iconClass: 'fa-heart-o', text: 'Add to favourites' },\n\t    { href: 'http://www.twitter.com', iconClass: 'fa-twitter' },\n\t    { href: 'https://facebook.com', iconClass: 'fa-facebook' }\n\t];\n\tvar createCardDescription = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'cardDescription'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state, imageClass = _a.imageClass, name = _a.name, tagline = _a.tagline, description = _a.description, favouriteCount = _a.favouriteCount;\n\t            var cardImage = d_1.v(\"div.cardImage.card-sprite-large.\" + imageClass);\n\t            var cardName = d_1.v('h1', { innerHTML: name });\n\t            var cardTagline = d_1.v('strong.tagline', { innerHTML: tagline });\n\t            var cardDescription = d_1.v('p', { innerHTML: description });\n\t            var cardFavouriteCount = d_1.v('span', { innerHTML: \"Favourited: \" + favouriteCount });\n\t            var shareButtons = d_1.v('div.buttonHolder', {}, shareButtonConfig.map(createButtonLink));\n\t            return [\n\t                cardImage,\n\t                d_1.v('article', {}, [\n\t                    cardName,\n\t                    cardTagline,\n\t                    cardDescription,\n\t                    cardFavouriteCount,\n\t                    shareButtons\n\t                ])\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardDescription;\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar createCard_1 = __webpack_require__(93);\n\tvar createCardNavBar = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'cardNavBar'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state.cards, cards = _a === void 0 ? [] : _a;\n\t            var cardNodes = cards.map(function (state) {\n\t                return d_1.w(createCard_1.default, { id: \"card-details-nav-bar-\" + state.id, state: state });\n\t            });\n\t            return cardNodes;\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardNavBar;\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCard = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'a',\n\t        classes: ['milestoneCard'],\n\t        nodeAttributes: [\n\t            function () {\n\t                return {\n\t                    href: \"#/cards/\" + this.state.id\n\t                };\n\t            }\n\t        ],\n\t        getChildrenNodes: function () {\n\t            var baseImageClass = this.state.large ? 'card-sprite-large' : 'card-sprite-small';\n\t            return [d_1.v(\"div.\" + baseImageClass + \".\" + this.state.imageClass)];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCard;\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCard_1 = __webpack_require__(93);\n\tvar lang_1 = __webpack_require__(24);\n\tvar createSeenWith = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        classes: ['seenWith'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state.cards, cards = _a === void 0 ? [] : _a;\n\t            var cardNodes = cards.map(function (card) {\n\t                var state = lang_1.assign({ large: true }, card);\n\t                return d_1.w(createCard_1.default, { id: \"card-details-seen-with-\" + state.id, state: state });\n\t            });\n\t            return [\n\t                d_1.v('h2', { innerHTML: 'last seen with' })\n\t            ].concat(cardNodes);\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createSeenWith;\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar createCardsList_1 = __webpack_require__(96);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCardsPage = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'pageHolder', 'cards'],\n\t        getChildrenNodes: function () {\n\t            var jumbotron = d_1.v('div.jumbotron');\n\t            var cardsList = d_1.w(createCardsList_1.default, { state: this.state });\n\t            return [jumbotron, cardsList];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardsPage;\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCardSummary_1 = __webpack_require__(97);\n\tvar createCardList = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['cardList'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state.cards, cards = _a === void 0 ? [] : _a;\n\t            return cards.map(function (state) {\n\t                return d_1.w(createCardSummary_1.default, { id: \"card-list-summary-\" + state.id, state: state });\n\t            });\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardList;\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar d_1 = __webpack_require__(75);\n\tvar createCard_1 = __webpack_require__(93);\n\tvar createCardSummary = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        classes: ['cardSummary'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state, id = _a.id, imageClass = _a.imageClass, name = _a.name, score = _a.score;\n\t            var cardImage = d_1.w(createCard_1.default, { state: { id: id, imageClass: imageClass, large: true } });\n\t            var cardName = d_1.v('h2', { innerHTML: name });\n\t            var cardPoints = d_1.v('p.points', { innerHTML: \"milestone points: \" + score });\n\t            return [\n\t                cardImage,\n\t                cardName,\n\t                cardPoints\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCardSummary;\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar d_1 = __webpack_require__(75);\n\tvar createGameplayPage = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'pageHolder', 'gameplay'],\n\t        getChildrenNodes: function () {\n\t            var heading = d_1.v('h1', { innerHTML: 'Gameplay' });\n\t            var jumbotron = d_1.v('div.jumbotron', {}, [heading]);\n\t            return [jumbotron];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createGameplayPage;\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(79);\n\tvar createCssTransitionMixin_1 = __webpack_require__(89);\n\tvar d_1 = __webpack_require__(75);\n\tvar createAboutPage = createWidgetBase_1.default\n\t    .mixin(createCssTransitionMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['animated', 'pageHolder', 'about'],\n\t        getChildrenNodes: function () {\n\t            var heading = d_1.v('h1', { innerHTML: 'About' });\n\t            var jumbotron = d_1.v('div.jumbotron', {}, [heading]);\n\t            return [jumbotron];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createAboutPage;\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\t(function (global) {\n\t\n\t  \"use strict\";\n\t\n\t  var browserSpecificTransitionEndEventName = null;\n\t\n\t  var determineBrowserSpecificStyleNames = function (element) {\n\t    if (\"WebkitTransition\" in element.style) {\n\t      browserSpecificTransitionEndEventName = \"webkitTransitionEnd\";\n\t    } else if (\"transition\" in element.style) {\n\t      browserSpecificTransitionEndEventName = \"transitionend\";\n\t    } else if (\"MozTransition\" in element.style) {\n\t      browserSpecificTransitionEndEventName = \"transitionend\";\n\t    } else {\n\t      throw new Error(\"Your browser is not supported\");\n\t    }\n\t  };\n\t\n\t  var init = function (testElement) {\n\t    if (browserSpecificTransitionEndEventName === null) {\n\t      determineBrowserSpecificStyleNames(testElement);\n\t    }\n\t  };\n\t\n\t  var cssTransitions = {\n\t    exit: function (node, properties, exitAnimation, removeNode) {\n\t      init(node);\n\t      var finished = false;\n\t      var transitionEnd = function (evt) {\n\t        if (!finished) {\n\t          finished = true;\n\t          node.removeEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n\t          removeNode();\n\t        }\n\t      };\n\t      node.classList.add(exitAnimation);\n\t      node.addEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n\t      requestAnimationFrame(function () {\n\t        node.classList.add(exitAnimation + \"-active\");\n\t      });\n\t    },\n\t    enter: function (node, properties, enterAnimation) {\n\t      init(node);\n\t      var finished = false;\n\t      var transitionEnd = function (evt) {\n\t        if (!finished) {\n\t          finished = true;\n\t          node.removeEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n\t          node.classList.remove(enterAnimation);\n\t          node.classList.remove(enterAnimation + \"-active\");\n\t        }\n\t      };\n\t      node.classList.add(enterAnimation);\n\t      node.addEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n\t      requestAnimationFrame(function () {\n\t        node.classList.add(enterAnimation + \"-active\");\n\t      });\n\t    }\n\t  };\n\t\n\t  if (global.module !== undefined && global.module.exports) {\n\t    // Node and other CommonJS-like environments that support module.exports\n\t    global.module.exports = cssTransitions;\n\t  } else if (typeof global.define == 'function' && global.define.amd) {\n\t    // AMD / RequireJS\n\t    global.define(function () {\n\t      return cssTransitions;\n\t    });\n\t  }\n\t  if (window) {\n\t    // Browser\n\t    window.cssTransitions = cssTransitions;\n\t  }\n\t\n\t})(this);\n\n\n/***/ }\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// src/main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6cc1f563352f1376ce5c","import router from './routes';\nimport { bindActions as bindCardStoreActions } from './stores/cardStore';\nimport widgetStore from './stores/widgetStore';\nimport createApp from './app';\nimport 'maquette/src/css-transitions';\n\nconst root = document.getElementsByTagName('my-app')[0];\n\nconst app = createApp({\n\tid: 'app',\n\tstateFrom: widgetStore,\n\troot,\n\tcssTransitions: true\n});\n\napp.append()\n\t.then(() => bindCardStoreActions())\n\t.then(() => router.start());\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","import createRoute from 'dojo-routing/createRoute';\nimport createRouter from 'dojo-routing/createRouter';\nimport createHashHistory from 'dojo-routing/history/createHashHistory';\nimport { Request, Context, Parameters } from 'dojo-routing/interfaces';\n\nexport type CardDetailsRouteParameters = Parameters & {\n\tid: string;\n}\n\nimport {\n\tgotoCardDetails as gotoCardDetailsAction,\n\tgotoCards as gotoCardsAction,\n\tgotoHome as gotoHomeAction,\n\tgotoAbout as gotoAboutAction,\n\tgotoGameplay as gotoGameplayAction\n} from './actions/routeActions';\n\nconst cardDetailRoute = createRoute({\n\tpath: 'cards/{id}',\n\texec (request: Request<Context, CardDetailsRouteParameters>) {\n\t\tconst { id } = request.params;\n\t\treturn gotoCardDetailsAction.do({ id });\n\t}\n});\n\nconst cardsRoute = createRoute({\n\tpath: 'cards',\n\texec (request: any) {\n\t\treturn gotoCardsAction.do();\n\t}\n});\n\nconst homeRoute = createRoute({\n\tpath: '',\n\texec (request: any) {\n\t\treturn gotoHomeAction.do();\n\t}\n});\n\nconst aboutRoute = createRoute({\n\tpath: 'about',\n\texec (request: any) {\n\t\treturn gotoAboutAction.do();\n\t}\n});\n\nconst gameplayRoute = createRoute({\n\tpath: 'gameplay',\n\texec (request: any) {\n\t\treturn gotoGameplayAction.do();\n\t}\n});\n\nexport const history = createHashHistory();\n\nconst router = createRouter({ history });\n\nexport default router;\n\nrouter.append([\n\tcardsRoute,\n\tcardDetailRoute,\n\thomeRoute,\n\taboutRoute,\n\tgameplayRoute\n]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/routes.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport UrlSearchParams from 'dojo-core/UrlSearchParams';\nimport { Hash } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Thenable } from 'dojo-shim/interfaces';\n\nimport { DefaultParameters, Context, Parameters, Request } from './interfaces';\nimport { hasBeenAppended } from './createRouter';\nimport {\n\tdeconstruct as deconstructPath,\n\tmatch as matchPath,\n\tDeconstructedPath\n} from './lib/path';\n\n/**\n * Hash object where keys are parameter names and keys are arrays of one or more\n * parameter values.\n */\nexport type SearchParams = Hash<string[]>;\n\n/**\n * Describes whether a route matched.\n */\nexport interface MatchResult<P> {\n\t/**\n\t * Whether there are path segments that weren't matched by this route.\n\t */\n\thasRemaining: boolean;\n\n\t/**\n\t * Position in the segments array that the remaining unmatched segments start.\n\t */\n\toffset: number;\n\n\t/**\n\t * Any extracted parameters. Only available if the route matched.\n\t */\n\tparams: P;\n\n\t/**\n\t * Values for named segments in the path, in order of occurrence.\n\t */\n\trawPathValues: string[];\n\n\t/**\n\t * Values for known named query parameters that were actually present in the\n\t * path.\n\t */\n\trawSearchParams: SearchParams;\n}\n\n/**\n * A request handler.\n */\nexport type Handler = (request: Request<Context, Parameters>) => void | Thenable<any>;\n\n/**\n * Describes the selection of a particular route.\n */\nexport interface Selection {\n\t/**\n\t * Which handler should be called when the route is executed.\n\t */\n\thandler: Handler;\n\n\t/**\n\t * The selected path.\n\t */\n\tpath: DeconstructedPath;\n\n\t/**\n\t * The extracted parameters.\n\t */\n\tparams: Parameters;\n\n\t/**\n\t * Values for named segments in the path, in order of occurrence.\n\t */\n\trawPathValues: string[];\n\n\t/**\n\t * Values for known named query parameters that were actually present in the\n\t * path.\n\t */\n\trawSearchParams: SearchParams;\n\n\t/**\n\t * The selected route.\n\t */\n\troute: Route<Context, Parameters>;\n}\n\n/**\n * A route.\n * The generic should be specified if parameter access is required.\n */\nexport interface Route<C extends Context, P extends Parameters> {\n\t/**\n\t * The route this route has been appended to.\n\t */\n\treadonly parent?: Route<Context, Parameters>;\n\n\t/**\n\t * Frozen, deconstructed path object.\n\t */\n\treadonly path: DeconstructedPath;\n\n\t/**\n\t * Append one or more routes.\n\t *\n\t * A route can only appended to another route, or a router itself, once.\n\t *\n\t * @param routes A single route or an array containing 0 or more routes.\n\t */\n\tappend(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;\n\n\t/**\n\t * Determine whether the route matches.\n\t * @param segments Segments of the pathname (excluding slashes).\n\t * @param hasTrailingSlash Whether the pathname that's being matched ended with a slashes.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return Whether and how the route matched.\n\t */\n\tmatch(segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): null | MatchResult<P>;\n\n\t/**\n\t * Attempt to select this and any nested routes.\n\t * @param context The dispatch context.\n\t * @param segments Segments of the pathname (excluding slashes).\n\t * @param hasTrailingSlash Whether the pathname that's being matched ended with a slashes.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return A string if a matching route determined a redirect is necessary. The string should be the path to\n\t *   redirect to. Otherwise an empty array if this (and any nested routes) could not be selected, else the selected\n\t *   routes and accompanying `params` objects.\n\t */\n\tselect(\n\t\tcontext: Context,\n\t\tsegments: string[],\n\t\thasTrailingSlash: boolean,\n\t\tsearchParams: UrlSearchParams\n\t): string | Selection[];\n}\n\n/**\n * The options for the route.\n */\nexport interface RouteOptions<C, P> {\n\t/**\n\t * Path the route matches against. Pathname segments may be named, same for query parameters. Leading slashes are\n\t * ignored. Defaults to `/`.\n\t */\n\tpath?: string;\n\n\t/**\n\t * If the `path` option contains a trailing slash (in the pathname component), the route will only match against\n\t * another pathname that contains a trailing slash, and vice-versa if the path does not contain a trailing slash.\n\t * Defaults to `true`, change to `false` to allow routes to match regardless of trailing slashes.\n\t */\n\ttrailingSlashMustMatch?: boolean;\n\n\t/**\n\t * A handler called when the route is executed.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\texec?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * If specified, causes the route to be selected if there are no nested routes that match the remainder of\n\t * the dispatched path. When the route is executed, this handler is called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tfallback?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used to determine whether the route should be selected after it's been matched.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t * @return Returning `true` causes the route to be selected. Returning a string indicates that a redirect is\n\t *   required; the string should be the path to redirect to.\n\t */\n\tguard?(request: Request<C, P>): string | boolean;\n\n\t/**\n\t * If specified, and the route is the final route in the hierarchy, when the route is executed, this handler is\n\t * called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tindex?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used for constructing the `params` object from extracted parameters, and validating the parameters.\n\t * @param fromPathname Array of parameter values extracted from the pathname.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return If `null` prevents the route from being selected, else the value for the `params` object.\n\t */\n\tparams?(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n}\n\nexport interface RouteFactory<C extends Context, P extends Parameters> extends ComposeFactory<Route<C, P>, RouteOptions<C, P>> {\n\t/**\n\t * Create a new instance of a route.\n\t * @param options Options to use during creation.\n\t */\n\t<P>(options?: RouteOptions<Context, P>): Route<Context, P>;\n\t<C, P>(options?: RouteOptions<C, P>): Route<C, P>;\n}\n\ninterface PrivateState {\n\tpath: DeconstructedPath;\n\troutes: Route<Context, Parameters>[];\n\ttrailingSlashMustMatch: boolean;\n\n\tcomputeParams<P extends Parameters>(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n\texec?: Handler;\n\tfallback?: Handler;\n\tguard?(request: Request<Context, Parameters>): string | boolean;\n\tindex?: Handler;\n}\n\nconst privateStateMap = new WeakMap<Route<Context, Parameters>, PrivateState>();\n\n// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n// change the private state of their children.\nconst parentMap = new WeakMap<Route<Context, Parameters>, Route<Context, Parameters>>();\n\nconst noop = () => {};\n\nfunction computeDefaultParams(\n\tparameters: string[],\n\tsearchParameters: string[],\n\tfromPathname: string[],\n\tsearchParams: UrlSearchParams\n): null | DefaultParameters {\n\tconst params: DefaultParameters = {};\n\tparameters.forEach((name, index) => {\n\t\tparams[name] = fromPathname[index];\n\t});\n\tsearchParameters.forEach(name => {\n\t\tconst value = searchParams.get(name);\n\t\tif (value !== undefined) {\n\t\t\tparams[name] = value;\n\t\t}\n\t});\n\n\treturn params;\n}\n\nconst createRoute: RouteFactory<Context, Parameters> =\n\tcompose({\n\t\tget parent(this: Route<Context, Parameters>) {\n\t\t\treturn parentMap.get(this);\n\t\t},\n\n\t\tget path(this: Route<Context, Parameters>) {\n\t\t\treturn privateStateMap.get(this).path;\n\t\t},\n\n\t\tappend(this: Route<Context, Parameters>, add: Route<Context, Parameters> | Route<Context, Parameters>[]) {\n\t\t\tconst { routes } = privateStateMap.get(this);\n\t\t\tconst append = (route: Route<Context, Parameters>) => {\n\t\t\t\tif (hasBeenAppended(route)) {\n\t\t\t\t\tthrow new Error('Cannot append route that has already been appended');\n\t\t\t\t}\n\n\t\t\t\troutes.push(route);\n\t\t\t\tparentMap.set(route, this);\n\t\t\t};\n\n\t\t\tif (Array.isArray(add)) {\n\t\t\t\tfor (const route of add) {\n\t\t\t\t\tappend(route);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tappend(add);\n\t\t\t}\n\t\t},\n\n\t\tmatch(\n\t\t\tthis: Route<Context, Parameters>,\n\t\t\tsegments: string[],\n\t\t\thasTrailingSlash: boolean,\n\t\t\tsearchParams: UrlSearchParams\n\t\t): null | MatchResult<Parameters> {\n\t\t\tconst { computeParams, path, trailingSlashMustMatch } = privateStateMap.get(this);\n\n\t\t\tconst result = matchPath(path, segments);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Only extract the search params defined in the route's path.\n\t\t\tconst knownSearchParams = path.searchParameters.reduce<SearchParams>((list, name) => {\n\t\t\t\tconst value = searchParams.getAll(name);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tlist[name] = value;\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}, {});\n\n\t\t\tconst params = computeParams(result.values, new UrlSearchParams(knownSearchParams));\n\t\t\tif (params === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\thasRemaining: result.hasRemaining,\n\t\t\t\toffset: result.offset,\n\t\t\t\tparams,\n\t\t\t\trawPathValues: result.values,\n\t\t\t\trawSearchParams: knownSearchParams\n\t\t\t};\n\t\t},\n\n\t\tselect(\n\t\t\tthis: Route<Context, Parameters>,\n\t\t\tcontext: Context,\n\t\t\tsegments: string[],\n\t\t\thasTrailingSlash: boolean,\n\t\t\tsearchParams: UrlSearchParams\n\t\t): string | Selection[] {\n\t\t\tconst { exec, index, fallback, guard, path, routes } = privateStateMap.get(this);\n\n\t\t\tconst matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\n\t\t\t// Return early if possible.\n\t\t\tif (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst { params } = matchResult;\n\t\t\tif (guard) {\n\t\t\t\tconst guardResult = guard({ context, params });\n\t\t\t\tif (typeof guardResult === 'string') {\n\t\t\t\t\treturn guardResult;\n\t\t\t\t}\n\t\t\t\tif (!guardResult) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet handler = exec;\n\t\t\tlet redirect: string | undefined;\n\t\t\tlet remainingSelection: Selection[] | undefined;\n\t\t\tlet selected = false;\n\n\t\t\tif (matchResult.hasRemaining) {\n\t\t\t\t// Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t\t\t\tconst remainingSegments = segments.slice(matchResult.offset);\n\t\t\t\tselected = routes.some((nested) => {\n\t\t\t\t\tconst nestedResult = nested.select(context, remainingSegments, hasTrailingSlash, searchParams);\n\t\t\t\t\tif (typeof nestedResult === 'string') {\n\t\t\t\t\t\tredirect = nestedResult;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (nestedResult.length > 0) {\n\t\t\t\t\t\tremainingSelection = nestedResult;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\t// No remaining segments matched, only select this route if a fallback handler was specified.\n\t\t\t\tif (!selected && fallback) {\n\t\t\t\t\tselected = true;\n\t\t\t\t\thandler = fallback;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Select this route, configure the index handler if specified.\n\t\t\telse {\n\t\t\t\tselected = true;\n\t\t\t\tif (index) {\n\t\t\t\t\thandler = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!selected) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (redirect !== undefined) {\n\t\t\t\treturn redirect;\n\t\t\t}\n\n\t\t\tconst { rawPathValues, rawSearchParams } = matchResult;\n\t\t\tconst selection = {\n\t\t\t\t// Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t\t\t\t// think no routes were selected.\n\t\t\t\thandler: handler || noop,\n\t\t\t\tpath,\n\t\t\t\tparams,\n\t\t\t\trawPathValues,\n\t\t\t\trawSearchParams,\n\t\t\t\troute: this\n\t\t\t};\n\t\t\treturn remainingSelection ? [selection, ...remainingSelection] : [selection];\n\t\t}\n\t},\n\t(\n\t\tinstance: Route<Context, Parameters>,\n\t\t{\n\t\t\texec,\n\t\t\tfallback,\n\t\t\tguard,\n\t\t\tindex,\n\t\t\tparams: computeParams,\n\t\t\tpath,\n\t\t\ttrailingSlashMustMatch = true\n\t\t}: RouteOptions<Context, Parameters> = {}\n\t) => {\n\t\tif (path && /#/.test(path)) {\n\t\t\tthrow new TypeError('Path must not contain \\'#\\'');\n\t\t}\n\n\t\tconst deconstructedPath = deconstructPath(path || '/');\n\t\tconst { parameters, searchParameters } = deconstructedPath;\n\n\t\tif (computeParams) {\n\t\t\tif (parameters.length === 0 && searchParameters.length === 0) {\n\t\t\t\tthrow new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomputeParams = (fromPathname: string[], searchParams: UrlSearchParams) => {\n\t\t\t\treturn computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t\t\t};\n\t\t}\n\n\t\tprivateStateMap.set(instance, {\n\t\t\tcomputeParams,\n\t\t\texec,\n\t\t\tfallback,\n\t\t\tguard,\n\t\t\tindex,\n\t\t\tpath: deconstructedPath,\n\t\t\troutes: [],\n\t\t\ttrailingSlashMustMatch\n\t\t});\n\t});\n\nexport default createRoute;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/createRoute.ts","import { deprecated } from 'dojo-core/instrument';\nimport { assign } from 'dojo-core/lang';\nimport { from as arrayFrom, includes } from 'dojo-shim/array';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport Symbol from 'dojo-shim/Symbol';\nimport {\n\tbefore as aspectBefore,\n\tafter as aspectAfter,\n\taround as aspectAround,\n\tBeforeAdvice,\n\tAfterAdvice,\n\tAroundAdvice\n} from './aspect';\n\n/**\n * A tuple of advice types and advice\n */\ntype AdviceTuple = ['before', BeforeAdvice] | ['after', AfterAdvice<any>] | ['around', AroundAdvice<any>];\n\n/**\n * A map of advice to apply to a method, with the `method` key being a tuple of advice\n */\ntype AdviceMap = {\n\t[method: string]: AdviceTuple[];\n};\n\n/**\n * Interface for storing the private meta data related to a factory\n */\ninterface PrivateFactoryData {\n\t/**\n\t * A map of advice that should be applied to a prototype of a factory as it is being constructed\n\t */\n\tadvice?: AdviceMap;\n\n\t/**\n\t * The base prototype that contains the methods and properties without advice applied\n\t */\n\tbase?: any;\n\n\t/**\n\t * The array of initialization functions that should be applied to the instance upon creation\n\t */\n\tinitFns: ComposeInitializationFunction<any, any>[];\n\n\t/**\n\t * Any static properties/methods that should be applied when creating a factory\n\t */\n\tstaticProperties?: any;\n}\n\n/**\n * The default factory label if no label can be derived during the factory creation process\n */\nconst DEFAULT_FACTORY_LABEL = 'Compose';\n\n/* References to support minification */\nconst defineProperty = Object.defineProperty;\nconst isArray = Array.isArray;\nconst objectCreate = Object.create;\nconst objectKeys = Object.keys;\n\n/**\n * A weakmap that stores all the private data for a factory\n */\nconst privateFactoryData = new WeakMap<Function, PrivateFactoryData>();\n\n/**\n * An internal function which stubs out a method which, when called at runtime, throws.\n *\n * @param method The name of \"abstract\" method being called\n */\nfunction missingMethod(method: string): () => never {\n\treturn function throwOnMissingMethod(): never {\n\t\tthrow new TypeError(`Advice being applied to missing method named: ${method}`);\n\t};\n}\n\n/**\n * Internal function which can label a factory with a name and also sets\n * the `toString()` method on the prototype to return the approriate\n * name for instances.\n *\n * @param fn The name of the factory to label\n * @param value The name to supply for the label\n */\nfunction assignFactoryName(factory: Function, value: string): void {\n\tif (typeof factory === 'function' && factory.prototype) {\n\t\tassignFunctionName(factory, value);\n\t\tdefineProperty(factory.prototype, <any> Symbol.toStringTag, {\n\t\t\tget() {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n}\n\n/**\n * Internal function which can label a function with a name\n */\nfunction assignFunctionName(fn: Function, value: string): void {\n\tconst nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\tif (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t\tdefineProperty(fn, 'name', {\n\t\t\tvalue,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n}\n\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n *\n * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n * @param target The target that properties should be copied onto\n * @param sources The rest of the parameters treated as sources to apply\n */\nfunction assignProperties(overwrite: boolean, target: any, ...sources: any[]) {\n\tsources.forEach((source) => {\n\t\tif (!source) {\n\t\t\treturn;\n\t\t}\n\t\tObject.defineProperties(\n\t\t\ttarget,\n\t\t\tObject.getOwnPropertyNames(source).reduce(\n\t\t\t\t(descriptors: PropertyDescriptorMap, key: string) => {\n\t\t\t\t\tif (key !== 'constructor') { /* don't copy constructor */\n\t\t\t\t\t\tconst sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t\t\t\t\t\tconst sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t\t\t\t\t\tconst targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t\t\t\t\t\tconst targetValue = targetDescriptor && targetDescriptor.value;\n\n\t\t\t\t\t\t/* Special handling to merge array proprties */\n\t\t\t\t\t\tif (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n\t\t\t\t\t\t\tsourceDescriptor.value = sourceValue.reduce(\n\t\t\t\t\t\t\t\t(value: any[], current: any) => {\n\t\t\t\t\t\t\t\t\tif (!includes(target[key], current)) {\n\t\t\t\t\t\t\t\t\t\tvalue.push(current);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tarrayFrom(targetValue)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdescriptors[key] = sourceDescriptor;\n\t\t\t\t\t}\n\t\t\t\t\treturn descriptors;\n\t\t\t\t},\n\t\t\t\tobjectCreate(null)\n\t\t\t)\n\t\t);\n\t});\n\treturn target;\n}\n\n/**\n * A helper funtion to return a function that is rebased to infer that the\n * first argument of the passed function will be the `this` when the function\n * is executed.\n *\n * @param  fn The function to be rebased\n * @return    The rebased function\n */\nfunction rebase(fn: (base: any, ...args: any[]) => any): (...args: any[]) => any {\n\treturn function(this: any, ...args: any[]) {\n\t\treturn fn.apply(this, [ this ].concat(args));\n\t};\n}\n\n/**\n * For a given factory, return the names of the initialization functions that will be\n * invoked upon construction.\n *\n * @param factory The factory that the array of function names should be returned for\n */\nexport function getInitFunctionNames(factory: ComposeFactory<any, any>): string[] | undefined {\n\tconst initFns = privateFactoryData.get(factory).initFns;\n\tif (initFns) {\n\t\treturn initFns.map((fn) => (<any> fn).name);\n\t}\n}\n\n/* The rebased functions we need to decorate compose constructors with */\n\n/**\n * Perform an extension of a class\n *\n * @deprecated\n */\nconst doExtend = rebase(extend);\n\n/**\n * Perform a mixin of a class\n */\nconst doMixin = rebase(mixin);\n\n/**\n * Perform a override of a class\n */\nconst doOverride = rebase(override);\n\n/**\n * Perform an overlay of a class\n */\nconst doOverlay = rebase(overlay);\n\n/**\n * Apply aspect advice to a class\n */\nconst doAspect = rebase(aspect);\n\n/**\n * Add static method/properties to a class\n */\nconst doStatic = rebase(_static);\n\n/**\n * Take a mixin and return a factory descriptor for the mixin\n *\n * @param mixin The factory to return the descriptor for\n * @template T The outer type of the descriptor\n * @template O The outer factory options of the descriptor\n * @template U The inner type of the descriptor\n * @template P The inner factory options of the descriptor\n */\nfunction factoryDescriptor<T, O, U, P>(mixin: ComposeFactory<U, P>): ComposeMixinDescriptor<T, O, U, P> {\n\treturn {\n\t\tmixin,\n\t\tclassName: mixin.name\n\t};\n};\n\n/**\n * Generate a factory descriptor for a class\n */\nconst doFactoryDescriptor = rebase(factoryDescriptor);\n\n/**\n * A set of functions that are used to decorate the compose factories\n */\nconst staticMethods = {\n\textend: doExtend, /* DEPRECATED */\n\tmixin: doMixin,\n\toverride: doOverride,\n\toverlay: doOverlay,\n\tfrom: doFrom,\n\tbefore: doBefore,\n\tafter: doAfter,\n\taround: doAround,\n\taspect: doAspect,\n\tfactoryDescriptor: doFactoryDescriptor,\n\tstatic: doStatic\n};\n\n/**\n * A convenience function to decorate compose class factories, including any static prpoerties\n *\n * @param base The target constructor\n */\ninterface FactoryOptions<T, U, O, S> {\n\t/**\n\t * A map of advice to be applied to be merged with any advice from factories and then applied to the prototype\n\t */\n\tadvice?: AdviceMap;\n\n\t/**\n\t * Any factories to mixin to this factory\n\t */\n\tfactories?: ComposeFactory<U, O>[];\n\n\t/**\n\t * Adds an init function to the factory\n\t */\n\tinitFunction?: ComposeInitializationFunction<any, O>;\n\n\t/**\n\t * The name of the class which the factory will construct\n\t */\n\tclassName?: string;\n\n\t/**\n\t * The prototype will always overwrite the base, instead of merging any special properties\n\t */\n\toverwrite?: boolean;\n\n\t/**\n\t * The prototype to mix into the base\n\t */\n\tproto?: T;\n\n\t/**\n\t * Any static properties to be added to the factory\n\t */\n\tstaticProperties?: S;\n}\n\n/**\n * Internal function that merges (or creates) an advice map\n *\n * @param sources The advice maps to be merged into a single one\n */\nfunction assignAdviceMap(...sources: (AdviceMap | undefined)[]): AdviceMap {\n\tconst result: AdviceMap = {};\n\tsources.forEach((source) => {\n\t\tif (source) {\n\t\t\tfor (const method in source) {\n\t\t\t\tresult[method] = result[method] ? [ ...result[method], ...source[method] ] : [ ...source[method] ];\n\t\t\t}\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * An internal function that takes a set of create widget options and returns a set of private factory data\n *\n * @param options The set of factory options to use in creating the private factory data\n */\nfunction createPrivateFactoryData({\n\tadvice: optionsAdvice,\n\tfactories,\n\tinitFunction,\n\toverwrite,\n\tproto,\n\tstaticProperties\n}: FactoryOptions<any, any, any, any>): PrivateFactoryData {\n\tconst factoryData = (factories || []).reduce((factoryData, factory) => {\n\t\tconst { advice, base, initFns } = privateFactoryData.get(factory);\n\t\tif (advice) {\n\t\t\tfactoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t\t}\n\t\tif (base) {\n\t\t\tassignProperties(false, factoryData.base, base);\n\t\t}\n\t\tconst optionsInitFns = factoryData.initFns;\n\t\tinitFns.forEach((initFn) => {\n\t\t\tif (!includes(optionsInitFns, initFn)) {\n\t\t\t\toptionsInitFns.push(initFn);\n\t\t\t}\n\t\t});\n\t\treturn factoryData;\n\t}, {\n\t\tbase: {},\n\t\tinitFns: [],\n\t\tstaticProperties: staticProperties ? assign({}, staticProperties) : undefined\n\t} as PrivateFactoryData);\n\n\tif (initFunction) {\n\t\tfactoryData.initFns.push(initFunction);\n\t}\n\n\tif (optionsAdvice) {\n\t\tfactoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t}\n\n\tassignProperties(Boolean(overwrite), factoryData.base, proto);\n\n\treturn factoryData;\n}\n\nfunction createFactory<T, U, O, S>(options: FactoryOptions<T, U, O, S>): ComposeFactory<T & U, O> & S;\nfunction createFactory<T, U, O>(options: FactoryOptions<T, U, O, any>): ComposeFactory<T & U, O> & any {\n\n\t/**\n\t * A compose factory\n\t */\n\tfunction factory(this: ComposeFactory<any, any>, ...args: any[]): any {\n\t\tif (this && this.constructor === factory) {\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\n\t\t}\n\t\tconst instance = objectCreate(factory.prototype);\n\n\t\t/* clone any arrays in the instance */\n\t\tfor (const key in instance) {\n\t\t\tif (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t\t\t\tinstance[key] = arrayFrom(instance[key]);\n\t\t\t}\n\t\t}\n\n\t\targs.unshift(instance);\n\t\tprivateFactoryData.get(factory).initFns.forEach(fn => {\n\t\t\tfn.apply(null, args);\n\t\t});\n\t\treturn instance;\n\t}\n\n\tconst factoryData = createPrivateFactoryData(options);\n\n\tprivateFactoryData.set(factory, factoryData);\n\n\tconst factoryPrototype = factory.prototype;\n\n\t/* mixin base properties into the prototype */\n\tassignProperties(false, factoryPrototype, factoryData.base);\n\n\t/* apply any advice to the prototype */\n\tif (factoryData.advice) {\n\t\tfor (const method in factoryData.advice) {\n\t\t\tfactoryData.advice[method].forEach(([ aspect, advice ]) => {\n\t\t\t\tconst sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t\t\t\tswitch (aspect) {\n\t\t\t\tcase 'before':\n\t\t\t\t\tfactoryPrototype[method] = aspectBefore(sourceMethod, <BeforeAdvice> advice);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'after':\n\t\t\t\t\tfactoryPrototype[method] = aspectAfter(sourceMethod, <AfterAdvice<any>> advice);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'around':\n\t\t\t\t\tfactoryPrototype[method] = aspectAround(sourceMethod, <AroundAdvice<any>> advice);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/* assign a constructor to the prototype */\n\tfactoryPrototype.constructor = factory;\n\n\t/* assign static methods/properties */\n\tassign(factory, staticMethods, factoryData.staticProperties);\n\n\t/* assign factory name */\n\tconst className = options.className ||\n\t\t(options.factories && options.factories[0] && options.factories[0].name) ||\n\t\tDEFAULT_FACTORY_LABEL;\n\tassignFactoryName(factory, className);\n\n\t/* freeze the factory, so it cannot be accidently modified */\n\tObject.freeze(factory);\n\n\treturn factory as ComposeFactory<any, any>;\n}\n\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n *\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nexport function isComposeFactory(value: any): value is ComposeFactory<any, any> {\n\treturn Boolean(value && privateFactoryData.get(value));\n}\n\n/* General Interfaces */\n\n/**\n * Used to adapt any consructor functions or classes to a compose factory\n */\nexport interface GenericClass<T> {\n\tnew (...args: any[]): T;\n\treadonly prototype: T;\n}\n\n/**\n * Used to adapt functions within compose\n */\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\n/**\n * A basic string index map of options\n */\nexport interface Options {\n\t[options: string]: any;\n}\n\nexport interface ComposeInitializationFunction<T, O extends Options> {\n\t/**\n\t * A callback function use to initialize a new created instance\n\t *\n\t * @param instance The newly constructed instance\n\t * @param options Any options that were passed to the factory\n\t * @template T The type of the instance\n\t * @template O The type of the options being passed\n\t */\n\t(instance: T, options?: O): void;\n\n\t/**\n\t * A string name of the function, used for debugging purposes\n\t */\n\treadonly name?: string;\n}\n\n/* Extension API */\n\n/* DEPRECATED - This API will be removed in the future */\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extend the factory prototype with the supplied object literal, class, or factory\n\t *\n\t * @deprecated\n\t * @param extension The object literal, class or factory to extend\n\t * @template T The original type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<U>(extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<U>(className: string, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<U, P>(extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n\textend<U, P>(className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Extend a compose factory prototype with the supplied object literal, class, or\n\t * factory.\n\t *\n\t * @deprecated\n\t * @param base The base compose factory to extend\n\t * @param extension The object literal, class or factory that is the extension\n\t * @template T The base type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the base factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<T, O, U>(base: ComposeFactory<T, O>, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<T, O, U>(base: ComposeFactory<T, O>, className: string, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n\textend<T, O, U, P>(base: ComposeFactory<T, O>, className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\n/**\n * The internal implementation of extending a compose factory\n *\n * @deprecated\n * @param base The base compose factory that is being extended\n * @param extension The extension to apply to the compose factory\n */\nfunction extend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\nfunction extend<T, O, U, P>(base: ComposeFactory<T, O>, className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\nfunction extend<O>(base: ComposeFactory<any, O>, className: any, extension?: any): ComposeFactory<any, O> {\n\tdeprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n\tif (typeof className !== 'string') {\n\t\textension = className;\n\t\tclassName = undefined;\n\t}\n\n\treturn createFactory({\n\t\tclassName,\n\t\tproto: typeof extension === 'function' ? extension.prototype : extension,\n\t\tfactories: [ base ]\n\t});\n}\n\n/* Override API */\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Override certain properties on the existing factory, returning a new factory.  If the properties\n\t * are not present in the existing factory, override will throw.\n\t *\n\t * @param properties The properties to override\n\t */\n\toverride(properties: any): this;\n\n\t/**\n\t * Override certain properties on the existing factory, returning a new factory.  If the properties\n\t * are not present in the existing factory, override with throw.\n\t *\n\t * @param className The class name for the factory\n\t * @param properties The properties to override\n\t */\n\toverride(className: string, properties: any): this;\n}\n\nexport interface Compose {\n\t/**\n\t * Override properties on a compose factory, returning a new factory.  If the properties are not\n\t * present on the base factory, override will throw.\n\t *\n\t * @param baseFactory The base compose factory to override\n\t * @param properties The properties to override\n\t */\n\toverride<T, O>(baseFactory: ComposeFactory<T, O>, properties: any): ComposeFactory<T, O>;\n\n\t/**\n\t * Override properties on a compose factory, returning a new factory.  If the properties are not\n\t * present on the base factory, override will throw.\n\t *\n\t * @param baseFactory The base compose factory to override\n\t * @param className The class name for the factory\n\t * @param properties The properties to override\n\t */\n\toverride<T, O>(baseFactory: ComposeFactory<T, O>, className: string, properties: any): ComposeFactory<T, O>;\n}\n\n/**\n * The internal implementation of overriding properties on a compose factory\n *\n * @param baseFactory The base factory\n * @param className The name of the class that will be produced by the factory\n * @param properties The object that contains the properties to override\n */\nfunction override<T, O>(baseFactory: ComposeFactory<T, O>, properties: any): ComposeFactory<T, O>;\nfunction override<T, O>(baseFactory: ComposeFactory<T, O>, className: string, properties: any): ComposeFactory<T, O>;\nfunction override<T, O>(baseFactory: ComposeFactory<T, O>, className: any, properties?: any): ComposeFactory<T, O> {\n\tif (typeof className !== 'string') {\n\t\tproperties = className;\n\t\tclassName = undefined;\n\t}\n\n\tif (typeof properties !== 'object') {\n\t\tthrow new TypeError('Argument \"properties\" must be an object.');\n\t}\n\n\tconst base = privateFactoryData.get(baseFactory).base;\n\n\t/* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n\t * similiar to this */\n\tObject.keys(properties).forEach((key) => {\n\t\tif (!(key in base)) {\n\t\t\tthrow new TypeError(`Attempting to override missing property \"${key}\"`);\n\t\t}\n\t});\n\n\treturn createFactory({\n\t\tclassName,\n\t\toverwrite: true,\n\t\tproto: properties,\n\t\tfactories: [ baseFactory ]\n\t});\n}\n\n/* Overlay API */\n\nexport interface OverlayFunction<T> {\n\t/**\n\t * A function that takes a factories prototype, allowing it to change the prototype without\n\t * mutating the type structure.\n\t *\n\t * @param proto The object literal that should be overlayed on the factories prototype.\n\t * @template T The type of the factories prototype\n\t */\n\t(proto: T): void;\n}\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Provide a function that mutates the factories prototype but does not change the factory's class\n\t * structure.\n\t *\n\t * @param overlayFunction The function which receives the factory's prototype\n\t * @template T The type of the factory's prototype\n\t */\n\toverlay(overlayFunction: OverlayFunction<T>): this;\n}\n\nexport interface Compose {\n\t/**\n\t * A static method that takes a compose factory and applies an overlay function to the factory,\n\t * returning a new compose factory with a mutated prototype.\n\t *\n\t * @param base The base ComposeFactory\n\t * @param overlayFunction The function which receives the base factory's prototype\n\t * @template T The type of the factory's prototype\n\t * @template O The options for the factory's creation\n\t */\n\toverlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;\n}\n\n/**\n * Internal implementation of the overlay functionality, to allow a function to modify a\n * compose factory prototype\n *\n * @param base The target compose factory\n * @param overlayFunction The callback function that will modify the prototype of the factory\n */\nfunction overlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O> {\n\tconst factory = createFactory({\n\t\tfactories: [ base ]\n\t});\n\toverlayFunction(factory.prototype);\n\treturn factory;\n}\n\n/* AOP/Inheritance API */\n\n/**\n * A descriptor for applying advice to a set of methods\n */\nexport interface AspectAdvice {\n\t/**\n\t * Any methods where the supplied advice should be applied *before* the base method is invoked\n\t */\n\tbefore?: { [method: string]: BeforeAdvice };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *after* the base method is invoked\n\t */\n\tafter?: { [method: string]: AfterAdvice<any> };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *around* the base method\n\t */\n\taround?: { [method: string]: AroundAdvice<any> };\n}\n\n/* Mixin API */\n\n/**\n * Either a class, object literal, or a factory\n */\nexport type ComposeMixinItem<T, O extends Options> = GenericClass<T> | T | ComposeFactory<T, O>;\n\n/**\n * An object which provides information on how to mixin into a compose factory\n */\nexport interface ComposeMixinDescriptor<T, O, U, P> {\n\t/**\n\t * The class, object literal, or factory to be mixed in\n\t */\n\tmixin?: ComposeMixinItem<U, P>;\n\n\t/**\n\t * An initialize function to be executed upon construction\n\t */\n\tinitialize?: ComposeInitializationFunction<T & U, O & P>;\n\n\t/**\n\t * Aspect Oriented Advice to be mixed into the factory\n\t */\n\taspectAdvice?: AspectAdvice;\n\n\t/**\n\t * An optional class name which is used when labelling different parts of a factory for\n\t * debugging purposes\n\t */\n\tclassName?: string;\n}\n\n/**\n * Identifies a compose factory or other object that can be transformed into a\n * ComposeMixinDescriptor\n */\nexport interface ComposeMixinable<U extends Options, P> {\n\t/**\n\t * A method that offers up a ComposeMixinDescriptor to allow complex mixin in of factories\n\t */\n\tfactoryDescriptor<T, O extends Options>(): ComposeMixinDescriptor<T, O, U, P>;\n}\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into the factory\n\t *\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<U, P>(mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;\n\tmixin<U, P>(mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into a factory\n\t *\n\t * @param base The base factory that is the target of the mixin\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinable<U, P>\n\t): ComposeFactory<T & U, O & P>;\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinDescriptor<T, O, U, P>\n\t): ComposeFactory<T & U, O & P>;\n}\n\n/**\n * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n * creating a factory\n *\n * @param aspectAdvice The aspect advice to convert into an advice map\n */\nfunction aspectAdviceToAdviceMap(aspectAdvice: AspectAdvice | undefined): AdviceMap | undefined {\n\tif (!aspectAdvice) {\n\t\treturn;\n\t}\n\n\tconst adviceMap: AdviceMap = {};\n\tconst beforeAdvice = aspectAdvice.before;\n\tconst afterAdvice = aspectAdvice.after;\n\tconst aroundAdvice = aspectAdvice.around;\n\n\tfunction mapAdvice(type: string, key: string, advice: { [ key: string ]: any }) {\n\t\tconst adviceTuple = [ type, advice[key] ] as AdviceTuple;\n\t\tif (adviceMap[key]) {\n\t\t\tadviceMap[key].push(adviceTuple);\n\t\t}\n\t\telse {\n\t\t\tadviceMap[key] = [ adviceTuple ];\n\t\t}\n\t}\n\n\tif (beforeAdvice) {\n\t\tobjectKeys(beforeAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('before', key, beforeAdvice!);\n\t\t});\n\t}\n\tif (afterAdvice) {\n\t\tobjectKeys(afterAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('after', key, afterAdvice!);\n\t\t});\n\t}\n\tif (aroundAdvice) {\n\t\tobjectKeys(aroundAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('around', key, aroundAdvice!);\n\t\t});\n\t}\n\treturn adviceMap;\n}\n\n/**\n * A custom type guard that determines if a value is ComposeMixinable\n *\n * @param value The value to guard for\n */\nfunction isComposeMixinable(value: any): value is ComposeMixinable<any, any> {\n\treturn Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n}\n\n/**\n * The internal implementation of mixin in values into a compose factory\n *\n * @param base The base compose factory that is the target for being mixed in\n * @param toMixin The value to be mixed in\n */\nfunction mixin<T, O, U, P>(\n\tbase: ComposeFactory<T, O>,\n\ttoMixin: ComposeMixinable<U, P> | ComposeMixinDescriptor<T, O, U, P>\n): ComposeFactory<T & U, O & P> {\n\t/* ensure we are dealing with a mixinDescriptor */\n\tconst mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\n\t/* destructure out most of the factory creation options */\n\tconst { mixin, initialize: initFunction, aspectAdvice, className } = mixinDescriptor;\n\n\t/* we will at least be using the base factory to create the new one */\n\tconst factories: ComposeFactory<any, any>[] = [ base ];\n\tlet proto: any;\n\n\t/* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\tif (isComposeFactory(mixin)) {\n\t\tfactories.push(mixin);\n\t}\n\t/* otherwise we are dealing with a prototype based mixin */\n\telse {\n\t\t/* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t\tproto = typeof mixin === 'function' ? mixin.prototype : mixin;\n\t}\n\n\t/* convert the advice, if any, to the format used by createFactory */\n\tconst advice = aspectAdviceToAdviceMap(aspectAdvice);\n\n\t/* label the initFn */\n\tif (initFunction) {\n\t\tassignFunctionName(\n\t\t\tinitFunction,\n\t\t\t`mixin${className || (isComposeFactory(mixin) && mixin.name) || base.name}`\n\t\t);\n\t}\n\n\t/* return the newly created factory */\n\treturn createFactory({\n\t\tadvice,\n\t\tfactories,\n\t\tinitFunction,\n\t\tclassName,\n\t\tproto\n\t}) as ComposeFactory<T & U, O & P>;\n}\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extract a method from another Class or Factory and add it to the returned factory\n\t *\n\t * @param base The base Class or Factory\n\t * @param method The name of the method to extract\n\t */\n\tfrom(base: GenericClass<any> | ComposeFactory<any, any>, method: string): this;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tbefore(method: string, advice: BeforeAdvice): this;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tafter<P>(method: string, advice: AfterAdvice<P>): this;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\taround<P>(method: string, advice: AroundAdvice<P>): this;\n\n\t/**\n\t * Provide an object literal which can contain a map of advice to apply\n\t *\n\t * @param advice An object literal which contains the maps of advice to apply\n\t */\n\taspect(advice: AspectAdvice): this;\n}\n\nexport interface Compose {\n\t/**\n\t * Extract a method from another Class or Factory and return it\n\t *\n\t * @param base The Class or Factory to extract from\n\t * @param method The method name to be extracted\n\t */\n\tfrom<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): T;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tbefore<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tafter<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\taround<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice to methods that exist in the base factory using the supplied advice map\n\t *\n\t * @param base The Factory that contains the methods the advice will be applied to\n\t * @param advice The map of advice to be applied\n\t */\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\n}\n\n/**\n * Internal implementation of extracting methods from another object\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction from<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): T {\n\treturn base.prototype[method];\n}\n\n/**\n * Internal implementation to apply from when `this` represents the base\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction doFrom<T, O>(this: ComposeFactory<T, O>, base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tproto: {\n\t\t\t[method]: base.prototype[method]\n\t\t}\n\t}) as ComposeFactory<T, O>;\n}\n\n/**\n * The internal implementation to apply before advice to a factory\n *\n * @param base The target that the advice should be applied to\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction before<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\nfunction before(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: BeforeAdvice;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply before advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doBefore<T, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: BeforeAdvice): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'before', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation to apply after advice to a factory\n *\n * @param base The target that the advice should be applied to\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction after<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply after advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAfter<T, P, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: AfterAdvice<P>): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'after', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation to apply after around when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction around<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\nfunction around(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAround(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply around advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAround<T, P, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: AroundAdvice<P>): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'around', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation of applying aspect advice to a factory\n *\n * @param base The base factory the advice should be applied to\n * @param advice The advice map to apply to the factory\n */\nfunction aspect<T, O>(base: ComposeFactory<T, O>, advice: AspectAdvice): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ base ],\n\t\tadvice: aspectAdviceToAdviceMap(advice)\n\t});\n}\n\n/* Creation API */\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Create a new instance\n\t *\n\t * @param options Options that are passed to the initialization functions of the factory\n\t */\n\t(options?: O): T;\n\n\t/**\n\t * The read only prototype of the factory\n\t */\n\treadonly prototype: T;\n}\n\nexport interface Compose {\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initalization function\n\t *\n\t * @param base The base Class, Factory or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and any creation options\n\t * @param className An optional class name that is used to label the factory for debug purposes\n\t */\n\t<T, O extends Options, P extends Options>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\t<T, O extends Options>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\t<T, O extends Options, P extends Options>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\t<T, O extends Options>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initialization function\n\t *\n\t * @param base The base Class, Facotry or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and nay creation options\n\t */\n\tcreate<T, O, P>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\tcreate<T, O>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\tcreate<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\tcreate<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n}\n\n/**\n * The internal implementation to create a compose factory\n *\n * @param base The base to use for creating the factory\n * @param initFunction Any function that should be run after the factory creates the instance\n */\nfunction create<T, O>(base: GenericClass<T> | T): ComposeFactory<T, O>;\nfunction create<T, O>(className: string, base: GenericClass<T> | T): ComposeFactory<T, O>;\nfunction create<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\nfunction create<T, O>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\nfunction create<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\nfunction create<T, O, P>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\nfunction create<O>(className: any, base?: any, initFunction?: ComposeInitializationFunction<any, O>): ComposeFactory<any, any> {\n\t/* disambugate arguments */\n\tif (typeof className !== 'string') {\n\t\tinitFunction = base;\n\t\tbase = className;\n\t\tclassName = undefined;\n\t}\n\n\t/* Label the initFunction */\n\tif (initFunction && className) {\n\t\tassignFunctionName(initFunction, `init${className}`);\n\t}\n\n\tlet factories: ComposeFactory<any, any>[] | undefined;\n\tlet proto: any;\n\n\t/* If base is a compose factory, set it as the factory array */\n\tif (base && isComposeFactory(base)) {\n\t\tfactories = [ base ];\n\t}\n\t/* Otherwise, we are dealing with a constructor function or a prototype */\n\telse {\n\t\tproto = typeof base === 'function' ? base.prototype : base;\n\t}\n\n\treturn createFactory({\n\t\tclassName,\n\t\tfactories,\n\t\tinitFunction,\n\t\tproto\n\t});\n}\n\n/* Extend factory with static properties */\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * Add static properties to a factory\n\t *\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<S>(staticProperties: S): this & S;\n}\n\nexport interface Compose {\n\t/**\n\t * Add static properties to a factory\n\t *\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<T, O, S>(factory: ComposeFactory<T, O>, staticProperties: S): ComposeFactory<T, O> & S;\n}\n\n/**\n * Internal implementation of applying static properties to a compose factory\n *\n * @param factory The factory that the static properties should be applied to\n * @param staticProperties The properties to be applied to the factory\n */\nfunction _static<T, O, S>(base: ComposeFactory<T, O>, staticProperties: S): ComposeFactory<T, O> & S {\n\treturn createFactory({\n\t\tfactories: [ base ],\n\t\tstaticProperties\n\t});\n}\n\nexport interface ComposeFactory<T, O extends Options> extends ComposeMixinable<T, O> {\n\t/**\n\t * The class name of the ComposeFactory\n\t */\n\treadonly name?: string;\n}\n\n/**\n * A factory construction utility\n *\n * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n * @param initFunction An optional initialization function for the factory\n */\nconst compose = create as Compose;\n\n/* Add static methods to compose */\n\nassign(compose, {\n\tcreate,\n\tstatic: _static,\n\textend, /* DEPRECATED */\n\tmixin,\n\toverride,\n\toverlay,\n\tfrom,\n\tbefore,\n\tafter,\n\taround,\n\taspect\n});\n\nexport default compose;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/compose.ts","import has from './has';\n\n/**\n * The default message to warn when no other is provided\n */\nconst DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n\n/**\n * When set, globalWarn will be used instead of `console.warn`\n */\nlet globalWarn: ((message?: any, ...optionalParams: any[]) => void) | undefined;\n\nexport interface DeprecatedOptions {\n\t/**\n\t * The message to use when warning\n\t */\n\tmessage?: string;\n\n\t/**\n\t * The name of the method or function to use\n\t */\n\tname?: string;\n\n\t/**\n\t * An alternative function to log the warning to\n\t */\n\twarn?: (...args: any[]) => void;\n\n\t/**\n\t * Reference an URL for more information when warning\n\t */\n\turl?: string;\n}\n\n/**\n * A function that will console warn that a function has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport function deprecated({ message, name, warn, url }: DeprecatedOptions = {}): void {\n\t/* istanbul ignore else: testing with debug off is difficult */\n\tif (has('debug')) {\n\t\tmessage = message || DEFAULT_DEPRECATED_MESSAGE;\n\t\tlet warning = `DEPRECATED: ${name ? name + ': ' : ''}${message}`;\n\t\tif (url) {\n\t\t\twarning += `\\n\\n    See ${url} for more details.\\n\\n`;\n\t\t}\n\t\tif (warn) {\n\t\t\twarn(warning);\n\t\t}\n\t\telse if (globalWarn) {\n\t\t\tglobalWarn(warning);\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(warning);\n\t\t}\n\t}\n}\n\n/**\n * A function that generates before advice that can be used to warn when an API has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport function deprecatedAdvice(options?: DeprecatedOptions): (...args: any[]) => any[] {\n\treturn function(...args: any[]): any[] {\n\t\tdeprecated(options);\n\t\treturn args;\n\t};\n}\n\n/**\n * A method decorator that will console warn when a method if invoked that is deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport function deprecatedDecorator(options?: DeprecatedOptions): MethodDecorator {\n\treturn function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\t\tif (has('debug')) {\n\t\t\tconst { value: originalFn } = descriptor;\n\t\t\toptions = options || {};\n\t\t\t/* IE 10/11 don't have the name property on functions */\n\t\t\toptions.name = target.constructor.name ? `${target.constructor.name}#${propertyKey}` : propertyKey;\n\t\t\tdescriptor.value = function(...args: any[]) {\n\t\t\t\tdeprecated(options);\n\t\t\t\treturn originalFn.apply(target, args);\n\t\t\t};\n\t\t}\n\t\treturn descriptor;\n\t};\n}\n\n/**\n * A function that will set the warn function that will be used instead of `console.warn` when\n * logging warning messages\n *\n * @param warn The function (or `undefined`) to use instead of `console.warn`\n */\nexport function setWarn(warn?: ((message?: any, ...optionalParams: any[]) => void)): void {\n\tglobalWarn = warn;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/instrument.ts","import global from './global';\nimport has, { add } from 'dojo-shim/support/has';\n\nexport * from 'dojo-shim/support/has';\nexport default has;\n\nadd('object-assign', typeof global.Object.assign === 'function');\n\nadd('raf', typeof requestAnimationFrame === 'function');\n\nadd('arraybuffer', typeof global.ArrayBuffer !== 'undefined');\nadd('formdata', typeof global.FormData !== 'undefined');\nadd('xhr', typeof global.XMLHttpRequest !== 'undefined');\nadd('xhr2', has('xhr') && 'responseType' in global.XMLHttpRequest.prototype);\nadd('xhr2-blob', function () {\n\tif (!has('xhr2')) {\n\t\treturn false;\n\t}\n\n\tconst request = new XMLHttpRequest();\n\trequest.open('GET', '/', true);\n\trequest.responseType = 'blob';\n\trequest.abort();\n\treturn request.responseType === 'blob';\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/has.ts","const globalObject: any = (function (): any {\n\tif (typeof window !== 'undefined') {\n\t\t// Browsers\n\t\treturn window;\n\t}\n\telse if (typeof global !== 'undefined') {\n\t\t// Node\n\t\treturn global;\n\t}\n\telse if (typeof self !== 'undefined') {\n\t\t// Web workers\n\t\treturn self;\n\t}\n\treturn {};\n})();\n\nexport default globalObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/global.ts","import global from './global';\nimport has from 'dojo-has/has';\nimport { add } from 'dojo-has/has';\n\nexport default has;\nexport * from 'dojo-has/has';\n\n/* ECMAScript 6 and 7 Features */\n\n/*\n * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n * will be anything that uses their iterator symbol, like Map, Set, etc.\n */\n\n/* Symbol */\nadd('es6-symbol', typeof global.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n\n/* Object */\nadd('es6-object-assign', typeof (<any> Object).assign === 'function');\n\n/* Array */\nadd('es6-array-from', 'from' in global.Array);\nadd('es6-array-of', 'of' in global.Array);\nadd('es6-array-fill', () => {\n\tif ('fill' in global.Array.prototype) {\n\t\t/* Some versions of Safari do not properly implement this */\n\t\treturn (<any> [ 1 ]).fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t}\n\treturn false;\n});\nadd('es6-array-findindex', 'findIndex' in global.Array.prototype);\nadd('es6-array-find', 'find' in global.Array.prototype);\nadd('es6-array-copywithin', 'copyWithin' in global.Array.prototype);\nadd('es7-array-includes', 'includes' in global.Array.prototype);\n\n/* String */\nadd('es6-string-raw', function () {\n\tfunction getCallSite(callSite: TemplateStringsArray, ...substitutions: any[]) {\n\t\treturn callSite;\n\t}\n\n\tif ('raw' in global.String) {\n\t\tlet b = 1;\n\t\tlet callSite = getCallSite`a\\n${b}`;\n\n\t\t(<any> callSite).raw = [ 'a\\\\n' ];\n\t\tconst supportsTrunc = global.String.raw(callSite, 42) === 'a:\\\\n';\n\n\t\treturn supportsTrunc;\n\t}\n\n\treturn false;\n});\nadd('es6-string-fromcodepoint', 'fromCodePoint' in global.String);\nadd('es6-string-codepointat', 'codePointAt' in global.String.prototype);\nadd('es6-string-normalize', 'normalize' in global.String.prototype);\nadd('es6-string-repeat', 'repeat' in global.String.prototype);\nadd('es6-string-startswith', 'startsWith' in global.String.prototype);\nadd('es6-string-endswith', 'endsWith' in global.String.prototype);\nadd('es6-string-includes', 'includes' in global.String.prototype);\nadd('es6-string-padstart', 'padStart' in global.String.prototype);\nadd('es6-string-padend', 'padEnd' in global.String.prototype);\n\n/* Math */\n\nadd('es6-math-acosh', typeof global.Math.acosh === 'function');\nadd('es6-math-clz32', typeof global.Math.clz32 === 'function');\nadd('es6-math-imul', () => {\n\tif ('imul' in global.Math) {\n\t\t/* Some versions of Safari on ios do not properly implement this */\n\t\treturn (<any> Math).imul(0xffffffff, 5) === -5;\n\t}\n\treturn false;\n});\n\n/* Promise */\nadd('es6-promise', typeof global.Promise !== 'undefined' && has('es6-symbol'));\n\n/* Observable */\nadd('es-observable', typeof global.Observable !== 'undefined');\n\n/* Set */\nadd('es6-set', () => {\n\tif (typeof global.Set === 'function') {\n\t\t/* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t\tconst set = new global.Set([1]);\n\t\treturn set.has(1) && 'keys' in set && typeof set.keys === 'function' && has('es6-symbol');\n\t}\n\treturn false;\n});\n\n/* Map */\nadd('es6-map', function () {\n\tif (typeof global.Map === 'function') {\n\t\t/*\n\t\tIE11 and older versions of Safari are missing critical ES6 Map functionality\n\t\tWe wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t\ttake arguments (iOS 8.4)\n\t\t */\n\t\ttry {\n\t\t\tconst map = new global.Map([ [0, 1] ]);\n\n\t\t\treturn map.has(0) &&\n\t\t\t\ttypeof map.keys === 'function' && has('es6-symbol') &&\n\t\t\t\ttypeof map.values === 'function' &&\n\t\t\t\ttypeof map.entries === 'function';\n\t\t}\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next: not testing on iOS at the moment */\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n});\n\n/* WeakMap */\nadd('es6-weakmap', function () {\n\tif (typeof global.WeakMap !== 'undefined') {\n\t\t/* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t\tconst key1 = {};\n\t\tconst key2 = {};\n\t\tconst map = new global.WeakMap([ [ key1, 1 ] ]);\n\t\tObject.freeze(key1);\n\t\treturn map.get(key1) === 1 && map.set(key2, 2) === map && has('es6-symbol');\n\t}\n\treturn false;\n});\n\n/* Miscellaneous features */\n\nadd('float32array', 'Float32Array' in global);\nadd('setimmediate', typeof global.setImmediate !== 'undefined');\nadd('postmessage', typeof postMessage === 'function');\nadd('microtasks', () => has('es6-promise') || has('host-node') || has('dom-mutationobserver'));\n\n/* DOM Features */\n\nadd('dom-mutationobserver', () => has('host-browser') && Boolean(global.MutationObserver || global.WebKitMutationObserver));\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/has.ts","const globalObject: any = (typeof global === 'undefined') ? Function('return this')() : global;\n\n// global spec defines a reference to the global object called 'global'\n// https://github.com/tc39/proposal-global\nif (!('global' in globalObject)) {\n\tglobalObject.global = globalObject;\n}\n\nexport default globalObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/global.ts","import { Require, Config } from './loader';\n\n/**\n * The valid return types from a feature test\n */\nexport type FeatureTestResult = boolean | string | number | undefined;\n\n/**\n * A function that tests for a feature and returns a result\n */\nexport type FeatureTest = () => FeatureTestResult;\n\n/**\n * A cache of results of feature tests\n */\nexport const testCache: { [feature: string]: FeatureTestResult } = {};\n\n/**\n * A cache of the un-resolved feature tests\n */\nexport const testFunctions: { [feature: string]: FeatureTest } = {};\n\nexport interface StaticHasFeatures {\n\t[ feature: string ]: FeatureTestResult;\n}\n\nexport interface DojoHasEnvironment {\n\t/**\n\t * Static features defined in the enviornment that should be used by the `has` module\n\t * instead of run-time detection.\n\t */\n\tstaticFeatures?: StaticHasFeatures | (() => StaticHasFeatures);\n}\n\ndeclare global {\n\tinterface Window {\n\t\t/**\n\t\t * The `dojo/has` enviornment which provides configuration when the module is\n\t\t * loaded.\n\t\t */\n\t\tDojoHasEnvironment?: DojoHasEnvironment;\n\t}\n}\n\n/**\n * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n */\nconst globalScope = (function (): any {\n\t/* istanbul ignore else */\n\tif (typeof window !== 'undefined') {\n\t\t// Browsers\n\t\treturn window;\n\t}\n\telse if (typeof global !== 'undefined') {\n\t\t// Node\n\t\treturn global;\n\t}\n\telse if (typeof self !== 'undefined') {\n\t\t// Web workers\n\t\treturn self;\n\t}\n\t/* istanbul ignore next */\n\treturn {};\n})();\n\n/* Grab the staticFeatures if there are available */\nconst { staticFeatures }: DojoHasEnvironment = globalScope.DojoHasEnvironment || {};\n\n/* Cleaning up the DojoHasEnviornment */\nif ('DojoHasEnvironment' in globalScope) {\n\tdelete globalScope.DojoHasEnvironment;\n}\n\n/**\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n * returns a map.\n *\n * @param value The value to guard for\n */\nfunction isStaticFeatureFunction(value: any): value is (() => StaticHasFeatures) {\n\treturn typeof value === 'function';\n}\n\n/**\n * The cache of asserted features that were available in the global scope when the\n * module loaded\n */\nconst staticCache: StaticHasFeatures = staticFeatures\n\t? isStaticFeatureFunction(staticFeatures)\n\t\t? staticFeatures.apply(globalScope)\n\t\t: staticFeatures\n\t: {}; /* Providing an empty cache, if none was in the environment\n\n/**\n * AMD plugin function.\n *\n * Conditional loads modules based on a has feature test value.\n *\n * @param resourceId Gives the resolved module id to load.\n * @param require The loader require function with respect to the module that contained the plugin resource in its\n *                dependency list.\n * @param load Callback to loader that consumes result of plugin demand.\n */\nexport function load(resourceId: string, require: Require, load: (value?: any) => void, config?: Config): void {\n\tresourceId ? require([ resourceId ], load) : load();\n}\n\n/**\n * AMD plugin function.\n *\n * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n * value(s).\n *\n * @param resourceId The id of the module\n * @param normalize Resolves a relative module id into an absolute module id\n */\nexport function normalize(resourceId: string, normalize: (moduleId: string) => string): string | null {\n\tconst tokens: RegExpMatchArray = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\tlet i = 0;\n\n\tfunction get(skip?: boolean): string | null {\n\t\tconst term = tokens[i++];\n\t\tif (term === ':') {\n\t\t\t// empty string module name, resolves to null\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\tif (tokens[i++] === '?') {\n\t\t\t\tif (!skip && has(term)) {\n\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\treturn get();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\tget(true);\n\t\t\t\t\treturn get(skip);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// a module\n\t\t\treturn term;\n\t\t}\n\t}\n\n\tconst id = get();\n\n\treturn id && normalize(id);\n}\n\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nexport function exists(feature: string): boolean {\n\treturn Boolean(feature in staticCache || feature in testCache || testFunctions[feature]);\n}\n\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nexport function add(feature: string, value: FeatureTest | FeatureTestResult, overwrite: boolean = false): void {\n\tif (exists(feature) && !overwrite && !(feature in staticCache)) {\n\t\tthrow new TypeError(`Feature \"${feature}\" exists and overwrite not true.`);\n\t}\n\n\tif (typeof value === 'function') {\n\t\ttestFunctions[feature] = value;\n\t}\n\telse {\n\t\ttestCache[feature] = value;\n\t\tdelete testFunctions[feature];\n\t}\n}\n\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n */\nexport default function has(feature: string): FeatureTestResult {\n\tlet result: FeatureTestResult;\n\n\tif (feature in staticCache) {\n\t\tresult = staticCache[feature];\n\t}\n\telse if (testFunctions[feature]) {\n\t\tresult = testCache[feature] = testFunctions[feature].call(null);\n\t\tdelete testFunctions[feature];\n\t}\n\telse if (feature in testCache) {\n\t\tresult = testCache[feature];\n\t}\n\telse {\n\t\tthrow new TypeError(`Attempt to detect unregistered has feature \"${feature}\"`);\n\t}\n\n\treturn result;\n}\n\n/*\n * Out of the box feature tests\n */\n\n/* Evironments */\n\n/* Used as a value to provide a debug only code path */\nadd('debug', true);\n\n/* Detects if the environment is \"browser like\" */\nadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\n/* Detects if the enviornment appears to be NodeJS */\nadd('host-node', function () {\n\tif (typeof process === 'object' && process.versions && process.versions.node) {\n\t\treturn process.versions.node;\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-has/has.ts","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 23\n// module chunks = 0","import has from './has';\nimport { Handle } from 'dojo-interfaces/core';\n\nconst slice = Array.prototype.slice;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value: any): value is Object {\n\treturn Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction copyArray<T>(array: T[], inherited: boolean): T[] {\n\treturn array.map(function (item: T): T {\n\t\tif (Array.isArray(item)) {\n\t\t\treturn  <any> copyArray(<any> item, inherited);\n\t\t}\n\n\t\treturn !shouldDeepCopyObject(item) ?\n\t\t\titem :\n\t\t\t_mixin({\n\t\t\t\tdeep: true,\n\t\t\t\tinherited: inherited,\n\t\t\t\tsources: <Array<T>> [ item ],\n\t\t\t\ttarget: <T> {}\n\t\t\t});\n\t});\n}\n\ninterface MixinArgs<T extends {}, U extends {}> {\n\tdeep: boolean;\n\tinherited: boolean;\n\tsources: (U | null | undefined)[];\n\ttarget: T;\n}\n\nfunction _mixin<T extends {}, U extends {}>(kwArgs: MixinArgs<T, U>): T&U {\n\tconst deep = kwArgs.deep;\n\tconst inherited = kwArgs.inherited;\n\tconst target = kwArgs.target;\n\n\tfor (let source of kwArgs.sources) {\n\t\tif (source === null || source === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let key in source) {\n\t\t\tif (inherited || hasOwnProperty.call(source, key)) {\n\t\t\t\tlet value: any = (<any> source)[key];\n\n\t\t\t\tif (deep) {\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tvalue = copyArray(value, inherited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (shouldDeepCopyObject(value)) {\n\t\t\t\t\t\tvalue = _mixin({\n\t\t\t\t\t\t\tdeep: true,\n\t\t\t\t\t\t\tinherited: inherited,\n\t\t\t\t\t\t\tsources: <U[]> [ value ],\n\t\t\t\t\t\t\ttarget: {}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(<any> target)[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn <T&U> target;\n}\n\ninterface ObjectAssignConstructor extends ObjectConstructor {\n\tassign<T extends {}, U extends {}>(target: T, ...sources: (U | null | undefined)[]): T&U;\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport const assign = has('object-assign') ?\n\t(<ObjectAssignConstructor> Object).assign :\n\tfunction<T extends {}, U extends {}> (target: T, ...sources: (U | null | undefined)[]): T&U {\n\t\treturn _mixin({\n\t\t\tdeep: false,\n\t\t\tinherited: false,\n\t\t\tsources: sources,\n\t\t\ttarget: target\n\t\t});\n\t};\n\n/**\n * Creates a new object from the given prototype, and copies all enumerable own properties of one or more\n * source objects to the newly created target object.\n *\n * @param prototype The prototype to create a new object from\n * @param mixins Any number of objects whose enumerable own properties will be copied to the created object\n * @return The new object\n */\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y, mixin6: Z): T & U & V & W & X & Y & Z;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y): T & U & V & W & X & Y;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X): T & U & V & W & X;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W): T & U & V & W;\nexport function create<T extends {}, U extends {}, V extends {}>(prototype: T, mixin1: U, mixin2: V): T & U & V;\nexport function create<T extends {}, U extends {}>(prototype: T, mixin: U): T & U;\nexport function create<T extends {}>(prototype: T): T;\nexport function create(prototype: any, ...mixins: any[]): any {\n\tif (!mixins.length) {\n\t\tthrow new RangeError('lang.create requires at least one mixin object.');\n\t}\n\n\tconst args = mixins.slice();\n\targs.unshift(Object.create(prototype));\n\n\treturn assign.apply(null, args);\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object,\n * recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepAssign<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepAssign<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepAssign(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: false,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object, recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepMixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nexport function duplicate<T extends {}>(source: T): T {\n\tconst target = Object.create(Object.getPrototypeOf(source));\n\n\treturn deepMixin(target, source);\n}\n\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport function isIdentical(a: any, b: any): boolean {\n\treturn a === b ||\n\t\t/* both values are NaN */\n\t\t(a !== a && b !== b);\n}\n\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nexport function lateBind(instance: {}, method: string, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn suppliedArgs.length ?\n\t\tfunction () {\n\t\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\t\t// TS7017\n\t\t\treturn (<any> instance)[method].apply(instance, args);\n\t\t} :\n\t\tfunction () {\n\t\t\t// TS7017\n\t\t\treturn (<any> instance)[method].apply(instance, arguments);\n\t\t};\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object.\n *\n * @return The modified target object\n */\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function mixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function mixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function mixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: false,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nexport function partial(targetFunction: (...args: any[]) => any, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn function (this: any) {\n\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\treturn targetFunction.apply(this, args);\n\t};\n}\n\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nexport function createHandle(destructor: () => void): Handle {\n\treturn {\n\t\tdestroy: function (this: Handle) {\n\t\t\tthis.destroy = function () {};\n\t\t\tdestructor.call(this);\n\t\t}\n\t};\n}\n\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nexport function createCompositeHandle(...handles: Handle[]): Handle {\n\treturn createHandle(function () {\n\t\tfor (let handle of handles) {\n\t\t\thandle.destroy();\n\t\t}\n\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/lang.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport has from './support/has';\nimport { wrapNative } from './support/util';\nimport { forOf, isArrayLike, isIterable, Iterable } from './iterator';\nimport { MAX_SAFE_INTEGER as maxSafeInteger } from './number';\n\nexport interface MapCallback<T, U> {\n\t/**\n\t * A callback function when mapping\n\t *\n\t * @param element The element that is currently being mapped\n\t * @param index The current index of the element\n\t */\n\t(element: T, index: number): U;\n}\n\nexport interface FindCallback<T> {\n\t/**\n\t * A callback function when using find\n\t *\n\t * @param element The element that is currenty being analysed\n\t * @param index The current index of the element that is being analysed\n\t * @param array The source array\n\t */\n\t(element: T, index: number, array: ArrayLike<T>): boolean;\n}\n\n/**\n * Ensures a non-negative, non-infinite, safe integer.\n *\n * @param length The number to validate\n * @return A proper length\n */\nfunction toLength(length: number): number {\n\tlength = Number(length);\n\tif (isNaN(length)) {\n\t\treturn 0;\n\t}\n\tif (isFinite(length)) {\n\t\tlength = Math.floor(length);\n\t}\n\t// Ensure a non-negative, real, safe integer\n\treturn Math.min(Math.max(length, 0), maxSafeInteger);\n}\n\n/**\n * From ES6 7.1.4 ToInteger()\n *\n * @param value A value to convert\n * @return An integer\n */\nfunction toInteger(value: any): number {\n\tvalue = Number(value);\n\tif (isNaN(value)) {\n\t\treturn 0;\n\t}\n\tif (value === 0 || !isFinite(value)) {\n\t\treturn value;\n\t}\n\n\treturn (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n}\n\n/**\n * Normalizes an offset against a given length, wrapping it if negative.\n *\n * @param value The original offset\n * @param length The total length to normalize against\n * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n */\nfunction normalizeOffset(value: number, length: number): number {\n\treturn value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n}\n\n/**\n * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n * the functionality is required or not.\n */\nexport namespace Shim {\n\texport function from(this: ArrayConstructor, arrayLike: Iterable<any> | ArrayLike<any>, mapFunction?: MapCallback<any, any>, thisArg?: any): Array<any> {\n\t\tif (arrayLike == null) {\n\t\t\tthrow new TypeError('from: requires an array-like object');\n\t\t}\n\n\t\tif (mapFunction && thisArg) {\n\t\t\tmapFunction = mapFunction.bind(thisArg);\n\t\t}\n\n\t\t/* tslint:disable-next-line:variable-name */\n\t\tconst Constructor = this;\n\t\tconst length: number = toLength((<any> arrayLike).length);\n\t\t// Support extension\n\t\tconst array: any[] = (typeof Constructor === 'function') ? <any[]> Object(new Constructor(length)) : new Array(length);\n\n\t\tif (!isArrayLike(arrayLike) && !isIterable(arrayLike)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tlet i = 0;\n\t\tforOf(arrayLike, function (value): void {\n\t\t\tarray[i] = mapFunction ? mapFunction(value, i) : value;\n\t\t\ti++;\n\t\t});\n\n\t\tif ((<any> arrayLike).length !== undefined) {\n\t\t\tarray.length = length;\n\t\t}\n\n\t\treturn array;\n\t}\n\n\texport function of<T>(...items: T[]): Array<T> {\n\t\treturn Array.prototype.slice.call(items);\n\t}\n\n\texport function copyWithin<T>(target: ArrayLike<T>, offset: number, start: number, end?: number): ArrayLike<T> {\n\t\tif (target == null) {\n\t\t\tthrow new TypeError('copyWithin: target must be an array-like object');\n\t\t}\n\n\t\tconst length = toLength(target.length);\n\t\toffset = normalizeOffset(toInteger(offset), length);\n\t\tstart = normalizeOffset(toInteger(start), length);\n\t\tend = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t\tlet count = Math.min(end - start, length - offset);\n\n\t\tlet direction = 1;\n\t\tif (offset > start && offset < (start + count)) {\n\t\t\tdirection = -1;\n\t\t\tstart += count - 1;\n\t\t\toffset += count - 1;\n\t\t}\n\n\t\twhile (count > 0) {\n\t\t\tif (start in target) {\n\t\t\t\ttarget[offset] = target[start];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete target[offset];\n\t\t\t}\n\n\t\t\toffset += direction;\n\t\t\tstart += direction;\n\t\t\tcount--;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\texport function fill<T>(target: ArrayLike<T>, value: any, start?: number, end?: number): ArrayLike<T> {\n\t\tconst length = toLength(target.length);\n\t\tlet i = normalizeOffset(toInteger(start), length);\n\t\tend = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\n\t\twhile (i < end) {\n\t\t\ttarget[i++] = value;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\texport function find<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): T | undefined {\n\t\tconst index = findIndex<T>(target, callback, thisArg);\n\t\treturn index !== -1 ? target[index] : undefined;\n\t}\n\n\texport function findIndex<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): number {\n\t\tconst length = toLength(target.length);\n\n\t\tif (!callback) {\n\t\t\tthrow new TypeError('find: second argument must be a function');\n\t\t}\n\n\t\tif (thisArg) {\n\t\t\tcallback = callback.bind(thisArg);\n\t\t}\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tif (callback(target[i], i, target)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\texport function includes<T>(target: ArrayLike<T>, searchElement: T, fromIndex: number = 0): boolean {\n\t\tlet len = toLength(target.length);\n\n\t\tfor (let i = fromIndex; i < len; ++i) {\n\t\t\tconst currentElement = target[i];\n\t\t\tif (searchElement === currentElement ||\n\t\t\t\t(searchElement !== searchElement && currentElement !== currentElement)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n/* ES6 Array static methods */\n\nexport interface From {\n\t/**\n\t * The Array.from() method creates a new Array instance from an array-like or iterable object.\n\t *\n\t * @param source An array-like or iterable object to convert to an array\n\t * @param mapFunction A map function to call on each element in the array\n\t * @param thisArg The execution context for the map function\n\t * @return The new Array\n\t */\n\t<T, U>(source: ArrayLike<T> | Iterable<T>, mapFunction: MapCallback<T, U>, thisArg?: any): Array<U>;\n\n\t/**\n\t * The Array.from() method creates a new Array instance from an array-like or iterable object.\n\t *\n\t * @param source An array-like or iterable object to convert to an array\n\t * @return The new Array\n\t */\n\t<T>(source: ArrayLike<T> | Iterable<T>): Array<T>;\n}\n\nexport const from: From = has('es6-array-from')\n\t? (<any> Array).from\n\t: Shim.from;\n\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexport const of: <T>(...items: T[]) => Array<T> = has('es6-array-of')\n\t? (<any> Array).of\n\t: Shim.of;\n\n/* ES6 Array instance methods */\n\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexport const copyWithin: <T>(target: ArrayLike<T>, offset: number, start: number, end?: number) => ArrayLike<T> = has('es6-array-copywithin')\n\t? wrapNative((<any> Array.prototype).copyWithin)\n\t: Shim.copyWithin;\n\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param start The first index to fill\n * @param end The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexport const fill: <T>(target: ArrayLike<T>, value: T, start?: number, end?: number) => ArrayLike<T> = has('es6-array-fill')\n\t? wrapNative((<any> Array.prototype).fill)\n\t: Shim.fill;\n\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param [thisArg] The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexport const find: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => T = has('es6-array-find')\n\t? wrapNative((<any> Array.prototype).find)\n\t: Shim.find;\n\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param [thisArg] The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexport const findIndex: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => number = has('es6-array-findindex')\n\t? wrapNative((<any> Array.prototype).findIndex)\n\t: Shim.findIndex;\n\n/* ES7 Array instance methods */\n\n/**\n * Determines whether an array includes a given value\n *\n * @param target the target array-like object\n * @param searchElement the item to search for\n * @param fromIndex the starting index to search from\n * @return `true` if the array includes the element, otherwise `false`\n */\nexport const includes: <T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number) => boolean = has('es7-array-includes')\n\t? wrapNative((<any> Array.prototype).includes)\n\t: Shim.includes;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/array.ts","/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor<T>(value: T, enumerable: boolean = false, writable: boolean = true, configurable: boolean = true): TypedPropertyDescriptor<T> {\n\treturn {\n\t\tvalue: value,\n\t\tenumerable: enumerable,\n\t\twritable: writable,\n\t\tconfigurable: configurable\n\t};\n}\n\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nexport function wrapNative(nativeFunction: Function): any {\n\treturn function (target: any, ...args: any[]) {\n\t\treturn nativeFunction.apply(target, args);\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/util.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX } from './string';\nimport './Symbol';\n\nexport interface IteratorResult<T> {\n\treadonly done: boolean;\n\treadonly value: T;\n}\n\nexport interface Iterator<T> {\n\tnext(value?: any): IteratorResult<T>;\n\treturn?(value?: any): IteratorResult<T>;\n\tthrow?(e?: any): IteratorResult<T>;\n}\n\nexport interface Iterable<T> {\n\t[Symbol.iterator](): Iterator<T>;\n}\n\nexport interface IterableIterator<T> extends Iterator<T> {\n\t[Symbol.iterator](): IterableIterator<T>;\n}\n\nconst staticDone: IteratorResult<any> = { done: true, value: undefined };\n\n/**\n * A class that provides \"shims\" an iterator interface on array like\n * objects.\n */\nexport class ShimIterator<T> {\n\tprivate _list: ArrayLike<T>;\n\tprivate _nextIndex: number = -1;\n\tprivate _nativeIterator: Iterator<T>;\n\n\tconstructor(list: ArrayLike<T> | Iterable<T>) {\n\t\tif (isIterable(list)) {\n\t\t\tthis._nativeIterator = list[Symbol.iterator]();\n\t\t}\n\t\telse {\n\t\t\tthis._list = list;\n\t\t}\n\t};\n\n\t/**\n\t * Return the next iteration result for the Iterator\n\t */\n\tnext(): IteratorResult<T> {\n\t\tif (this._nativeIterator) {\n\t\t\treturn this._nativeIterator.next();\n\t\t}\n\t\tif (!this._list) {\n\t\t\treturn staticDone;\n\t\t}\n\t\tif (++this._nextIndex < this._list.length) {\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: this._list[this._nextIndex]\n\t\t\t};\n\t\t}\n\t\treturn staticDone;\n\t};\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this;\n\t}\n}\n\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nexport function isIterable(value: any): value is Iterable<any> {\n\treturn value && typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nexport function isArrayLike(value: any): value is ArrayLike<any> {\n\treturn value && typeof value.length === 'number';\n}\n\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nexport function get<T>(iterable: Iterable<T> | ArrayLike<T>): Iterator<T> | undefined {\n\tif (isIterable(iterable)) {\n\t\treturn iterable[Symbol.iterator]();\n\t}\n\telse if (isArrayLike(iterable)) {\n\t\treturn new ShimIterator(iterable);\n\t}\n};\n\nexport interface ForOfCallback<T> {\n\t/**\n\t * A callback function for a forOf() iteration\n\t *\n\t * @param value The current value\n\t * @param object The object being iterated over\n\t * @param doBreak A function, if called, will stop the iteration\n\t */\n\t(value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;\n}\n\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nexport function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void {\n\tlet broken = false;\n\n\tfunction doBreak() {\n\t\tbroken = true;\n\t}\n\n\t/* We need to handle iteration of double byte strings properly */\n\tif (!isIterable(iterable) && typeof iterable === 'string') {\n\t\tconst l = iterable.length;\n\t\tfor (let i = 0; i < l; ++i) {\n\t\t\tlet char = iterable[i];\n\t\t\tif ((i + 1) < l) {\n\t\t\t\tconst code = char.charCodeAt(0);\n\t\t\t\tif ((code >= HIGH_SURROGATE_MIN) && (code <= HIGH_SURROGATE_MAX)) {\n\t\t\t\t\tchar += iterable[++i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback.call(thisArg, char, iterable, doBreak);\n\t\t\tif (broken) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tconst iterator = get(iterable);\n\t\tif (iterator) {\n\t\t\tlet result = iterator.next();\n\n\t\t\twhile (!result.done) {\n\t\t\t\tcallback.call(thisArg, result.value, iterable, doBreak);\n\t\t\t\tif (broken) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/iterator.ts","import has from './support/has';\nimport { wrapNative } from './support/util';\n\n/**\n * The minimum location of high surrogates\n */\nexport const HIGH_SURROGATE_MIN = 0xD800;\n\n/**\n * The maximum location of high surrogates\n */\nexport const HIGH_SURROGATE_MAX = 0xDBFF;\n\n/**\n * The minimum location of low surrogates\n */\nexport const LOW_SURROGATE_MIN = 0xDC00;\n\n/**\n * The maximum location of low surrogates\n */\nexport const LOW_SURROGATE_MAX = 0xDFFF;\n\nexport namespace Shim {\n\t/**\n\t * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t * Used by startsWith, includes, and endsWith.\n\t *\n\t * @return Normalized position.\n\t */\n\tfunction normalizeSubstringArgs(name: string, text: string, search: string, position: number,\n\t\t\tisEnd: boolean = false): [ string, string, number ] {\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.' + name + ' requires a valid string to search against.');\n\t\t}\n\n\t\tconst length = text.length;\n\t\tposition = position !== position ? (isEnd ? length : 0) : position;\n\t\treturn [ text, String(search), Math.min(Math.max(position, 0), length) ];\n\t}\n\n\texport function raw(callSite: TemplateStringsArray, ...substitutions: any[]): string {\n\t\tlet rawStrings = callSite.raw;\n\t\tlet result = '';\n\t\tlet numSubstitutions = substitutions.length;\n\n\t\tif (callSite == null || callSite.raw == null) {\n\t\t\tthrow new TypeError('string.raw requires a valid callSite object with a raw value');\n\t\t}\n\n\t\tfor (let i = 0, length = rawStrings.length; i < length; i++) {\n\t\t\tresult += rawStrings[i] + (i < numSubstitutions && i < length - 1 ? substitutions[i] : '');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport function fromCodePoint(...codePoints: number[]): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t\tconst length = arguments.length;\n\t\tif (!length) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromCharCode = String.fromCharCode;\n\t\tconst MAX_SIZE = 0x4000;\n\t\tlet codeUnits: number[] = [];\n\t\tlet index = -1;\n\t\tlet result = '';\n\n\t\twhile (++index < length) {\n\t\t\tlet codePoint = Number(arguments[index]);\n\n\t\t\t// Code points must be finite integers within the valid range\n\t\t\tlet isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t\t\t\tcodePoint >= 0 && codePoint <= 0x10FFFF;\n\t\t\tif (!isValid) {\n\t\t\t\tthrow RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t\t\t}\n\n\t\t\tif (codePoint <= 0xFFFF) {\n\t\t\t\t// BMP code point\n\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Astral code point; split in surrogate halves\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\tlet highSurrogate = (codePoint >> 10) + HIGH_SURROGATE_MIN;\n\t\t\t\tlet lowSurrogate = (codePoint % 0x400) + LOW_SURROGATE_MIN;\n\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t}\n\n\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\tresult += fromCharCode.apply(null, codeUnits);\n\t\t\t\tcodeUnits.length = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function codePointAt(text: string, position: number = 0): number | undefined {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.codePointAt requries a valid string.');\n\t\t}\n\t\tconst length = text.length;\n\n\t\tif (position !== position) {\n\t\t\tposition = 0;\n\t\t}\n\t\tif (position < 0 || position >= length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Get the first code unit\n\t\tconst first = text.charCodeAt(position);\n\t\tif (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > position + 1) {\n\t\t\t// Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\tconst second = text.charCodeAt(position + 1);\n\t\t\tif (second >= LOW_SURROGATE_MIN && second <= LOW_SURROGATE_MAX) {\n\t\t\t\treturn (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n\t\t\t}\n\t\t}\n\t\treturn first;\n\t}\n\n\t/* TODO: Missing normalize */\n\n\texport function repeat(text: string, count: number = 0): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\t\tif (count !== count) {\n\t\t\tcount = 0;\n\t\t}\n\t\tif (count < 0 || count === Infinity) {\n\t\t\tthrow new RangeError('string.repeat requires a non-negative finite count.');\n\t\t}\n\n\t\tlet result = '';\n\t\twhile (count) {\n\t\t\tif (count % 2) {\n\t\t\t\tresult += text;\n\t\t\t}\n\t\t\tif (count > 1) {\n\t\t\t\ttext += text;\n\t\t\t}\n\t\t\tcount >>= 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function startsWith(text: string, search: string, position: number = 0): boolean {\n\t\tsearch = String(search);\n\t\t[ text, search, position ] = normalizeSubstringArgs('startsWith', text, search, position);\n\n\t\tconst end = position + search.length;\n\t\tif (end > text.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(position, end) === search;\n\t}\n\n\texport function endsWith(text: string, search: string, endPosition?: number): boolean {\n\t\tif (endPosition == null) {\n\t\t\tendPosition = text.length;\n\t\t}\n\n\t\t[ text, search, endPosition ] = normalizeSubstringArgs('endsWith', text, search, endPosition, true);\n\n\t\tconst start = endPosition - search.length;\n\t\tif (start < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(start, endPosition) === search;\n\t}\n\n\texport function includes(text: string, search: string, position: number = 0): boolean {\n\t\t[ text, search, position ] = normalizeSubstringArgs('includes', text, search, position);\n\t\treturn text.indexOf(search, position) !== -1;\n\t}\n\n\texport function padEnd(text: string, maxLength: number, fillString: string = ' '): string {\n\t\tif (text === null || text === undefined) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\n\t\tif (maxLength === Infinity) {\n\t\t\tthrow new RangeError('string.padEnd requires a non-negative finite count.');\n\t\t}\n\n\t\tif (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\tlet strText = String(text);\n\t\tconst padding = maxLength - strText.length;\n\n\t\tif (padding > 0) {\n\t\t\tstrText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n\t\t}\n\n\t\treturn strText;\n\t}\n\n\texport function padStart(text: string, maxLength: number, fillString: string = ' '): string {\n\t\tif (text === null || text === undefined) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\n\t\tif (maxLength === Infinity) {\n\t\t\tthrow new RangeError('string.padStart requires a non-negative finite count.');\n\t\t}\n\n\t\tif (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\tlet strText = String(text);\n\t\tconst padding = maxLength - strText.length;\n\n\t\tif (padding > 0) {\n\t\t\tstrText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n\t\t}\n\n\t\treturn strText;\n\t}\n\n\t/* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n}\n\n/**\n * A tag function for template strings to get the template string's raw string form.\n *\n * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n * @return String containing the raw template string with variables substituted\n *\n * @example\n * // Within TypeScript; logs 'The answer is:\\\\n42'\n * let answer = 42;\n * console.log(string.raw`The answer is:\\n${answer}`);\n *\n * @example\n * // The same example as above, but directly specifying a JavaScript object and substitution\n * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n */\nexport const raw: (callSite: TemplateStringsArray, ...substitutions: any[]) => string = has('es6-string-raw')\n\t? (<any> String).raw\n\t: Shim.raw;\n\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexport const fromCodePoint: (...codePoints: number[]) => string = has('es6-string-fromcodepoint')\n\t? (<any> String).fromCodePoint\n\t: Shim.fromCodePoint;\n\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexport const codePointAt: (text: string, position?: number) => number = has('es6-string-codepointat')\n\t? wrapNative((<any> String.prototype).codePointAt)\n\t: Shim.codePointAt;\n\n/**\n * Returns a string containing the given string repeated the specified number of times.\n *\n * @param text The string to repeat\n * @param count The number of times to repeat the string\n * @return A string containing the input string repeated count times\n */\nexport const repeat: (text: string, count?: number) => string = has('es6-string-repeat')\n\t? wrapNative((<any> String.prototype).repeat)\n\t: Shim.repeat;\n\n/**\n * Determines whether a string begins with the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found at the beginning of the given string\n */\nexport const startsWith: (text: string, search: string, position?: number) => boolean = has('es6-string-startswith')\n\t? wrapNative((<any> String.prototype).startsWith)\n\t: Shim.startsWith;\n\n/**\n * Determines whether a string ends with the given substring.\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param endPosition The index searching should stop before (defaults to text.length)\n * @return Boolean indicating if the search string was found at the end of the given string\n */\nexport const endsWith: (text: string, search: string, endPosition?: number) => boolean = has('es6-string-endswith')\n\t? wrapNative((<any> String.prototype).endsWith)\n\t: Shim.endsWith;\n\n/**\n * Determines whether a string includes the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found within the given string\n */\nexport const includes: (text: string, search: string, position?: number) => boolean = has('es6-string-includes')\n\t? wrapNative((<any> String.prototype).includes)\n\t: Shim.includes;\n\n/**\n * Pads the beginning of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded in the front if necessary.\n */\nexport const padStart: (text: string, maxLength: number, fillString?: string) => string = has('es6-string-padstart')\n\t? wrapNative((<any> String.prototype).padStart)\n\t: Shim.padStart;\n\n/**\n * Pads the end of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded at the end if necessary.\n */\nexport const padEnd: (text: string, maxLength: number, fillString?: string) => string = has('es6-string-padend')\n\t? wrapNative((<any> String.prototype).padEnd)\n\t: Shim.padEnd;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/string.ts","import has from './support/has';\nimport global from './support/global';\nimport { getValueDescriptor } from './support/util';\n\nexport namespace Shim {\n\t/* tslint:disable-next-line:variable-name */\n\tlet Symbol: SymbolConstructor;\n\t/* tslint:disable-next-line:variable-name */\n\tlet InternalSymbol: SymbolConstructor;\n\n\tconst defineProperties = Object.defineProperties;\n\tconst defineProperty = Object.defineProperty;\n\tconst create = Object.create;\n\n\tconst objPrototype = Object.prototype;\n\n\tinterface GlobalSymbols {\n\t\t[key: string]: symbol;\n\t}\n\n\tconst globalSymbols: GlobalSymbols = {};\n\n\tinterface TypedPropertyDescriptor<T> extends PropertyDescriptor {\n\t\tvalue?: T;\n\t\tget? (): T;\n\t\tset? (v: T): void;\n\t}\n\n\tconst getSymbolName = (function () {\n\t\tconst created = create(null);\n\t\treturn function (desc: string|number): string {\n\t\t\tlet postfix = 0;\n\t\t\tlet name: string;\n\t\t\twhile (created[String(desc) + (postfix || '')]) {\n\t\t\t\t++postfix;\n\t\t\t}\n\t\t\tdesc += String(postfix || '');\n\t\t\tcreated[desc] = true;\n\t\t\tname = '@@' + desc;\n\n\t\t\t// FIXME: Temporary guard until the duplicate execution when testing can be\n\t\t\t// pinned down.\n\t\t\tif (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t\t\t\tdefineProperty(objPrototype, name, {\n\t\t\t\t\tset: function (this: Symbol, value: any) {\n\t\t\t\t\t\tdefineProperty(this, name, getValueDescriptor(value));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn name;\n\t\t};\n\t}());\n\n\tInternalSymbol = function Symbol(this: any, description?: string|number): symbol {\n\t\tif (this instanceof InternalSymbol) {\n\t\t\tthrow new TypeError('TypeError: Symbol is not a constructor');\n\t\t}\n\t\treturn Symbol(description);\n\t} as SymbolConstructor;\n\n\tSymbol = function Symbol(this: Symbol, description?: string|number): symbol {\n\t\tif (this instanceof Symbol) {\n\t\t\tthrow new TypeError('TypeError: Symbol is not a constructor');\n\t\t}\n\t\tconst sym = Object.create(InternalSymbol.prototype);\n\t\tdescription = (description === undefined ? '' : String(description));\n\t\treturn defineProperties(sym, {\n\t\t\t__description__: getValueDescriptor(description),\n\t\t\t__name__: getValueDescriptor(getSymbolName(description))\n\t\t});\n\t} as SymbolConstructor;\n\n\t/**\n\t * A custom guard function that determines if an object is a symbol or not\n\t * @param  {any}       value The value to check to see if it is a symbol or not\n\t * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t */\n\texport function isSymbol(value: any): value is symbol {\n\t\treturn (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t}\n\n\t/**\n\t * Throws if the value is not a symbol, used internally within the Shim\n\t * @param  {any}    value The value to check\n\t * @return {symbol}       Returns the symbol or throws\n\t */\n\tfunction validateSymbol(value: any): symbol {\n\t\tif (!isSymbol(value)) {\n\t\t\tthrow new TypeError(value + ' is not a symbol');\n\t\t}\n\t\treturn value;\n\t}\n\n\t/* Decorate the Symbol function with the appropriate properties */\n\tdefineProperty(Symbol, 'for', getValueDescriptor(function (key: string): symbol {\n\t\tif (globalSymbols[key]) {\n\t\t\treturn globalSymbols[key];\n\t\t}\n\t\treturn (globalSymbols[key] = Symbol(String(key)));\n\t}));\n\tdefineProperties(Symbol, {\n\t\tkeyFor: getValueDescriptor(function (sym: symbol): string | undefined {\n\t\t\tlet key: string;\n\t\t\tvalidateSymbol(sym);\n\t\t\tfor (key in globalSymbols) {\n\t\t\t\tif (globalSymbols[key] === sym) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\thasInstance: getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t\tisConcatSpreadable: getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t\titerator: getValueDescriptor(Symbol.for('iterator'), false, false),\n\t\tmatch: getValueDescriptor(Symbol.for('match'), false, false),\n\t\tobservable: getValueDescriptor(Symbol.for('observable'), false, false),\n\t\treplace: getValueDescriptor(Symbol.for('replace'), false, false),\n\t\tsearch: getValueDescriptor(Symbol.for('search'), false, false),\n\t\tspecies: getValueDescriptor(Symbol.for('species'), false, false),\n\t\tsplit: getValueDescriptor(Symbol.for('split'), false, false),\n\t\ttoPrimitive: getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t\ttoStringTag: getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t\tunscopables: getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t});\n\n\t/* Decorate the InternalSymbol object */\n\tdefineProperties(InternalSymbol.prototype, {\n\t\tconstructor: getValueDescriptor(Symbol),\n\t\ttoString: getValueDescriptor(function (this: { __name__: string }) { return this.__name__; }, false, false)\n\t});\n\n\t/* Decorate the Symbol.prototype */\n\tdefineProperties(Symbol.prototype, {\n\t\ttoString: getValueDescriptor(function (this: Symbol) { return 'Symbol (' + (<any> validateSymbol(this)).__description__ + ')'; }),\n\t\tvalueOf: getValueDescriptor(function (this: Symbol) { return validateSymbol(this); })\n\t});\n\n\tdefineProperty(Symbol.prototype, <any> Symbol.toPrimitive, getValueDescriptor(function (this: Symbol) { return validateSymbol(this); }));\n\tdefineProperty(Symbol.prototype, <any> Symbol.toStringTag, getValueDescriptor('Symbol', false, false, true));\n\n\tdefineProperty(InternalSymbol.prototype, <any> Symbol.toPrimitive, getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\tdefineProperty(InternalSymbol.prototype, <any> Symbol.toStringTag, getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\n\t/* tslint:disable-next-line:variable-name */\n\texport const Exposed = Symbol;\n}\n\n/* tslint:disable-next-line:variable-name */\nconst SymbolShim: SymbolConstructor = has('es6-symbol') ? global.Symbol : global.Symbol = Shim.Exposed;\n\n/**\n * Fill any missing well known symbols if the native Symbol is missing them\n */\n[ 'hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t'toStringTag', 'unscopables', 'observable' ].forEach((wellKnown) => {\n\t\tif (!(<any> Symbol)[wellKnown]) {\n\t\t\tObject.defineProperty(Symbol, wellKnown, getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t\t}\n\t});\n\nexport const isSymbol = Shim.isSymbol;\n\nexport default SymbolShim;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Symbol.ts","import global from './support/global';\n\n/**\n * The smallest interval between two representable numbers.\n */\nexport const EPSILON = 1;\n\n/**\n * The maximum safe integer in JavaScript\n */\nexport const MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * The minimum safe integer in JavaScript\n */\nexport const MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n/**\n * Determines whether the passed value is NaN without coersion.\n *\n * @param value The value to test\n * @return true if the value is NaN, false if it is not\n */\nexport function isNaN(value: any): boolean {\n\treturn typeof value === 'number' && global.isNaN(value);\n}\n\n/**\n * Determines whether the passed value is a finite number without coersion.\n *\n * @param value The value to test\n * @return true if the value is finite, false if it is not\n */\nexport function isFinite(value: any): boolean {\n\treturn typeof value === 'number' && global.isFinite(value);\n}\n\n/**\n * Determines whether the passed value is an integer.\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport function isInteger(value: any): boolean {\n\treturn isFinite(value) && Math.floor(value) === value;\n}\n\n/**\n * Determines whether the passed value is an integer that is 'safe,' meaning:\n *   1. it can be expressed as an IEEE-754 double precision number\n *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n *      IEEE-754 representation cannot be the result of rounding any other\n *      integer to fit the IEEE-754 representation\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport function isSafeInteger(value: any): boolean {\n\treturn isInteger(value) && Math.abs(value) <= MAX_SAFE_INTEGER;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/number.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, Iterable } from './iterator';\nimport './Symbol';\n\nmodule Shim {\n\tconst DELETED: any = {};\n\n\tinterface Entry<K, V> {\n\t\tkey: K;\n\t\tvalue: V;\n\t}\n\n\tfunction getUID(): number {\n\t\treturn Math.floor(Math.random() * 100000000);\n\t}\n\n\tlet generateName = (function () {\n\t\tlet startId = Math.floor(Date.now() % 100000000);\n\n\t\treturn function generateName(): string {\n\t\t\treturn '__wm' + getUID() + (startId++ + '__');\n\t\t};\n\t})();\n\n\texport class WeakMap<K, V> {\n\t\tprivate readonly _name: string;\n\t\tprivate readonly _frozenEntries: Entry<K, V>[];\n\n\t\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {\n\t\t\tObject.defineProperty(this, '_name', {\n\t\t\t\tvalue: generateName()\n\t\t\t});\n\n\t\t\tthis._frozenEntries = [];\n\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, ([ key, value ]: [K, V]) => this.set(key, value));\n\t\t\t}\n\t\t}\n\n\t\tprivate _getFrozenEntryIndex(key: any): number {\n\t\t\tfor (let i = 0; i < this._frozenEntries.length; i++) {\n\t\t\t\tif (this._frozenEntries[i].key === key) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (entry && entry.key === key && entry.value !== DELETED) {\n\t\t\t\tentry.value = DELETED;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\tthis._frozenEntries.splice(frozenIndex, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tget(key: any): V | undefined {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (entry && entry.key === key && entry.value !== DELETED) {\n\t\t\t\treturn entry.value;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\treturn this._frozenEntries[frozenIndex].value;\n\t\t\t}\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tset(key: any, value?: any): Shim.WeakMap<K, V> {\n\t\t\tif (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t\t\t\tthrow new TypeError('Invalid value used as weak map key');\n\t\t\t}\n\t\t\tlet entry: Entry<K, V> = key[this._name];\n\t\t\tif (!entry || entry.key !== key) {\n\t\t\t\tentry = Object.create(null, {\n\t\t\t\t\tkey: { value: key }\n\t\t\t\t});\n\n\t\t\t\tif (Object.isFrozen(key)) {\n\t\t\t\t\tthis._frozenEntries.push(entry);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject.defineProperty(key, this._name, {\n\t\t\t\t\t\tvalue: entry\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.value = value;\n\t\t\treturn this;\n\t\t}\n\n\t\t[Symbol.toStringTag]: string = 'WeakMap';\n\t}\n}\n\n@hasClass('es6-weakmap', global.WeakMap, Shim.WeakMap)\nexport default class WeakMap<K, V> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {}\n\n\t/* istanbul ignore next */\n\tdelete(key: K): boolean { throw new Error(); }\n\t/* istanbul ignore next */\n\tget(key: K): V { throw new Error(); }\n\t/* istanbul ignore next */\n\thas(key: K): boolean { throw new Error(); }\n\t/* istanbul ignore next */\n\tset(key: K, value?: V): WeakMap<K, V> { throw new Error(); }\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'WeakMap';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/WeakMap.ts","import has from './has';\n\n/**\n * A class decorator that provides either a native class or a shimmed class based on a feature\n * test\n * @param feature The has feature to check\n * @param trueClass The class to use if feature test returns `true`\n * @param falseClass The class to use if the feature test returns `false` or is not defined\n */\nexport function hasClass(feature: string, trueClass: Function, falseClass: Function): ClassDecorator {\n\treturn function (target: Function): Function {\n\t\treturn has(feature) ? trueClass : falseClass;\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/decorators.ts","import WeakMap from 'dojo-shim/WeakMap';\n\nexport interface AdvisingFunction extends Function {\n\t/**\n\t * The next advice in an advice chain\n\t */\n\treadonly next: AdvisingFunction;\n\n\t/**\n\t * The previous advice in an advice chain\n\t */\n\treadonly previous: AdvisingFunction;\n}\n\nexport interface DispatchAdvice<T> {\n\tbefore?: BeforeAdvice[];\n\tafter?: AfterAdvice<T>[];\n\treadonly joinPoint: Function;\n}\n\nexport interface BeforeAdvice {\n\t/**\n\t * Advice which is applied *before*, receiving the original arguments, if the advising\n\t * function returns a value, it is passed further along taking the place of the original\n\t * arguments.\n\t *\n\t * @param args The arguments the method was called with\n\t */\n\t(...args: any[]): any[] | void;\n}\n\nexport interface AfterAdvice<T> {\n\t/**\n\t * Advice which is applied *after*, receiving the result and arguments from the join point.\n\t *\n\t * @param result The result from the function being advised\n\t * @param args The arguments that were supplied to the advised function\n\t * @returns The value returned from the advice is then the result of calling the method\n\t */\n\t(result: T, ...args: any[]): T;\n}\n\nexport interface AroundAdvice<T> {\n\t/**\n\t * Advice which is applied *around*.  The advising function receives the original function and\n\t * needs to return a new function which will then invoke the original function.\n\t *\n\t * @param origFn The original function\n\t * @returns A new function which will inoke the original function.\n\t */\n\t(origFn: GenericFunction<T>): (...args: any[]) => T;\n}\n\n/**\n * Types of advice\n */\nexport enum AdviceType { Before, After, Around };\n\n/**\n * A weak map of dispatchers used to apply the advice\n */\nconst dispatchAdviceMap = new WeakMap<Function, DispatchAdvice<any>>();\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n *\n * @param joinPoint The function that is to be advised\n */\nfunction getDispatcher<F extends GenericFunction<T>, T>(joinPoint: F): F {\n\n\tfunction dispatcher(this: Function, ...args: any[]): T {\n\t\tconst { before, after, joinPoint } = dispatchAdviceMap.get(dispatcher);\n\t\tif (before) {\n\t\t\targs = before.reduce((previousArgs, advice) => {\n\t\t\t\tconst currentArgs = advice.apply(this, previousArgs);\n\t\t\t\treturn currentArgs || previousArgs;\n\t\t\t}, args);\n\t\t}\n\t\tlet result = joinPoint.apply(this, args);\n\t\tif (after) {\n\t\t\tresult = after.reduce((previousResult, advice) => {\n\t\t\t\treturn advice.apply(this, [ previousResult ].concat(args));\n\t\t\t}, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* We want to \"clone\" the advice that has been applied already, if this\n\t * joinPoint is already advised */\n\tif (dispatchAdviceMap.has(joinPoint)) {\n\t\tconst adviceMap = dispatchAdviceMap.get(joinPoint);\n\t\tlet { before, after } = adviceMap;\n\t\tif (before) {\n\t\t\tbefore = before.slice(0);\n\t\t}\n\t\tif (after) {\n\t\t\tafter = after.slice(0);\n\t\t}\n\t\tdispatchAdviceMap.set(dispatcher, {\n\t\t\tjoinPoint: adviceMap.joinPoint,\n\t\t\tbefore,\n\t\t\tafter\n\t\t});\n\t}\n\t/* Otherwise, this is a new joinPoint, so we will create the advice map afresh */\n\telse {\n\t\tdispatchAdviceMap.set(dispatcher, { joinPoint });\n\t}\n\n\treturn dispatcher as F;\n}\n\n/**\n * Advise a join point (function) with supplied advice\n *\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction advise<F extends GenericFunction<T>, T>(this: any, joinPoint: F, type: AdviceType, advice: BeforeAdvice | AfterAdvice<T> | AroundAdvice<T>): F {\n\tlet dispatcher: F;\n\tif (type === AdviceType.Around) {\n\t\tdispatcher = getDispatcher(advice.apply(this, [ joinPoint ]));\n\t}\n\telse {\n\t\tdispatcher = getDispatcher(joinPoint);\n\t\tconst adviceMap = dispatchAdviceMap.get(dispatcher);\n\t\tif (type === AdviceType.Before) {\n\t\t\t(adviceMap.before || (adviceMap.before = [])).unshift(<BeforeAdvice> advice);\n\t\t}\n\t\telse {\n\t\t\t(adviceMap.after || (adviceMap.after = [])).push(advice);\n\t\t}\n\t}\n\treturn dispatcher;\n}\n\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport function before<F extends GenericFunction<any>>(joinPoint: F, advice: BeforeAdvice): F {\n\treturn advise(joinPoint, AdviceType.Before, advice);\n}\n\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nexport function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: AfterAdvice<T>): F {\n\treturn advise(joinPoint, AdviceType.After, advice);\n}\n\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: AroundAdvice<T>): F {\n\treturn advise<F, T>(joinPoint, AdviceType.Around, advice);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/aspect.ts","import { Hash } from 'dojo-interfaces/core';\nimport { duplicate } from './lang';\n\n/**\n * Object with string keys and string or string array values that describes a query string.\n */\nexport type ParamList = Hash<string | string[]>;\n\n/**\n * Parses a query string, returning a ParamList object.\n */\nfunction parseQueryString(input: string): ParamList {\n\tconst query: Hash<string[]> = {};\n\tfor (const entry of input.split('&')) {\n\t\tconst indexOfFirstEquals = entry.indexOf('=');\n\t\tlet key: string;\n\t\tlet value = '';\n\n\t\tif (indexOfFirstEquals >= 0) {\n\t\t\tkey = entry.slice(0, indexOfFirstEquals);\n\t\t\tvalue = entry.slice(indexOfFirstEquals + 1);\n\t\t} else {\n\t\t\tkey = entry;\n\t\t}\n\n\t\tkey = key ? decodeURIComponent(key) : '';\n\t\tvalue = value ? decodeURIComponent(value) : '';\n\n\t\tif (key in query) {\n\t\t\tquery[key].push(value);\n\t\t}\n\t\telse {\n\t\t\tquery[key] = [ value ];\n\t\t}\n\t}\n\treturn query;\n}\n\n/**\n * Represents a set of URL query search parameters.\n */\nexport default class UrlSearchParams {\n\t/**\n\t * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t * UrlSearchParams.\n\t */\n\tconstructor(input?: string | ParamList | UrlSearchParams) {\n\t\tlet list: ParamList;\n\n\t\tif (input instanceof UrlSearchParams) {\n\t\t\t// Copy the incoming UrlSearchParam's internal list\n\t\t\tlist = <ParamList> duplicate(input._list);\n\t\t}\n\t\telse if (typeof input === 'object') {\n\t\t\t// Copy the incoming object, assuming its property values are either arrays or strings\n\t\t\tlist = {};\n\t\t\tfor (const key in input) {\n\t\t\t\tconst value = (<ParamList> input)[key];\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tlist[key] = value.length ? value.slice() : [ '' ];\n\t\t\t\t}\n\t\t\t\telse if (value == null) {\n\t\t\t\t\tlist[key] = [ '' ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlist[key] = [ <string> value ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof input === 'string') {\n\t\t\t// Parse the incoming string as a query string\n\t\t\tlist = parseQueryString(input);\n\t\t}\n\t\telse {\n\t\t\tlist = {};\n\t\t}\n\n\t\tObject.defineProperty(this, '_list', { value: list });\n\t}\n\n\t/**\n\t * Maps property keys to arrays of values. The value for any property that has been set will be an array containing\n\t * at least one item. Properties that have been deleted will have a value of 'undefined'.\n\t */\n\tprotected _list: Hash<string[] | undefined>;\n\n\t/**\n\t * Appends a new value to the set of values for a key.\n\t * @param key The key to add a value for\n\t * @param value The value to add\n\t */\n\tappend(key: string, value: string): void {\n\t\tif (!this.has(key)) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t\telse {\n\t\t\tconst values = this._list[key];\n\t\t\tif (values) {\n\t\t\t\tvalues.push(value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Deletes all values for a key.\n\t * @param key The key whose values are to be removed\n\t */\n\tdelete(key: string): void {\n\t\t// Set to undefined rather than deleting the key, for better consistency across browsers.\n\t\t// If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t\t// its original position.  This approach maintains the original position everywhere.\n\t\tthis._list[key] = undefined;\n\t}\n\n\t/**\n\t * Returns the first value associated with a key.\n\t * @param key The key to return the first value for\n\t * @return The first string value for the key\n\t */\n\tget(key: string): string | undefined {\n\t\tif (!this.has(key)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst value = this._list[key];\n\t\treturn value ? value[0] : undefined;\n\t}\n\n\t/**\n\t * Returns all the values associated with a key.\n\t * @param key The key to return all values for\n\t * @return An array of strings containing all values for the key\n\t */\n\tgetAll(key: string): string[] | undefined {\n\t\tif (!this.has(key)) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._list[key];\n\t}\n\n\t/**\n\t * Returns true if a key has been set to any value, false otherwise.\n\t * @param key The key to test for existence\n\t * @return A boolean indicating if the key has been set\n\t */\n\thas(key: string): boolean {\n\t\treturn Array.isArray(this._list[key]);\n\t}\n\n\t/**\n\t * Returns an array of all keys which have been set.\n\t * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t */\n\tkeys(): string[] {\n\t\tconst keys: string[] = [];\n\n\t\tfor (const key in this._list) {\n\t\t\tif (this.has(key)) {\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\t/**\n\t * Sets the value associated with a key.\n\t * @param key The key to set the value of\n\t */\n\tset(key: string, value: string): void {\n\t\tthis._list[key] = [ value ];\n\t}\n\n\t/**\n\t * Returns this object's data as an encoded query string.\n\t * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t */\n\ttoString(): string {\n\t\tconst query: string[] = [];\n\n\t\tfor (const key in this._list) {\n\t\t\tif (!this.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst values = this._list[key];\n\t\t\tif (values) {\n\t\t\t\tconst encodedKey = encodeURIComponent(key);\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tquery.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn query.join('&');\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/UrlSearchParams.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, {\n\tEvented,\n\tEventedOptions,\n\tEventedListener,\n\tTargettedEventObject\n} from 'dojo-compose/mixins/createEvented';\nimport { Handle, Hash } from 'dojo-core/interfaces';\nimport Task from 'dojo-core/async/Task';\nimport { pausable, PausableHandle } from 'dojo-core/on';\nimport UrlSearchParams from 'dojo-core/UrlSearchParams';\nimport { includes } from 'dojo-shim/array';\nimport { Thenable } from 'dojo-shim/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\n\nimport { Route, SearchParams, Selection } from './createRoute';\nimport { Context, Parameters, Request } from './interfaces';\nimport { History, HistoryChangeEvent } from './history/interfaces';\nimport { isNamedSegment, parse as parsePath } from './lib/path';\n\n/**\n * An object to resume or cancel router dispatch.\n */\nexport interface DispatchDeferral {\n\t/**\n\t * Call to prevent a path from being dispatched.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * Call to resume a path being dispatched.\n\t */\n\tresume(): void;\n}\n\n/**\n * Event object that is emitted for the 'navstart' event.\n */\nexport interface NavigationStartEvent extends TargettedEventObject {\n\t/**\n\t * The path that has been navigated to.\n\t */\n\tpath: string;\n\n\t/**\n\t * Call to prevent the path to be dispatched.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * Call to defer dispatching of the path\n\t * @return an object which allows the caller to resume or cancel dispatch.\n\t */\n\tdefer(): DispatchDeferral;\n\n\t/**\n\t * The router that emitted this event.\n\t */\n\ttarget: Router<Context>;\n}\n\n/**\n * Event object that is emitted for the 'error' event.\n */\nexport interface ErrorEvent<C extends Context> extends TargettedEventObject {\n\t/**\n\t * The context that was being dispatched when the error occurred.\n\t */\n\tcontext: C;\n\n\t/**\n\t * The error.\n\t */\n\terror: any;\n\n\t/**\n\t * The path that was being dispatched when the error occurred.\n\t */\n\tpath: string;\n\n\t/**\n\t * The router that emitted this event.\n\t */\n\ttarget: Router<C>;\n}\n\n/**\n * Describes the result of a dispatch.\n */\nexport interface DispatchResult {\n\t/**\n\t * Whether a route requested a redirect to a different path.\n\t */\n\tredirect?: string;\n\n\t/**\n\t * False if dispatch was canceled (via the navstart event) or if no routes could be selected. True otherwise.\n\t */\n\tsuccess: boolean;\n}\n\nexport type LinkParams = Hash<string | string[] | undefined>;\n\n/**\n * A router mixin.\n */\nexport interface RouterMixin<C extends Context> {\n\t/**\n\t * Append one or more routes.\n\t *\n\t * A route can only appended to another route, or a router itself, once.\n\t *\n\t * @param routes A single route or an array containing 0 or more routes.\n\t */\n\tappend(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;\n\n\t/**\n\t * Select and execute routes for a given path.\n\t * @param context A context object that is provided when executing selected routes.\n\t * @param path The path.\n\t */\n\tdispatch(context: C, path: string): Task<DispatchResult>;\n\n\t/**\n\t * Generate a link for the route.\n\t *\n\t * Route hierarchies may require parameters to be present. Parameters are automatically derived from the currently\n\t * selected routes. Errors are thrown if parameters are missing or if the route is not in this router's hierarchy.\n\t *\n\t * @\n\t */\n\tlink(route: Route<Context, Parameters>, params?: LinkParams): string;\n\n\t/**\n\t * Start the router.\n\t *\n\t * Observes the history manager provided when the router was created for change events and dispatches routes in\n\t * response. Noop if no history manager was provided.\n\t *\n\t * @param options An optional options object, can be used to prevent the router from immediately dispatching.\n\t */\n\tstart(options?: StartOptions): PausableHandle;\n}\n\nexport interface RouterOverrides<C extends Context> {\n\t/**\n\t * Event emitted when dispatch is called, but before routes are selected.\n\t */\n\ton(type: 'navstart', listener: EventedListener<NavigationStartEvent>): Handle;\n\n\t/**\n\t * Event emitted when errors occur during dispatch.\n\t *\n\t * Certain errors may reject the task returned when dispatching, but this task is not always accessible and may\n\t * hide errors if it's canceled.\n\t */\n\ton(type: 'error', listener: EventedListener<ErrorEvent<C>>): Handle;\n\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type Router<C extends Context> = Evented & RouterMixin<C> & RouterOverrides<C>;\n\n/**\n * The options for the router.\n */\nexport interface RouterOptions<C extends Context> extends EventedOptions {\n\t/**\n\t * A Context object to be used for all requests, or a function that provides such an object, called for each\n\t * dispatch.\n\t */\n\tcontext?: C | (() => C);\n\n\t/**\n\t * A handler called when no routes match the dispatch path.\n\t * @param request An object whose `context` property contains the dispatch context. No extracted parameters\n\t *   are available.\n\t */\n\tfallback?: (request: Request<C, Parameters>) => void | Thenable<any>;\n\n\t/**\n\t * The history manager. Routes will be dispatched in response to change events emitted by the manager.\n\t */\n\thistory?: History;\n}\n\n/**\n * The options for the router's start() method.\n */\nexport interface StartOptions {\n\t/**\n\t * Whether to immediately dispatch with the history's current value.\n\t */\n\tdispatchCurrent: boolean;\n}\n\nexport interface RouterFactory<C extends Context> extends ComposeFactory<Router<C>, RouterOptions<C>> {\n\t/**\n\t * Create a new instance of a Router.\n\t * @param options Options to use during creation.\n\t */\n\t(options?: RouterOptions<Context>): Router<Context>;\n\t<C>(options?: RouterOptions<C>): Router<C>;\n}\n\nconst parentMap = new WeakMap<Route<Context, Parameters>, Router<Context>>();\nexport function hasBeenAppended(route: Route<Context, Parameters>): boolean {\n\treturn parentMap.has(route) || route.parent !== undefined;\n}\n\ninterface PrivateState {\n\tcontextFactory: () => Context;\n\tcurrentSelection: Selection[];\n\tdispatchFromStart: boolean;\n\tfallback?: (request: Request<Context, Parameters>) => void | Thenable<any>;\n\thistory?: History;\n\troutes: Route<Context, Parameters>[];\n\tstarted?: boolean;\n}\n\nconst privateStateMap = new WeakMap<Router<Context>, PrivateState>();\n\n// istanbul ignore next\nconst noop = () => {};\n\nfunction createDeferral() {\n\t// Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\tlet cancel: () => void = noop;\n\tlet resume: () => void = noop;\n\tconst promise = new Promise<void>((resolve, reject) => {\n\t\tcancel = reject;\n\t\t// Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t\tresume = () => resolve();\n\t});\n\treturn { cancel, promise, resume };\n}\n\nfunction reportError(router: Router<Context>, context: Context, path: string, error: any) {\n\trouter.emit<ErrorEvent<Context>>({\n\t\tcontext,\n\t\terror,\n\t\tpath,\n\t\ttarget: router,\n\t\ttype: 'error'\n\t});\n}\n\nfunction catchRejection(router: Router<Context>, context: Context, path: string, thenable: void | Thenable<any>) {\n\tif (thenable) {\n\t\tPromise.resolve(thenable).catch((error) => {\n\t\t\treportError(router, context, path, error);\n\t\t});\n\t}\n}\n\nconst createRouter: RouterFactory<Context> = compose.mixin(createEvented, {\n\tmixin: {\n\t\tappend(this: Router<Context>, add: Route<Context, Parameters> | Route<Context, Parameters>[]) {\n\t\t\tconst { routes } = privateStateMap.get(this);\n\t\t\tconst append = (route: Route<Context, Parameters>) => {\n\t\t\t\tif (hasBeenAppended(route)) {\n\t\t\t\t\tthrow new Error('Cannot append route that has already been appended');\n\t\t\t\t}\n\n\t\t\t\troutes.push(route);\n\t\t\t\tparentMap.set(route, this);\n\t\t\t};\n\n\t\t\tif (Array.isArray(add)) {\n\t\t\t\tfor (const route of add) {\n\t\t\t\t\tappend(route);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tappend(add);\n\t\t\t}\n\t\t},\n\n\t\tdispatch(this: Router<Context>, context: Context, path: string): Task<DispatchResult> {\n\t\t\tconst state = privateStateMap.get(this);\n\t\t\tconst { dispatchFromStart } = state;\n\t\t\t// Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t\t\t// may call dispatch() themselves.\n\t\t\tstate.dispatchFromStart = false;\n\n\t\t\tlet canceled = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tcanceled = true;\n\t\t\t};\n\n\t\t\tconst deferrals: Promise<void>[] = [];\n\n\t\t\tthis.emit<NavigationStartEvent>({\n\t\t\t\tcancel,\n\t\t\t\tdefer () {\n\t\t\t\t\tconst { cancel, promise, resume } = createDeferral();\n\t\t\t\t\tdeferrals.push(promise);\n\t\t\t\t\treturn { cancel, resume };\n\t\t\t\t},\n\t\t\t\tpath,\n\t\t\t\ttarget: this,\n\t\t\t\ttype: 'navstart'\n\t\t\t});\n\n\t\t\t// Synchronous cancelation.\n\t\t\tif (canceled) {\n\t\t\t\treturn Task.resolve({ success: false });\n\t\t\t}\n\n\t\t\tconst { searchParams, segments, trailingSlash } = parsePath(path);\n\t\t\treturn new Task<DispatchResult>((resolve, reject) => {\n\t\t\t\t// *Always* start dispatching in a future turn, even if there were no deferrals.\n\t\t\t\tPromise.all(deferrals).then<DispatchResult>(\n\t\t\t\t\t() => {\n\t\t\t\t\t\t// The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t\t\t\t\t\t// Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t\t\t\t\t\t// manages to do so before this turn.\n\t\t\t\t\t\tif (canceled) {\n\t\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { fallback, routes } = state;\n\t\t\t\t\t\tlet redirect: undefined | string;\n\t\t\t\t\t\tconst dispatched = routes.some((route) => {\n\t\t\t\t\t\t\tconst result = route.select(context, segments, trailingSlash, searchParams);\n\n\t\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\t\tredirect = result;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.length === 0) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update the selected routes after selecting new routes, but before invoking the handlers.\n\t\t\t\t\t\t\t// This means the original value is available to guard() and params() functions, and the\n\t\t\t\t\t\t\t// new value when the newly selected routes are executed.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Reset selected routes if not dispatched from start().\n\t\t\t\t\t\t\tstate.currentSelection = dispatchFromStart ? result : [];\n\n\t\t\t\t\t\t\tfor (const { handler, params } of result) {\n\t\t\t\t\t\t\t\tcatchRejection(this, context, path, handler({ context, params }));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t\t\t\t\t\tif (!dispatched || redirect !== undefined) {\n\t\t\t\t\t\t\tstate.currentSelection = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dispatched && fallback) {\n\t\t\t\t\t\t\tcatchRejection(this, context, path, fallback({ context, params: {} }));\n\t\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result: DispatchResult = { success: dispatched };\n\t\t\t\t\t\tif (redirect !== undefined) {\n\t\t\t\t\t\t\tresult.redirect = redirect;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t\t// When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t\t\t\t\t// with `false` instead of being rejected too.\n\t\t\t\t\t() => {\n\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t}\n\t\t\t\t).then(resolve, (error) => {\n\t\t\t\t\treportError(this, context, path, error);\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t\t}, cancel);\n\t\t},\n\n\t\tlink(this: Router<Context>, route: Route<Context, Parameters>, params: LinkParams = {}): string {\n\t\t\tconst { history, routes: roots, currentSelection } = privateStateMap.get(this);\n\n\t\t\tconst hierarchy = [ route ];\n\t\t\tfor (let parent = route.parent; parent !== undefined; parent = parent.parent) {\n\t\t\t\thierarchy.unshift(parent);\n\t\t\t}\n\n\t\t\tif (!includes(roots, hierarchy[0])) {\n\t\t\t\tthrow new Error('Cannot generate link for route that is not in the hierarchy');\n\t\t\t}\n\n\t\t\tconst { leadingSlash: addLeadingSlash } = hierarchy[0].path;\n\t\t\tlet addTrailingSlash = false;\n\t\t\tconst segments: string[] = [];\n\t\t\tconst searchParams = new UrlSearchParams();\n\n\t\t\thierarchy\n\t\t\t\t.map((route, index) => {\n\t\t\t\t\tconst { path } = route;\n\t\t\t\t\tlet currentPathValues: string[] | undefined;\n\t\t\t\t\tlet currentSearchParams: SearchParams | undefined;\n\n\t\t\t\t\tconst selection = currentSelection[index];\n\t\t\t\t\tif (selection && selection.route === route) {\n\t\t\t\t\t\tcurrentPathValues = selection.rawPathValues;\n\t\t\t\t\t\tcurrentSearchParams = selection.rawSearchParams;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { currentPathValues, currentSearchParams, path };\n\t\t\t\t})\n\t\t\t\t.forEach(({ currentPathValues, currentSearchParams, path }) => {\n\t\t\t\t\tconst { expectedSegments, searchParameters, trailingSlash } = path;\n\t\t\t\t\taddTrailingSlash = trailingSlash;\n\n\t\t\t\t\tlet namedOffset = 0;\n\t\t\t\t\tfor (const segment of expectedSegments) {\n\t\t\t\t\t\tif (isNamedSegment(segment)) {\n\t\t\t\t\t\t\tconst value = params[segment.name];\n\t\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\t\tsegments.push(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (Array.isArray(value)) {\n\t\t\t\t\t\t\t\tif (value.length === 1) {\n\t\t\t\t\t\t\t\t\tsegments.push(value[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(`Cannot generate link, multiple values for parameter '${segment.name}'`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (currentPathValues) {\n\t\t\t\t\t\t\t\tsegments.push(currentPathValues[namedOffset]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new Error(`Cannot generate link, missing parameter '${segment.name}'`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnamedOffset++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsegments.push(segment.literal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const key of searchParameters) {\n\t\t\t\t\t\t// Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t\t\t\t\t\t// it.\n\t\t\t\t\t\tif (searchParams.has(key)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = params[key];\n\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\tsearchParams.append(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (Array.isArray(value)) {\n\t\t\t\t\t\t\tfor (const item of value) {\n\t\t\t\t\t\t\t\tsearchParams.append(key, item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (currentSearchParams) {\n\t\t\t\t\t\t\tfor (const item of currentSearchParams[key]) {\n\t\t\t\t\t\t\t\tsearchParams.append(key, item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(`Cannot generate link, missing search parameter '${key}'`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tlet pathname = segments.join('/');\n\t\t\tif (addLeadingSlash) {\n\t\t\t\tpathname = '/' + pathname;\n\t\t\t}\n\t\t\tif (addTrailingSlash) {\n\t\t\t\tpathname += '/';\n\t\t\t}\n\t\t\tif (history) {\n\t\t\t\tpathname = history.prefix(pathname);\n\t\t\t}\n\n\t\t\tconst search = searchParams.toString();\n\t\t\tconst path = search ? `${pathname}?${search}` : pathname;\n\n\t\t\treturn path;\n\t\t},\n\n\t\tstart(this: Router<Context>, { dispatchCurrent }: StartOptions = { dispatchCurrent: true }): PausableHandle {\n\t\t\tconst state = privateStateMap.get(this);\n\t\t\tif (state.started) {\n\t\t\t\tthrow new Error('start can only be called once');\n\t\t\t}\n\t\t\tstate.started = true;\n\n\t\t\tconst { contextFactory, history } = state;\n\t\t\tif (!history) {\n\t\t\t\treturn {\n\t\t\t\t\tpause() {},\n\t\t\t\t\tresume() {},\n\t\t\t\t\tdestroy() {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlet lastDispatch: Task<void>;\n\t\t\tlet redirectCount = 0;\n\t\t\tlet redirecting = false;\n\n\t\t\tconst dispatch = (path: string) => {\n\t\t\t\tif (lastDispatch) {\n\t\t\t\t\tlastDispatch.cancel();\n\t\t\t\t}\n\n\t\t\t\t// Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t\t\t\t// a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t\t\t\t// redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t\t\t\tif (!redirecting) {\n\t\t\t\t\tredirectCount = 0;\n\t\t\t\t}\n\n\t\t\t\t// Signal to dispatch() that it was called from here.\n\t\t\t\tstate.dispatchFromStart = true;\n\n\t\t\t\tconst context = contextFactory();\n\t\t\t\tlastDispatch = this.dispatch(context, path).then(({ redirect, success }) => {\n\t\t\t\t\tif (success && redirect !== undefined) {\n\t\t\t\t\t\tredirectCount++;\n\t\t\t\t\t\tif (redirectCount > 20) {\n\t\t\t\t\t\t\tconst error = new Error('More than 20 redirects, giving up');\n\t\t\t\t\t\t\treportError(this, context, path, error);\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tredirecting = true;\n\t\t\t\t\t\t// The history manager MUST emit the change event synchronously.\n\t\t\t\t\t\thistory.replace(redirect);\n\t\t\t\t\t\tredirecting = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tconst listener = pausable(history, 'change', (event: HistoryChangeEvent) => {\n\t\t\t\tdispatch(event.value);\n\t\t\t});\n\t\t\tthis.own(listener);\n\n\t\t\tif (dispatchCurrent) {\n\t\t\t\tdispatch(history.current);\n\t\t\t}\n\n\t\t\treturn listener;\n\t\t}\n\t},\n\tinitialize<C extends Context>(instance: Router<C>, { context, fallback, history }: RouterOptions<C> = {}) {\n\t\tlet contextFactory: () => C;\n\t\tif (typeof context === 'function') {\n\t\t\tcontextFactory = context;\n\t\t}\n\t\telse if (typeof context === 'undefined') {\n\t\t\tcontextFactory = () => {\n\t\t\t\treturn {} as C;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\t// Assign to a constant since the context variable may be changed after the function is defined,\n\t\t\t// which would violate its typing.\n\t\t\tconst sharedContext = context;\n\t\t\tcontextFactory = () => sharedContext;\n\t\t}\n\n\t\tif (history) {\n\t\t\tinstance.own(history);\n\t\t}\n\n\t\tprivateStateMap.set(instance, {\n\t\t\tcontextFactory,\n\t\t\tcurrentSelection: [],\n\t\t\tdispatchFromStart: false,\n\t\t\tfallback,\n\t\t\thistory,\n\t\t\troutes: []\n\t\t});\n\t}\n});\n\nexport default createRouter;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/createRouter.ts","import { on } from 'dojo-core/aspect';\nimport { EventObject, Handle } from 'dojo-core/interfaces';\nimport Map from 'dojo-shim/Map';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\nimport createDestroyable, { Destroyable } from './createDestroyable';\n\nexport interface TargettedEventObject extends EventObject {\n\t/**\n\t * The target of the event\n\t */\n\ttarget: any;\n}\n\nexport interface ActionableOptions<E extends TargettedEventObject> {\n\t[ option: string ]: any;\n\t/**\n\t * An event object\n\t */\n\tevent?: E;\n}\n\nexport interface Actionable<E extends TargettedEventObject> {\n\t/**\n\t * The *do* method of an Action, which can take a `options` property of an `event`\n\t *\n\t * @param options Options passed which includes an `event` object\n\t */\n\tdo(options?: ActionableOptions<E>): any;\n}\n\nexport interface EventedCallback<E extends EventObject> {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\t(event: E): boolean | void;\n}\n\n/**\n * Either an `EventedCallback` or something that is `Actionable`\n */\nexport type EventedListener<E extends TargettedEventObject> = EventedCallback<E> | Actionable<E>;\n\n/**\n * Either a single `EventedListener` or an array\n */\nexport type EventedListenerOrArray<E extends TargettedEventObject> = EventedListener<E> | EventedListener<E>[];\n\n/**\n * A map of listeners where the key is the event `type`\n */\nexport interface EventedListenersMap {\n\t[type: string]: EventedListenerOrArray<TargettedEventObject>;\n}\n\n/**\n * A map of callbacks where the key is the event `type`\n */\ntype EventedCallbackMap = Map<string, EventedCallback<EventObject>>;\n\nexport interface EventedOptions {\n\t/**\n\t * Any listeners that should be attached during construction\n\t */\n\tlisteners?: EventedListenersMap;\n}\n\nexport interface EventedMixin {\n\t/**\n\t * Emit an event.\n\t *\n\t * The event is determined by the `event.type`, if there are no listeners for an event type,\n\t * `emit` is essentially a noop.\n\t *\n\t * @param event The `EventObject` to be delivered to listeners based on `event.type`\n\t */\n\temit<E extends EventObject>(event: E): void;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listener Either a function which takes an emitted `event` object, something that is `Actionable`,\n\t *                 or an array of of such listeners.\n\t * @returns A handle which can be used to remove the listener\n\t */\n\ton(type: string, listener: EventedListenerOrArray<TargettedEventObject>): Handle;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listeners An object which contains key value pairs of event types and listeners.\n\t */\n\ton(listeners: EventedListenersMap): Handle;\n}\n\nexport type Evented = EventedMixin & Destroyable;\n\nexport interface EventedFactory extends ComposeFactory<Evented, EventedOptions> { }\n\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nconst listenersMap = new WeakMap<Evented, EventedCallbackMap>();\n\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable(value: any): value is Actionable<any> {\n\treturn Boolean(value && typeof value.do === 'function');\n}\n\n/**\n * An internal function that always returns an EventedCallback\n *\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nexport function resolveListener<E extends TargettedEventObject>(listener: EventedListener<E>): EventedCallback<E> {\n\treturn isActionable(listener) ? (event: E) => listener.do({ event }) : listener;\n}\n\n/**\n * Internal function to convert an array of handles to a single handle\n *\n * @param handles The array of handles to convert into a signle handle\n * @return The single handle\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * Creates a new instance of an `Evented`\n */\nconst createEvented: EventedFactory = compose<EventedMixin, EventedOptions>({\n\t\temit<E extends EventObject>(this: Evented, event: E): void {\n\t\t\tconst method = listenersMap.get(this).get(event.type);\n\t\t\tif (method) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t},\n\n\t\ton(this: Evented, ...args: any[]): Handle {\n\t\t\tconst listenerMap = listenersMap.get(this);\n\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\tconst [ type, listeners ] = <[ string, EventedListenerOrArray<TargettedEventObject>]> args;\n\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\tconst handles = listeners.map((listener) => on(listenerMap, type, resolveListener(listener)));\n\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn on(listenerMap, type, resolveListener(listeners));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\tconst [ listenerMapArg ] = <[EventedListenersMap]> args;\n\t\t\t\tconst handles = Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type]));\n\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t}\n\t\t\telse { /* unexpected signature */\n\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tclassName: 'Evented',\n\t\tmixin: createDestroyable,\n\t\tinitialize(instance, options) {\n\t\t\t/* Initialise listener map */\n\t\t\tlistenersMap.set(instance, new Map<string, EventedCallback<EventObject>>());\n\n\t\t\tif (options && options.listeners) {\n\t\t\t\tinstance.own(instance.on(options.listeners));\n\t\t\t}\n\t\t}\n\t});\n\nexport default createEvented;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createEvented.ts","import { Handle } from 'dojo-interfaces/core';\nimport { createHandle } from './lang';\n\n/**\n * An object that provides the necessary APIs to be MapLike\n */\nexport interface MapLike<K, V> {\n\tget(key: K): V;\n\tset(key: K, value?: V): this;\n}\n\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value: any): value is MapLike<any, any> {\n\treturn value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n\nexport interface Indexable {\n\t[method: string]: any;\n}\n\n/**\n * The types of objects or maps where advice can be applied\n */\nexport type Targetable = MapLike<string, any> | Indexable;\n\ntype AdviceType = 'before' | 'after';\n\n/**\n * A meta data structure when applying advice\n */\ninterface Advised {\n\tid?: number;\n\tadvice?: Function;\n\tprevious?: Advised;\n\tnext?: Advised;\n\treceiveArguments?: boolean;\n}\n\n/**\n * A function that dispatches advice which is decorated with additional\n * meta data about the advice to apply\n */\ninterface Dispatcher {\n\t[ type: string ]: Advised | undefined;\n\t(): any;\n\ttarget: any;\n\tbefore?: Advised;\n\taround?: Advised;\n\tafter?: Advised;\n}\n\n/**\n * A UID for tracking advice ordering\n */\nlet nextId = 0;\n\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction advise(\n\tdispatcher: Dispatcher | undefined,\n\ttype: AdviceType,\n\tadvice: Function | undefined,\n\treceiveArguments?: boolean\n): Handle {\n\tlet previous = dispatcher && dispatcher[type];\n\tlet advised: Advised | undefined = {\n\t\tid: nextId++,\n\t\tadvice: advice,\n\t\treceiveArguments: receiveArguments\n\t};\n\n\tif (previous) {\n\t\tif (type === 'after') {\n\t\t\t// add the listener to the end of the list\n\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\twhile (previous.next && (previous = previous.next)) {}\n\t\t\tprevious.next = advised;\n\t\t\tadvised.previous = previous;\n\t\t}\n\t\telse {\n\t\t\t// add to the beginning\n\t\t\tif (dispatcher) {\n\t\t\t\tdispatcher.before = advised;\n\t\t\t}\n\t\t\tadvised.next = previous;\n\t\t\tprevious.previous = advised;\n\t\t}\n\t}\n\telse {\n\t\tdispatcher && (dispatcher[type] = advised);\n\t}\n\n\tadvice = previous = undefined;\n\n\treturn createHandle(function () {\n\t\tlet { previous = undefined, next = undefined } = (advised || {});\n\n\t\tif (dispatcher && !previous && !next) {\n\t\t\tdispatcher[type] = undefined;\n\t\t}\n\t\telse {\n\t\t\tif (previous) {\n\t\t\t\tprevious.next = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdispatcher && (dispatcher[type] = next);\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tnext.previous = previous;\n\t\t\t}\n\t\t}\n\t\tif (advised) {\n\t\t\tdelete advised.advice;\n\t\t}\n\t\tdispatcher = advised = undefined;\n\t});\n}\n\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcher(target: Targetable, methodName: string): Dispatcher {\n\tconst existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\tlet dispatcher: Dispatcher;\n\n\tif (!existing || existing.target !== target) {\n\t\t/* There is no existing dispatcher, therefore we will create one */\n\t\tdispatcher = <Dispatcher> function (this: Dispatcher): any {\n\t\t\tlet executionId = nextId;\n\t\t\tlet args = arguments;\n\t\t\tlet results: any;\n\t\t\tlet before = dispatcher.before;\n\n\t\t\twhile (before) {\n\t\t\t\tif (before.advice) {\n\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t}\n\t\t\t\tbefore = before.next;\n\t\t\t}\n\n\t\t\tif (dispatcher.around && dispatcher.around.advice) {\n\t\t\t\tresults = dispatcher.around.advice(this, args);\n\t\t\t}\n\n\t\t\tlet after = dispatcher.after;\n\t\t\twhile (after && after.id < executionId) {\n\t\t\t\tif (after.advice) {\n\t\t\t\t\tif (after.receiveArguments) {\n\t\t\t\t\t\tlet newResults = after.advice.apply(this, args);\n\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tafter = after.next;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\n\t\tif (isMapLike(target)) {\n\t\t\ttarget.set(methodName, dispatcher);\n\t\t}\n\t\telse {\n\t\t\ttarget && (target[methodName] = dispatcher);\n\t\t}\n\n\t\tif (existing) {\n\t\t\tdispatcher.around = {\n\t\t\t\tadvice: function (target: any, args: any[]): any {\n\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdispatcher.target = target;\n\t}\n\telse {\n\t\tdispatcher = existing;\n\t}\n\n\treturn dispatcher;\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function after(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice);\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function around(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle {\n\tlet dispatcher: Dispatcher | undefined = getDispatcher(target, methodName);\n\tlet previous = dispatcher.around;\n\tlet advised: Function | undefined;\n\tif (advice) {\n\t\tadvised = advice(function (this: Dispatcher): any {\n\t\t\tif (previous && previous.advice) {\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispatcher.around = {\n\t\tadvice: function (target: any, args: any[]): any {\n\t\t\treturn advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t\t}\n\t};\n\n\treturn createHandle(function () {\n\t\tadvised = dispatcher = undefined;\n\t});\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function before(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle {\n\treturn advise(getDispatcher(target, methodName), 'before', advice);\n}\n\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function on(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice, true);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/aspect.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, Iterable, IterableIterator, ShimIterator } from './iterator';\nimport { is as objectIs } from './object';\nimport './Symbol';\n\nexport namespace Shim {\n\t/**\n\t * An implementation analogous to the Map specification in ES2015.\n\t */\n\texport class Map<K, V> {\n\t\tprotected readonly _keys: K[] = [];\n\t\tprotected readonly _values: V[] = [];\n\n\t\t/**\n\t\t * An alternative to Array.prototype.indexOf using Object.is\n\t\t * to check for equality. See http://mzl.la/1zuKO2V\n\t\t */\n\t\tprotected _indexOfKey(keys: K[], key: K): number {\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tif (objectIs(keys[i], key)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t/**\n\t\t * Creates a new Map\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param iterator\n\t\t * Array or iterator containing two-item tuples used to initially populate the map.\n\t\t * The first item in each tuple corresponds to the key of the map entry.\n\t\t * The second item corresponds to the value of the map entry.\n\t\t */\n\t\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, (value: [K, V]) => {\n\t\t\t\t\tthis.set(value[0], value[1]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the number of key / value pairs in the Map.\n\t\t *\n\t\t * @return the number of key / value pairs in the Map\n\t\t */\n\t\tget size(): number {\n\t\t\treturn this._keys.length;\n\t\t}\n\n\t\t/**\n\t\t * Deletes all keys and their associated values.\n\t\t */\n\t\tclear(): void {\n\t\t\tthis._keys.length = this._values.length = 0;\n\t\t}\n\n\t\t/**\n\t\t * Deletes a given key and its associated value.\n\t\t *\n\t\t * @param key The key to delete\n\t\t * @return true if the key exists, false if it does not\n\t\t */\n\t\tdelete(key: K): boolean {\n\t\t\tconst index = this._indexOfKey(this._keys, key);\n\t\t\tif (index < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._keys.splice(index, 1);\n\t\t\tthis._values.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each key/value pair as an array.\n\t\t *\n\t\t * @return An iterator for each key/value pair in the instance.\n\t\t */\n\t\tentries(): IterableIterator<[K, V]> {\n\t\t\tconst values = this._keys.map((key: K, i: number): [K, V] => {\n\t\t\t\treturn [ key, this._values[i] ];\n\t\t\t});\n\n\t\t\treturn new ShimIterator<[K, V]>(values);\n\t\t}\n\n\t\t/**\n\t\t * Executes a given function for each map entry. The function\n\t\t * is invoked with three arguments: the element value, the\n\t\t * element key, and the associated Map instance.\n\t\t *\n\t\t * @param callback The function to execute for each map entry,\n\t\t * @param context The value to use for `this` for each execution of the calback\n\t\t */\n\t\tforEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}) {\n\t\t\tconst keys = this._keys;\n\t\t\tconst values = this._values;\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tcallback.call(context, values[i], keys[i], this);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the value associated with a given key.\n\t\t *\n\t\t * @param key The key to look up\n\t\t * @return The value if one exists or undefined\n\t\t */\n\t\tget(key: K): V | undefined {\n\t\t\tconst index = this._indexOfKey(this._keys, key);\n\t\t\treturn index < 0 ? undefined : this._values[index];\n\t\t}\n\n\t\t/**\n\t\t * Checks for the presence of a given key.\n\t\t *\n\t\t * @param key The key to check for\n\t\t * @return true if the key exists, false if it does not\n\t\t */\n\t\thas(key: K): boolean {\n\t\t\treturn this._indexOfKey(this._keys, key) > -1;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each key in the map.\n\t\t *\n\t\t * @return An iterator containing the instance's keys.\n\t\t */\n\t\tkeys(): IterableIterator<K> {\n\t\t\treturn new ShimIterator<K>(this._keys);\n\t\t}\n\n\t\t/**\n\t\t * Sets the value associated with a given key.\n\t\t *\n\t\t * @param key The key to define a value to\n\t\t * @param value The value to assign\n\t\t * @return The Map instance\n\t\t */\n\t\tset(key: K, value: V): Map<K, V> {\n\t\t\tlet index = this._indexOfKey(this._keys, key);\n\t\t\tindex = index < 0 ? this._keys.length : index;\n\t\t\tthis._keys[index] = key;\n\t\t\tthis._values[index] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each value in the map.\n\t\t *\n\t\t * @return An iterator containing the instance's values.\n\t\t */\n\t\tvalues(): IterableIterator<V> {\n\t\t\treturn new ShimIterator<V>(this._values);\n\t\t}\n\n\t\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\t\treturn this.entries();\n\t\t}\n\n\t\t[Symbol.toStringTag]: string = 'Map';\n\t}\n}\n\n@hasClass('es6-map', global.Map, Shim.Map)\nexport default class Map<K, V> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) { };\n\n\t/* istanbul ignore next */\n\tget size(): number { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tclear(): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tdelete(key: K): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tentries(): IterableIterator<[K, V]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tforEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tget(key: K): V | undefined { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\thas(key: K): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tkeys(): IterableIterator<K> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tset(key: K, value: V): Map<K, V> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tvalues(): IterableIterator<V> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.iterator](): IterableIterator<[K, V]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'Map';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Map.ts","import has from './support/has';\nimport { isSymbol } from './Symbol';\n\nnamespace Shim {\n\texport function is(value1: any, value2: any): boolean {\n\t\tif (value1 === value2) {\n\t\t\treturn value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t\t}\n\t\treturn value1 !== value1 && value2 !== value2; // NaN\n\t}\n\n\texport function getOwnPropertySymbols(o: any): symbol[] {\n\t\treturn Object.getOwnPropertyNames(o).filter((key) => Boolean(key.match(/^@@.+/)))\n\t\t\t.map((key) => Symbol.for(key.substring(2)));\n\t}\n\n\texport function getOwnPropertyNames(o: any): string[] {\n\t\treturn Object.getOwnPropertyNames(o).filter((key) => !Boolean(key.match(/^@@.+/)));\n\t}\n\n\texport function symbolAwareKeys(o: any): string[] {\n\t\treturn Object.keys(o).filter((key) => !Boolean(key.match(/^@@.+/)));\n\t}\n\n\texport function getOwnPropertyDescriptor(o: any, prop: string | symbol): PropertyDescriptor | undefined {\n\t\tif (isSymbol(prop)) {\n\t\t\treturn (<any> Object).getOwnPropertyDescriptor(o, prop);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyDescriptor(o, prop);\n\t\t}\n\t}\n\n\texport function values(o: any): any[] {\n\t\treturn keys(o).map(key => o[ key ]);\n\t}\n\n\texport function entries(o: any): any[] {\n\t\treturn keys(o).map(key => [ key, o[ key ] ]);\n\t}\n}\n\n/**\n * Determines whether two values are the same value.\n *\n * @param value1 The first value to compare\n * @param value2 The second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport const is: (value1: any, value2: any) => boolean = 'is' in Object\n\t? (<any> Object).is\n\t: Shim.is;\n\n/**\n * Detect if there is native support for Symbol properties in Object\n */\nconst hasGetOwnPropertySymbols = has('es6-symbol') && 'getOwnPropertySymbols' in Object;\n\n/**\n * Returns an array of own properties who key is a symbol\n *\n * @param o The object to return the properties for\n */\nexport const getOwnPropertySymbols: (o: any) => symbol[] = hasGetOwnPropertySymbols\n\t? (<any> Object).getOwnPropertySymbols\n\t: Shim.getOwnPropertySymbols;\n\n/**\n * Returns an array of own properties who key is a string\n *\n * @param o The object to return the properties for\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexport const getOwnPropertyNames: (o: any) => string[] = hasGetOwnPropertySymbols\n\t? Object.getOwnPropertyNames\n\t: Shim.getOwnPropertyNames;\n\n/**\n * Returns the names of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexport const keys: (o: any) => string[] = hasGetOwnPropertySymbols\n\t? Object.keys\n\t: Shim.symbolAwareKeys;\n\n/**\n * Returns the values of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods.\n */\nexport const values: (o: any) => any[] = 'values' in Object\n\t? (<any> Object).values\n\t: Shim.values;\n\n/**\n * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n * array holding the [key, value].\n * @param o Object that contains the properties and methods.\n */\nexport const entries: (o: any) => any[] = 'entries' in Object\n\t? (<any> Object).entries\n\t: Shim.entries;\n\nexport const getOwnPropertyDescriptor: (o: any, property: string | symbol) => PropertyDescriptor | undefined = hasGetOwnPropertySymbols\n\t? Object.getOwnPropertyDescriptor\n\t: Shim.getOwnPropertyDescriptor;\n\nfunction getOwnPropertyDescriptorsWrapper(o: any): any {\n\tlet descriptors: {[_: string]: PropertyDescriptor} = getOwnPropertyNames(o).reduce((descriptors: {[_: string]: PropertyDescriptor}, key: string) => {\n\t\tdescriptors[ key ] = <PropertyDescriptor> getOwnPropertyDescriptor(o, key);\n\t\treturn descriptors;\n\t}, {});\n\n\tgetOwnPropertySymbols(o).forEach((sym: symbol) => {\n\t\tdescriptors[ sym ] = <PropertyDescriptor> getOwnPropertyDescriptor(o, sym);\n\t});\n\n\treturn descriptors;\n}\n\n/* Return descriptors for enumerable and non enumerable properties on an object */\nexport const getOwnPropertyDescriptors: (o: any) => any = 'getOwnPropertyDescriptors' in Object\n\t? (<any> Object).getOwnPropertyDescriptors\n\t: getOwnPropertyDescriptorsWrapper;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/object.ts","import { Handle } from 'dojo-core/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\n\nexport interface DestroyableOptions { }\n\nexport interface Destroyable {\n\t/**\n\t * Take a handle and *own* it, which ensures that the handle's `destroy()` method is called when the\n\t * *owner* is destroyed.\n\t *\n\t * @param handle The handle to own\n\t * @returns A handle to *unown* the passed handle\n\t */\n\town(handle: Handle): Handle;\n\n\t/**\n\t * Invoke `destroy()` on any owned handles.\n\t *\n\t * @returns A promise that resolves to `true` if successful, otherwise `false`\n\t */\n\tdestroy(): Promise<boolean>;\n}\n\nexport interface DestroyableFactory extends ComposeFactory<Destroyable, DestroyableOptions> { }\n\n/**\n * A reference to a function that always returns a promise which resolves to false\n */\nfunction noop(): Promise<boolean> {\n\treturn Promise.resolve(false);\n};\n\n/**\n * A reference to a function that throws, used to replace the `own()` method after\n * destruction\n */\nfunction destroyed(): never {\n\tthrow new Error('Call made to destroyed method');\n};\n\n/**\n * A weak map for *owning* handles on instances\n */\nconst handlesWeakMap = new WeakMap<Destroyable, Handle[]>();\n\n/**\n * A type guard that determines if the value is a Destroyable\n *\n * @param value The value to guard for\n */\nexport function isDestroyable(value: any): value is Destroyable {\n\treturn Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n}\n\n/**\n * A mixin which adds the concepts of being able to *destroy* handles which the instance\n * *owns*\n */\nconst createDestroyable: DestroyableFactory = compose('Destroyable', {\n\town(this: Destroyable, handle: Handle): Handle {\n\t\tconst handles = handlesWeakMap.get(this);\n\t\thandles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\thandles.splice(handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tdestroy(this: Destroyable) {\n\t\treturn new Promise((resolve) => {\n\t\t\thandlesWeakMap.get(this).forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\tthis.destroy = noop;\n\t\t\tthis.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}, (instance) => {\n\thandlesWeakMap.set(instance, []);\n});\n\nexport default createDestroyable;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createDestroyable.ts","import { Thenable } from 'dojo-interfaces/shim';\nimport global from './support/global';\nimport { queueMicroTask } from './support/queue';\nimport { forOf, Iterable } from './iterator';\nimport './Symbol';\nimport { hasClass } from './support/decorators';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;\n}\n\nmodule Shim {\n\n\t/**\n\t * The State enum represents the possible states of a promise.\n\t */\n\texport const enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\texport function isThenable<T>(value: any): value is Thenable<T> {\n\t\treturn value && typeof value.then === 'function';\n\t}\n\n\t/**\n\t * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t * not intended to be used directly.\n\t *\n\t * @borrows Promise.all as Promise.all\n\t * @borrows Promise.race as Promise.race\n\t * @borrows Promise.reject as Promise.reject\n\t * @borrows Promise.resolve as Promise.resolve\n\t * @borrows Promise#catch as Promise#catch\n\t * @borrows Promise#then as Promise#then\n\t */\n\texport class Promise<T> implements Thenable<T> {\n\t\tstatic all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tconst values: T[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[ index ] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: (T | Thenable<T>)): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (isThenable(item)) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tforOf(iterable, function (value: T | Thenable<T>) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tforOf(iterable, function (item: T | Thenable<T>) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tstatic reject<T>(reason?: any): Promise<T> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function (resolve) {\n\t\t\t\tresolve(<T> value);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function (callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function (): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[ i ].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(\n\t\t\t\t\t\tsettle.bind(null, State.Fulfilled),\n\t\t\t\t\t\tsettle.bind(null, State.Rejected)\n\t\t\t\t\t);\n\t\t\t\t\tisChained = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <U>(onFulfilled?: (value?: T) => (U | Promise<U>),\n\t\t\t\t\t\t\tonRejected?: (reason?: any) => (U | Promise<U>)): Promise<U> => {\n\t\t\t\treturn new Promise<U>((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined = this.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\t(<Executor<T>> executor)(\n\t\t\t\t\tresolve.bind(null, State.Fulfilled),\n\t\t\t\t\tresolve.bind(null, State.Rejected)\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<U>(onRejected: (reason: any) => (U | Thenable<U>)): Promise<U> {\n\t\t\treturn this.then<U>(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|any}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <U>(onFulfilled?: (value: T) => (U | Thenable<U>), onRejected?: (reason: any) => (U | Thenable<U>)) => Promise<U>;\n\n\t\t[Symbol.toStringTag]: string = 'Promise';\n\t}\n}\n\n@hasClass('es6-promise', global.Promise, Shim.Promise)\nexport default class Promise<T> implements Thenable<T> {\n\t/**\n\t * Creates a new Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\t/* istanbul ignore next */\n\tconstructor(executor: Executor<T>) {\n\t}\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t *\n\t * @example\n\t * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t *     value[0] === 'foo'; // true\n\t *     value[1] === 'bar'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.all({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: 'bar'\n\t * }).then((value) => {\n\t *     value.foo === 'foo'; // true\n\t *     value.bar === 'bar'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\tthrow new Error();\n\t};\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t *\n\t * @example\n\t * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.race({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: Promise.resolve('bar')\n\t * }).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> |  (T | Thenable<T>)[]): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is rejected with the given error.\n\t */\n\t/* istanbul ignore next */\n\tstatic reject<T>(reason?: any): Promise<any> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is resolved with the given value.\n\t */\n\tstatic resolve(): Promise<void>;\n\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t/* istanbul ignore next */\n\tstatic resolve<T>(value?: any): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.\n\t */\n\tcatch<U>(onRejected: (reason: any) => (U | Thenable<U>)): Promise<U>;\n\t/* istanbul ignore next */\n\tcatch<U>(onRejected: (reason: any) => void): Promise<U> {\n\t\tthrow new Error();\n\t}\n\n\tthen<U>(onFulfilled?: (value: T) => U | Thenable<U> | undefined | null, onRejected?: (reason: any) => void): Promise<U>;\n\t/* istanbul ignore next */\n\tthen<U>(onFulfilled?: (value: T) => U | Thenable<U> | undefined | null, onRejected?: (reason: any) => (U | Thenable<U>)): Promise<U> {\n\t\tthrow new Error();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Promise.ts","import { Handle } from 'dojo-interfaces/core';\nimport global from './global';\nimport has from './has';\n\nexport interface QueueItem {\n\tisActive: boolean;\n\treadonly callback: (...args: any[]) => any;\n}\n\ninterface PostMessageEvent extends Event {\n\treadonly source: any;\n\treadonly data: string;\n}\n\n/**\n * Executes a task\n * @param item The task to execute\n */\nfunction executeTask(item: QueueItem | undefined): void {\n\tif (item && item.isActive) {\n\t\titem.callback();\n\t}\n}\n\n/**\n * Get a handle to be able to remove an item from the queue\n */\nfunction getQueueHandle(item: QueueItem | undefined, destructor?: (...args: any[]) => any): Handle {\n\treturn {\n\t\tdestroy: function (this: any) {\n\t\t\tthis.destroy = function () {};\n\t\t\tif (item) {\n\t\t\t\titem.isActive = false;\n\t\t\t}\n\t\t\tif (destructor) {\n\t\t\t\tdestructor();\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst microTasks: QueueItem[] = [];\nlet microTaskQueued = false;\nlet checkMicroTaskQueue: () => void = function () {};\n\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueTask = (function() {\n\tlet destructor: (...args: any[]) => any;\n\tlet enqueue: (item: QueueItem) => void;\n\n\t/* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\tif (has('postmessage')) {\n\t\tconst queue: QueueItem[] = [];\n\n\t\taddEventListener('message', function (event: PostMessageEvent): void {\n\t\t\t// Confirm that the event was triggered by the current window and by this particular implementation.\n\t\t\tif (event.source === global && event.data === 'dojo-queue-message') {\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\tif (queue.length) {\n\t\t\t\t\texecuteTask(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tpostMessage('dojo-queue-message', '*');\n\t\t};\n\t}\n\telse if (has('setimmediate')) {\n\t\tdestructor = clearImmediate;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setImmediate(executeTask.bind(null, item));\n\t\t};\n\t}\n\telse {\n\t\tdestructor = clearTimeout;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setTimeout(executeTask.bind(null, item), 0);\n\t\t};\n\t}\n\n\tfunction queueTask(callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\t\tconst id: any = enqueue(item);\n\n\t\treturn getQueueHandle(item, destructor && function () {\n\t\t\tdestructor(id);\n\t\t});\n\t};\n\n\t// TODO: Use aspect.before when it is available.\n\treturn has('microtasks') ? queueTask : function (callback: (...args: any[]) => any): Handle {\n\t\tcheckMicroTaskQueue();\n\t\treturn queueTask(callback);\n\t};\n})();\n\ncheckMicroTaskQueue = !has('microtasks')\n\t? function () {\n\t\tif (!microTaskQueued) {\n\t\t\tmicroTaskQueued = true;\n\t\t\tqueueTask(function () {\n\t\t\t\tmicroTaskQueued = false;\n\n\t\t\t\tif (microTasks.length) {\n\t\t\t\t\tlet item: QueueItem | undefined;\n\t\t\t\t\twhile (item = microTasks.shift()) {\n\t\t\t\t\t\texecuteTask(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} : checkMicroTaskQueue;\n\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueMicroTask = (function () {\n\tlet enqueue: (item: QueueItem) => void;\n\n\tif (has('host-node')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tprocess.nextTick(executeTask.bind(null, item));\n\t\t};\n\t}\n\t/* Edge's Promise does not consitently resolve as a microtask, therefore not using Promise */\n\telse if (has('es6-promise') && !has('setimmediate') && !has('host-node')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tglobal.Promise.resolve(item).then(executeTask);\n\t\t};\n\t}\n\telse if (has('dom-mutationobserver')) {\n\t\t/* tslint:disable-next-line:variable-name */\n\t\tconst HostMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\t\tconst node = document.createElement('div');\n\t\tconst queue: QueueItem[] = [];\n\t\tconst observer = new HostMutationObserver(function (): void {\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tconst item = queue.shift();\n\t\t\t\tif (item && item.isActive) {\n\t\t\t\t\titem.callback();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tobserver.observe(node, { attributes: true });\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tnode.setAttribute('queueStatus', '1');\n\t\t};\n\t}\n\telse {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tcheckMicroTaskQueue();\n\t\t\tmicroTasks.push(item);\n\t\t};\n\t}\n\n\treturn function (callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\n\t\tenqueue(item);\n\n\t\treturn getQueueHandle(item);\n\t};\n})();\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/queue.ts","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 43\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 44\n// module chunks = 0","import { Thenable } from 'dojo-shim/interfaces';\nimport { Executor } from 'dojo-shim/Promise';\nimport ExtensiblePromise from './ExtensiblePromise';\n\n/**\n * Describe the internal state of a task.\n */\nexport declare const enum State {\n\tFulfilled = 0,\n\tPending = 1,\n\tRejected = 2,\n\tCanceled = 3\n}\n\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nexport function isTask<T>(value: any): value is Task<T> {\n\treturn Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n}\n\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nexport function isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nexport default class Task<T> extends ExtensiblePromise<T> {\n\t/**\n\t * Return a resolved task.\n\t *\n\t * @param value The value to resolve with\n\t *\n\t * @return {Task}\n\t */\n\tpublic static resolve(): Task<void>;\n\tpublic static resolve<T>(value: (T | Thenable<T>)): Task<T>;\n\tpublic static resolve<T>(value?: any): Task<T> {\n\t\treturn new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * A cancelation handler that will be called if this task is canceled.\n\t */\n\tprivate canceler: () => void;\n\n\t/**\n\t * Children of this Task (i.e., Tasks that were created from this Task with `then` or `catch`).\n\t */\n\tprivate children: Task<any>[];\n\n\t/**\n\t * The finally callback for this Task (if it was created by a call to `finally`).\n\t */\n\tprivate _finally: () => void | Thenable<any>;\n\n\t/**\n\t * The state of the task\n\t */\n\tprotected _state: State;\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * @constructor\n\t *\n\t * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t *\n\t * @param executor Method that initiates some task\n\t * @param canceler Method to call when the task is canceled\n\t *\n\t */\n\tconstructor(executor: Executor<T>, canceler?: () => void) {\n\t\t// we have to initialize these to avoid a compiler error of using them before they are initialized\n\t\tlet superResolve: (value?: T | Thenable<T> | undefined) => void = () => {};\n\t\tlet superReject: (reason?: any) => void = () => {};\n\n\t\tsuper((resolve, reject) => {\n\t\t\tsuperResolve = resolve;\n\t\t\tsuperReject = reject;\n\t\t});\n\n\t\tthis._state = State.Pending;\n\n\t\tthis.children = [];\n\t\tthis.canceler = () => {\n\t\t\tif (canceler) {\n\t\t\t\tcanceler();\n\t\t\t}\n\t\t\tthis._cancel();\n\t\t};\n\n\t\t// Don't let the Task resolve if it's been canceled\n\t\ttry {\n\t\t\texecutor(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Fulfilled;\n\t\t\t\t\tsuperResolve(value);\n\t\t\t\t},\n\t\t\t\t(reason) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Rejected;\n\t\t\t\t\tsuperReject(reason);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (reason) {\n\t\t\tthis._state = State.Rejected;\n\t\t\tsuperReject(reason);\n\t\t}\n\t}\n\n\t/**\n\t * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t */\n\tprivate _cancel(finallyTask?: void | Thenable<any>): void {\n\t\tthis._state = State.Canceled;\n\n\t\tconst runFinally = () => {\n\t\t\ttry {\n\t\t\t\treturn this._finally();\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\t// Any errors in a `finally` callback are completely ignored during cancelation\n\t\t\t}\n\t\t};\n\n\t\tif (this._finally) {\n\t\t\tif (isThenable(finallyTask)) {\n\t\t\t\tfinallyTask = (<Thenable<any>> finallyTask).then(runFinally, runFinally);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinallyTask = runFinally();\n\t\t\t}\n\t\t}\n\n\t\tthis.children.forEach(function (child) {\n\t\t\tchild._cancel(finallyTask);\n\t\t});\n\t}\n\n\t/**\n\t * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t */\n\tcancel(): void {\n\t\tif (this._state === State.Pending) {\n\t\t\tthis.canceler();\n\t\t}\n\t}\n\n\t/**\n\t * Allows for cleanup actions to be performed after resolution of a Promise.\n\t */\n\tfinally(callback: () => void | Thenable<any>): Task<T> {\n\t\t// if this task is already canceled, call the task\n\t\tif (this._state === State.Canceled) {\n\t\t\treturn Task.resolve(callback());\n\t\t}\n\n\t\tconst task = this.then<any>(\n\t\t\tvalue => Task.resolve(callback()).then(() => value),\n\t\t\treason => Task.resolve(callback()).then(() => {\n\t\t\t\tthrow reason;\n\t\t\t})\n\t\t);\n\n\t\t// Keep a reference to the callback; it will be called if the Task is canceled\n\t\ttask._finally = callback;\n\t\treturn task;\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the Task resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error: Error) => U | Thenable<U>): this {\n\t\t// FIXME\n\t\t// tslint:disable-next-line:no-var-keyword\n\t\tvar task = super.then<U>(\n\t\t\t// Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t\t\tfunction (value) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onFulfilled) {\n\t\t\t\t\treturn onFulfilled(value);\n\t\t\t\t}\n\t\t\t\treturn <any> value;\n\t\t\t},\n\t\t\tfunction (error) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onRejected) {\n\t\t\t\t\treturn onRejected(error);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\ttask.canceler = () => {\n\t\t\t// If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t\t\t// unresolved parent\n\t\t\tif (this._state === State.Pending) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t\t// If task's parent has been resolved, propagate cancelation to the task's descendants\n\t\t\telse {\n\t\t\t\ttask._cancel();\n\t\t\t}\n\t\t};\n\n\t\t// Keep track of child Tasks for propogating cancelation back down the chain\n\t\tthis.children.push(task);\n\n\t\treturn task;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/async/Task.ts","import { Iterable, forOf } from 'dojo-shim/iterator';\nimport Promise, { Executor } from 'dojo-shim/Promise';\nimport { Thenable } from 'dojo-shim/interfaces';\n\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nfunction unwrapPromises(iterable: Iterable<any> | any[]): any[] {\n\tconst unwrapped: any[] = [];\n\tforOf(iterable, function (item: any): void {\n\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t});\n\treturn unwrapped;\n}\n\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport default class ExtensiblePromise<T> {\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param {Error?} reason    The reason for the rejection\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic reject<T>(reason?: Error): any {\n\t\treturn new this<T>((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic resolve(): any;\n\tstatic resolve<T>(value: (T | Thenable<T>)): any;\n\tstatic resolve<T>(value?: any): any {\n\t\treturn new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic all<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F {\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.all(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic race<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F {\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.race(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Promise}\n\t * The wrapped promise\n\t */\n\t_promise: Promise<T>;\n\n\t/**\n\t * Creates a new extended Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\tthis._promise = new Promise<T>(executor);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise is rejected.\n\t *\n\t * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tcatch<U>(onRejected: (reason: Error) => (U | Thenable<U>)): this;\n\tcatch<U>(onRejected: (reason: Error) => void): this {\n\t\treturn this.then<U>(undefined, onRejected);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): this;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): this {\n\t\tlet e: Executor<U> = (resolve, reject) => {\n\t\t\tfunction handler(rejected: boolean, valueOrError: T | U | Error) {\n\t\t\t\tconst callback: ((value: T | U | Error) => (U | Thenable<U> | void)) | undefined = rejected ? onRejected : onFulfilled;\n\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(<U> callback(<T> valueOrError));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (rejected) {\n\t\t\t\t\treject(valueOrError);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve(<U> valueOrError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t\t};\n\n\t\treturn new (<{ new(executor: Executor<U>): any }> this.constructor)(e);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/async/ExtensiblePromise.ts","import { Handle, EventObject } from 'dojo-interfaces/core';\nimport { createHandle, createCompositeHandle } from './lang';\nimport Evented from './Evented';\n\nexport interface EventCallback {\n\t(event: EventObject): void;\n}\n\nexport interface EventEmitter {\n\ton(event: string, listener: EventCallback): EventEmitter;\n\tremoveListener(event: string, listener: EventCallback): EventEmitter;\n}\n\ninterface DOMEventObject extends EventObject {\n\tbubbles: boolean;\n\tcancelable: boolean;\n}\n\n/**\n * Provides a normalized mechanism for dispatching events for event emitters, Evented objects, or DOM nodes.\n * @param target The target to emit the event from\n * @param event The event object to emit\n * @return Boolean indicating if preventDefault was called on the event object (only relevant for DOM events;\n *     always false for other event emitters)\n */\nexport function emit<T extends EventObject>(target: Evented | EventTarget | EventEmitter, event: T | EventObject): boolean;\nexport function emit<T extends EventObject>(target: any, event: T | EventObject): boolean {\n\tif (\n\t\ttarget.dispatchEvent && /* includes window and document */\n\t\t\t((target.ownerDocument && target.ownerDocument.createEvent) || /* matches nodes */\n\t\t\t(target.document && target.document.createEvent) || /* matches window */\n\t\t\ttarget.createEvent) /* matches document */\n\t) {\n\t\tconst nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t\tnativeEvent.initEvent(\n\t\t\tevent.type,\n\t\t\tBoolean((<DOMEventObject> event).bubbles),\n\t\t\tBoolean((<DOMEventObject> event).cancelable)\n\t\t);\n\n\t\tfor (let key in event) {\n\t\t\tif (!(key in nativeEvent)) {\n\t\t\t\tnativeEvent[key] = (<any> event)[key];\n\t\t\t}\n\t\t}\n\n\t\treturn target.dispatchEvent(nativeEvent);\n\t}\n\n\tif (target.emit) {\n\t\tif (target.removeListener) {\n\t\t\t// Node.js EventEmitter\n\t\t\ttarget.emit(event.type, event);\n\t\t\treturn false;\n\t\t}\n\t\telse if (target.on) {\n\t\t\t// Dojo Evented or similar\n\t\t\ttarget.emit(event);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tthrow new Error('Target must be an event emitter');\n}\n\n/**\n * Provides a normalized mechanism for listening to events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport default function on(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport default function on(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\nexport default function on(target: any, type: any, listener: any, capture?: boolean): Handle {\n\tif (Array.isArray(type)) {\n\t\tlet handles: Handle[] = type.map(function (type: string): Handle {\n\t\t\treturn on(target, type, listener, capture);\n\t\t});\n\n\t\treturn createCompositeHandle(...handles);\n\t}\n\n\tconst callback = function (this: any) {\n\t\tlistener.apply(this, arguments);\n\t};\n\n\t// DOM EventTarget\n\tif (target.addEventListener && target.removeEventListener) {\n\t\ttarget.addEventListener(type, callback, capture);\n\t\treturn createHandle(function () {\n\t\t\ttarget.removeEventListener(type, callback, capture);\n\t\t});\n\t}\n\n\tif (target.on) {\n\t\t// EventEmitter\n\t\tif (target.removeListener) {\n\t\t\ttarget.on(type, callback);\n\t\t\treturn createHandle(function () {\n\t\t\t\ttarget.removeListener(type, callback);\n\t\t\t});\n\t\t}\n\t\t// Evented\n\t\telse if (target.emit) {\n\t\t\treturn target.on(type, listener);\n\t\t}\n\t}\n\n\tthrow new TypeError('Unknown event emitter object');\n}\n\n/**\n * Provides a mechanism for listening to the next occurrence of an event from event\n * emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may be a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport function once(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport function once(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\nexport function once(target: any, type: any, listener: any, capture?: boolean): Handle {\n\t// FIXME\n\t// tslint:disable-next-line:no-var-keyword\n\tvar handle = on(target, type, function (this: any) {\n\t\thandle.destroy();\n\t\treturn listener.apply(this, arguments);\n\t}, capture);\n\n\treturn handle;\n}\n\nexport interface PausableHandle extends Handle {\n\tpause(): void;\n\tresume(): void;\n}\n\n/**\n * Provides a mechanism for creating pausable listeners for events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle with additional pause and resume methods; the listener will never fire when paused\n */\nexport function pausable(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): PausableHandle;\nexport function pausable(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): PausableHandle;\nexport function pausable(target: any, type: any, listener: any, capture?: boolean): PausableHandle {\n\tlet paused: boolean;\n\n\tconst handle = <PausableHandle> on(target, type, function (this: any) {\n\t\tif (!paused) {\n\t\t\treturn listener.apply(this, arguments);\n\t\t}\n\t}, capture);\n\n\thandle.pause = function () {\n\t\tpaused = true;\n\t};\n\n\thandle.resume = function () {\n\t\tpaused = false;\n\t};\n\n\treturn handle;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/on.ts","import UrlSearchParams from 'dojo-core/UrlSearchParams';\n\nexport interface ParsedPath {\n\t/**\n\t * Parameters extracted from the search component.\n\t */\n\tsearchParams: UrlSearchParams;\n\n\t/**\n\t * Pathname segments.\n\t */\n\tsegments: string[];\n\n\t/**\n\t * Whether the pathname ended with a trailing slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nexport function parse(path: string): ParsedPath {\n\tconst tokens: string[] = path.split(/([/?#])/).filter(Boolean);\n\n\tlet pathnameTokens = tokens;\n\tlet searchParams: UrlSearchParams;\n\n\tconst searchStart = tokens.indexOf('?');\n\tconst hashStart = tokens.indexOf('#');\n\tif (searchStart >= 0) {\n\t\tif (hashStart >= 0) {\n\t\t\t// Either `/foo?bar#baz` or `/foo#bar?baz`\n\t\t\tpathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1, hashStart).join(''));\n\t\t}\n\t\telse {\n\t\t\t// `/foo?bar`\n\t\t\tpathnameTokens = tokens.slice(0, searchStart);\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1).join(''));\n\t\t}\n\t}\n\telse {\n\t\tsearchParams = new UrlSearchParams();\n\t\tif (hashStart >= 0) {\n\t\t\t// `/foo#bar`\n\t\t\tpathnameTokens = tokens.slice(0, hashStart);\n\t\t}\n\t}\n\n\tconst segments = pathnameTokens.filter(t => t !== '/');\n\tconst trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\n\treturn {\n\t\tsearchParams,\n\t\tsegments,\n\t\ttrailingSlash\n\t};\n}\n\nexport interface MatchResult {\n\t/**\n\t * Whether there are remaining segments that weren't matched.\n\t */\n\thasRemaining: boolean;\n\n\t/**\n\t * Position in the segments array that the remaining unmatched segments start.\n\t */\n\toffset: number;\n\n\t/**\n\t * Values for named segments.\n\t */\n\tvalues: string[];\n}\n\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nexport function match({ expectedSegments }: DeconstructedPath, segments: string[]): MatchResult | null {\n\tif (expectedSegments.length === 0) {\n\t\treturn {\n\t\t\thasRemaining: segments.length > 0,\n\t\t\toffset: 0,\n\t\t\tvalues: []\n\t\t};\n\t}\n\n\tif (expectedSegments.length > segments.length) {\n\t\treturn null;\n\t}\n\n\tlet isMatch = true;\n\tconst values: string[] = [];\n\tfor (let i = 0; isMatch && i < expectedSegments.length; i++) {\n\t\tconst value = segments[i];\n\t\tconst expected = expectedSegments[i];\n\t\tif (isNamedSegment(expected)) {\n\t\t\tvalues.push(value);\n\t\t}\n\t\telse if (expected.literal !== value) {\n\t\t\tisMatch = false;\n\t\t}\n\t}\n\n\tif (!isMatch) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\thasRemaining: expectedSegments.length < segments.length,\n\t\toffset: expectedSegments.length,\n\t\tvalues\n\t};\n}\n\nexport interface LiteralSegment {\n\tliteral: string;\n}\n\nexport interface NamedSegment {\n\tname: string;\n}\n\nexport type Segment = LiteralSegment | NamedSegment;\n\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nexport function isNamedSegment(segment: Segment): segment is NamedSegment {\n\treturn (<NamedSegment> segment).name !== undefined;\n}\n\n/**\n * Describes a route path, broken down into its constituent parts.\n */\nexport interface DeconstructedPath {\n\t/**\n\t * Segments (literal and named) that are expected to be present when matching paths.\n\t */\n\texpectedSegments: Segment[];\n\n\t/**\n\t * Whether the pathname started with a slash.\n\t */\n\tleadingSlash: boolean;\n\n\t/**\n\t * Named path parameters, in the order that they occurred in the path.\n\t */\n\tparameters: string[];\n\n\t/**\n\t * Named query parameters, in the order that they occurred in the path.\n\t */\n\tsearchParameters: string[];\n\n\t/**\n\t * Whether the pathname ended with a slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nexport function deconstruct(path: string): DeconstructedPath {\n\tconst expectedSegments: Segment[] = [];\n\tconst parameters: string[] = [];\n\tconst searchParameters: string[] = [];\n\tlet trailingSlash = false;\n\n\tconst tokens = path.split(/([/{}?&])/).filter(Boolean);\n\tconst leadingSlash = tokens[0] === '/';\n\n\tlet i = 0;\n\tconst consume = () => tokens[i++];\n\tconst peek = () => tokens[i];\n\n\tlet inSearchComponent = false;\n\twhile (i < tokens.length) {\n\t\tconst t = consume();\n\n\t\tswitch (t) {\n\t\t\tcase '{': {\n\t\t\t\tconst name = consume();\n\t\t\t\tif (!name || name === '}') {\n\t\t\t\t\tthrow new TypeError('Parameter must have a name');\n\t\t\t\t}\n\t\t\t\t// Reserve : for future use, e.g. including type data in the parameter declaration.\n\t\t\t\tif (name === '{' || name === '&' || /:/.test(name)) {\n\t\t\t\t\tthrow new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t\t\t\t}\n\t\t\t\tif (parameters.indexOf(name) !== -1 || searchParameters.indexOf(name) !== -1) {\n\t\t\t\t\tthrow new TypeError(`Parameter must have a unique name, got '${name}'`);\n\t\t\t\t}\n\n\t\t\t\tconst closing = consume();\n\t\t\t\tif (!closing || closing !== '}') {\n\t\t\t\t\tthrow new TypeError(`Parameter name must be followed by '}', got '${closing}'`);\n\t\t\t\t}\n\n\t\t\t\tconst separator = peek();\n\t\t\t\tif (separator) {\n\t\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\t\tif (separator !== '&') {\n\t\t\t\t\t\t\tthrow new TypeError(`Search parameter must be followed by '&', got '${separator}'`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (separator !== '/' && separator !== '?') {\n\t\t\t\t\t\tthrow new TypeError(`Parameter must be followed by '/' or '?', got '${separator}'`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tsearchParameters.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tparameters.push(name);\n\t\t\t\t\texpectedSegments.push(Object.freeze({ name }));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '?':\n\t\t\tcase '/':\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\tif (t === '?') {\n\t\t\t\t\tinSearchComponent = true;\n\t\t\t\t\tif (expectedSegments.length === 0) {\n\t\t\t\t\t\tthrow new TypeError('Path must contain at least one segment');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (t === '/') {\n\t\t\t\t\tconst next = peek();\n\t\t\t\t\tif (next === '/') {\n\t\t\t\t\t\tthrow new TypeError('Path segment must not be empty');\n\t\t\t\t\t}\n\t\t\t\t\tif (expectedSegments.length > 0 && (!next || next === '?')) {\n\t\t\t\t\t\ttrailingSlash = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tif (!inSearchComponent) {\n\t\t\t\t\tthrow new TypeError('Path segment must not contain \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tconst next = peek();\n\t\t\t\tif (next === '&') {\n\t\t\t\t\tthrow new TypeError('Expected parameter in search component, got \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\texpectedSegments.push(Object.freeze({ literal: t }));\n\t\t}\n\t}\n\n\treturn Object.freeze({\n\t\texpectedSegments: Object.freeze(expectedSegments),\n\t\tleadingSlash,\n\t\tparameters: Object.freeze(parameters),\n\t\tsearchParameters: Object.freeze(searchParameters),\n\t\ttrailingSlash\n\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/lib/path.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented from 'dojo-compose/mixins/createEvented';\nimport global from 'dojo-core/global';\nimport on from 'dojo-core/on';\nimport WeakMap from 'dojo-shim/WeakMap';\n\nimport { History, HistoryOptions } from './interfaces';\n\n/**\n * A browser-based history manager that uses the location hash to store the current value.\n */\nexport type HashHistory = History;\n\n/**\n * Options for creating HashHistory instances.\n */\nexport interface HashHistoryOptions extends HistoryOptions {\n\t/**\n\t * A DOM window object. HashHistory uses the `location` property and\n\t * listens to `hashchange` events. The current value is initialized to the\n\t * initial hash.\n\t */\n\twindow: Window;\n}\n\nexport interface HashHistoryFactory extends ComposeFactory<HashHistory, HashHistoryOptions> {\n\t/**\n\t * Create a new HashHistory instance.\n\t * @param options Options to use during creation. If not specified the instance assumes\n\t *   the global object is a DOM window.\n\t */\n\t(options?: HashHistoryOptions): HashHistory;\n}\n\ninterface PrivateState {\n\tcurrent: string;\n\tbrowserLocation: Location;\n}\n\nconst privateStateMap = new WeakMap<HashHistory, PrivateState>();\n\nconst createHashHistory: HashHistoryFactory = compose.mixin(createEvented, {\n\tmixin: {\n\t\tget current(this: HashHistory) {\n\t\t\treturn privateStateMap.get(this).current;\n\t\t},\n\n\t\tprefix(path: string) {\n\t\t\treturn `#${path}`;\n\t\t},\n\n\t\tset(this: HashHistory, path: string) {\n\t\t\tconst privateState = privateStateMap.get(this);\n\t\t\tif (privateState.current === path) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprivateState.current = path;\n\t\t\tprivateState.browserLocation.hash = this.prefix(path);\n\t\t\tthis.emit({\n\t\t\t\ttype: 'change',\n\t\t\t\tvalue: path\n\t\t\t});\n\t\t},\n\n\t\treplace(this: HashHistory, path: string) {\n\t\t\tconst privateState = privateStateMap.get(this);\n\t\t\tif (privateState.current === path) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprivateState.current = path;\n\n\t\t\tconst { pathname, search } = privateState.browserLocation;\n\t\t\tprivateState.browserLocation.replace(pathname + search + this.prefix(path));\n\n\t\t\tthis.emit({\n\t\t\t\ttype: 'change',\n\t\t\t\tvalue: path\n\t\t\t});\n\t\t}\n\t},\n\tinitialize(instance: HashHistory, { window }: HashHistoryOptions = { window: global }) {\n\t\tconst { location: browserLocation } = window;\n\n\t\tconst privateState: PrivateState = {\n\t\t\tcurrent: browserLocation.hash.slice(1),\n\t\t\tbrowserLocation\n\t\t};\n\t\tprivateStateMap.set(instance, privateState);\n\n\t\tinstance.own(on(window, 'hashchange', () => {\n\t\t\tconst path = browserLocation.hash.slice(1);\n\n\t\t\t// Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t\t\t// manager sets the hash.\n\t\t\tif (path !== privateState.current) {\n\t\t\t\tprivateState.current = path;\n\t\t\t\tinstance.emit({\n\t\t\t\t\ttype: 'change',\n\t\t\t\t\tvalue: path\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n});\n\nexport default createHashHistory;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/history/createHashHistory.ts","import createAction from 'dojo-actions/createAction';\nimport widgetStore from '../stores/widgetStore';\nimport { CardDetailsRouteParameters } from '../routes';\nimport cardStore, { pickRandomCards } from '../stores/cardStore';\n\nexport const gotoCardDetails = createAction({\n\tdo({ id }: CardDetailsRouteParameters) {\n\t\treturn cardStore.get(id).then(function (cardDescription) {\n\t\t\treturn pickRandomCards(2, [ id ]).then((seenWith) => {\n\t\t\t\treturn Promise.all([\n\t\t\t\t\twidgetStore.patch({ id: 'cardDetails', cardDescription, seenWith }),\n\t\t\t\t\twidgetStore.patch({ id: 'app', route: 'cardDetails' })\n\t\t\t\t]);\n\t\t\t});\n\t\t});\n\t}\n});\n\nexport const gotoCards = createAction({\n\tdo() {\n\t\treturn widgetStore.patch({ id: 'app', route: 'cards' });\n\t}\n});\n\nexport const gotoHome = createAction({\n\tdo() {\n\t\treturn widgetStore.patch({ id: 'app', route: 'home' });\n\t}\n});\n\nexport const gotoAbout = createAction({\n\tdo() {\n\t\treturn widgetStore.patch({ id: 'app', route: 'about' });\n\t}\n});\n\nexport const gotoGameplay = createAction({\n\tdo() {\n\t\treturn widgetStore.patch({ id: 'app', route: 'gameplay' });\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/routeActions.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { Stateful, StatefulOptions, State } from 'dojo-compose/mixins/createStateful';\nimport { EventObject } from 'dojo-core/interfaces';\nimport Task, { isTask } from 'dojo-core/async/Task';\nimport { Thenable } from 'dojo-shim/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\n\n/**\n * A type alias to a \"generic\" action\n */\nexport type AnyAction = Action<any, DoOptions<any, TargettedEventObject<any>>, ActionState>;\n\nexport interface TargettedEventObject<T> extends EventObject {\n\t/**\n\t * The target of the event\n\t */\n\ttarget: T;\n}\n\nexport interface DoOptions<T, E extends TargettedEventObject<T>> {\n\t[option: string]: any;\n\n\t/**\n\t * The target event (subject) of the action\n\t */\n\tevent?: E;\n}\n\nexport interface ActionState extends State {\n\t/**\n\t * Determines if the action is enabled or not\n\t */\n\tenabled?: boolean;\n}\n\nexport interface ActionMixin<T, O extends DoOptions<T, TargettedEventObject<T>>> {\n\t/**\n\t * The main method that performs the action and returns a task which resolves when the action completes\n\t * @param options The options to be passed to the `do` method\n\t */\n\tdo(options?: O): Task<T>;\n\n\t/**\n\t * Enabled the task is disabled\n\t */\n\tenable(): void;\n\n\t/**\n\t * Disable the task if enabled\n\t */\n\tdisable(): void;\n\n\t/**\n\t * A method which may be called to configure the action after it's been created.\n\t *\n\t * It's up to the implementation to decide what happens if this method is called multiple times. Implementations\n\t * may throw or return a rejected promise.\n\t *\n\t * @param configuration The configuration. Implementations will need to cast to their expected configuration object\n\t * @return May return a promise in case configuration is asynchronous\n\t */\n\tconfigure(options: { [option: string]: any }): Promise<void> | void;\n}\n\nexport type Action<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState> = Stateful<S> & ActionMixin<T, O>;\n\nexport type DoFunction<T> = (options?: DoOptions<T, TargettedEventObject<T>>) => T | Thenable<T>;\n\nexport interface ActionOptions<T, S extends ActionState> extends StatefulOptions<S> {\n\t/**\n\t * The method that is invoked when `do()` is called and the action is enabled\n\t */\n\tdo: DoFunction<T>;\n\n\t/**\n\t * Set the enabled state during construction\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The method that is invoked when `configure()` is called\n\t */\n\tconfigure?(options: { [option: string]: any }): Promise<void> | void;\n}\n\nexport interface ActionFactory extends ComposeFactory<Action<any, DoOptions<any, any>, ActionState>, ActionOptions<any, ActionState>> {\n\t/**\n\t * Create a new instance of an Action, using the supplied options\n\t * @param options The options used to construct the Action\n\t */\n\t<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState>(options: ActionOptions<T, S>): Action<T, O, S>;\n}\n\n/**\n * A type guard that validates the object passed is an Action\n */\nexport function isAction<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState>(value: any): value is Action<T, O, S> {\n\treturn typeof value === 'object' && typeof value.do === 'function';\n}\n\n/**\n * A weak map of `do` methods\n */\nconst doFunctions = new WeakMap<AnyAction, DoFunction<any>>();\n\n/**\n * A weak map of `configure` methods\n */\nconst configureFunctions = new WeakMap<AnyAction, (configuration: Object) => Promise<void> | void>();\n\n/**\n * A factory which creates instances of Action\n */\nconst createAction: ActionFactory = compose<ActionMixin<any, DoOptions<any, TargettedEventObject<any>>>, ActionOptions<any, ActionState>>({\n\t\tdo(this: AnyAction, options?: DoOptions<any, TargettedEventObject<any>>): Task<any> {\n\t\t\tconst doFn = doFunctions.get(this);\n\t\t\tif (doFn && this.state.enabled) {\n\t\t\t\tconst result = doFn.call(this, options);\n\t\t\t\treturn isTask(result) ? result : Task.resolve(result);\n\t\t\t}\n\t\t\treturn Task.resolve();\n\t\t},\n\t\tenable(this: AnyAction): void {\n\t\t\tif (!this.state.enabled) {\n\t\t\t\tthis.setState({ enabled: true });\n\t\t\t}\n\t\t},\n\t\tdisable(this: AnyAction): void {\n\t\t\tif (this.state.enabled) {\n\t\t\t\tthis.setState({ enabled: false });\n\t\t\t}\n\t\t},\n\t\tconfigure(this: AnyAction, configuration: Object): Promise<void> | void {\n\t\t\tconst configureFn = configureFunctions.get(this);\n\t\t\tif (configureFn) {\n\t\t\t\treturn configureFn.call(this, configuration);\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createStateful,\n\t\tinitialize(instance: AnyAction, { do: doFn, enabled = true, configure }: ActionOptions<any, ActionState>) {\n\t\t\tif (!doFn) {\n\t\t\t\tthrow new TypeError(`'options.do' required during creation.`);\n\t\t\t}\n\t\t\tdoFunctions.set(instance, doFn);\n\t\t\tinstance.setState({ enabled });\n\t\t\tif (configure) {\n\t\t\t\tconfigureFunctions.set(instance, configure);\n\t\t\t}\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tdoFunctions.delete(instance);\n\t\t\t\t\tconfigureFunctions.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nexport default createAction;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-actions/createAction.ts","import { Handle } from 'dojo-core/interfaces';\nimport { deepAssign } from 'dojo-core/lang';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Observable, Subscription } from './interfaces';\nimport createEvented, { Evented, EventedOptions, EventedListener, TargettedEventObject } from './createEvented';\nimport { ComposeFactory } from '../compose';\nimport createCancelableEvent, { CancelableEvent } from './../util/createCancelableEvent';\n\n/**\n * Base State interface\n */\nexport interface State {\n\t[prop: string]: any;\n}\n\nexport interface ObservableState<S extends State> {\n\t/**\n\t * A method that allows the return of an `Observable` interface for a particular `id`\n\t * @param id The ID to observe\n\t */\n\tobserve(id: string): Observable<S>;\n\n\t/**\n\t * A method that allows the `Stateful` to provide a change to its state, instead of\n\t * changing its state directly.\n\t * @param partial The partial state to be *patched*\n\t * @param options A map of options, which includes the `id` being observed\n\t */\n\tpatch(partial: any, options?: { id?: string }): Promise<S>;\n}\n\nexport interface StatefulOptions<S extends State> extends EventedOptions {\n\t/**\n\t * State that should be set during creation\n\t */\n\tstate?: S;\n\n\t/**\n\t * An ID to be used in conjunction with the `stateFrom` option to observe the state\n\t */\n\tid?: string;\n\n\t/**\n\t * An object that the Stateful should observe its state from, which supplies an `observe` and\n\t * `patch` methods to be able to manage its state\n\t */\n\tstateFrom?: ObservableState<S>;\n}\n\nexport interface StateChangeEvent<S extends State> extends TargettedEventObject {\n\t/**\n\t * The event type\n\t */\n\ttype: string;\n\n\t/**\n\t * The state of the target\n\t */\n\tstate: S;\n\n\t/**\n\t * A Stateful instance\n\t */\n\ttarget: Stateful<S>;\n}\n\nexport interface StatefulMixin<S extends State>{\n\t/**\n\t * A read only view of the state\n\t */\n\treadonly state: S;\n\n\t/**\n\t * Set the state on the instance.\n\t *\n\t * Set state can take a partial value, therefore if a key is ommitted from the value, it will not be changed.\n\t * To *clear* a value, set a key to `undefined`\n\t *\n\t * @param value The state (potentially partial) to be set\n\t */\n\tsetState(value: S): void;\n\n\t/**\n\t * Observe (and update) the state from an Observable\n\t * @param id The ID to be observed on the Observable\n\t * @param observable An object which provides a `observe` and `patch` methods which allow `Stateful` to be able to\n\t *                   manage its state.\n\t */\n\tobserveState(id: string, observable: ObservableState<S>): Handle;\n}\n\nexport type Stateful<S extends State> = StatefulMixin<S> & Evented & {\n\t/**\n\t * Add a listener for a `statecomplete` event, which occures when state is observed\n\t * and is completed.  If the event is not cancelled, the instance will continue and\n\t * call `target.destroy()`.\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'statecomplete', listener: EventedListener<CancelableEvent<'statecomplete', Stateful<S>>>): Handle;\n\n\t/**\n\t * Add a listener for a `statechange` event, which occures whenever the state changes on the instance.\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {\n\t<S extends State>(options?: StatefulOptions<S>): Stateful<S>;\n}\n\n/**\n * Internal interface which contains references to an observed state\n */\ninterface ObservedState {\n\tid: string;\n\tobservable: ObservableState<State>;\n\tsubscription: Subscription;\n\thandle: Handle;\n}\n\n/**\n * A weak map of stateful instances to their obseved state references\n */\nconst observedStateMap = new WeakMap<Stateful<State>, ObservedState>();\n\n/**\n * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n * cancelled.\n *\n * @param stateful The `Stateful` object to unobserve\n */\nfunction unobserve(stateful: Stateful<State>): void {\n\tconst observedState = observedStateMap.get(stateful);\n\tif (observedState) {\n\t\tobservedState.handle.destroy();\n\t\tconst statecomplete = createCancelableEvent({\n\t\t\ttype: 'statecomplete',\n\t\t\ttarget: stateful\n\t\t});\n\t\tstateful.emit(statecomplete);\n\t\tif (!statecomplete.defaultPrevented) {\n\t\t\tstateful.destroy();\n\t\t}\n\t}\n}\n\n/**\n * Internal function that actually applies the state to the Stateful's state and\n * emits the `statechange` event.\n *\n * @param stateful The Stateful instance\n * @param state The State to be set\n */\nfunction setStatefulState(stateful: Stateful<State>, state: State): void {\n\tstate = deepAssign(stateWeakMap.get(stateful), state);\n\tstateful.emit({\n\t\ttype: 'statechange',\n\t\tstate,\n\t\ttarget: stateful\n\t});\n}\n\n/**\n * A weak map that contains the stateful's state\n */\nconst stateWeakMap = new WeakMap<Stateful<State>, State>();\n\n/**\n * Create an instance of a stateful object\n */\nconst createStateful: StatefulFactory = createEvented\n\t.mixin({\n\t\tclassName: 'Stateful',\n\t\tmixin: {\n\t\t\tget state(this: Stateful<State>): State {\n\t\t\t\treturn stateWeakMap.get(this);\n\t\t\t},\n\n\t\t\tsetState(this: Stateful<State>, value: State): void {\n\t\t\t\tconst observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tobservedState.observable.patch(value, { id: observedState.id });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsetStatefulState(this, value);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tobserveState(this: Stateful<State>, id: string, observable: ObservableState<State>): Handle {\n\t\t\t\tlet observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tif (observedState.id === id && observedState.observable === observable) {\n\t\t\t\t\t\treturn observedState.handle;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Already observing state with ID '${observedState.id}'`);\n\t\t\t\t}\n\t\t\t\tconst stateful = this;\n\t\t\t\tobservedState = {\n\t\t\t\t\tid,\n\t\t\t\t\tobservable,\n\t\t\t\t\tsubscription: observable\n\t\t\t\t\t\t.observe(id)\n\t\t\t\t\t\t.subscribe(\n\t\t\t\t\t\t\t(item) => setStatefulState(stateful, item), /* next handler */\n\t\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\t\t/* TODO: Should we emit an error, instead of throwing? */\n\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t}, /* error handler */\n\t\t\t\t\t\t\t() => unobserve(stateful)), /* completed handler */\n\t\t\t\t\thandle: {\n\t\t\t\t\t\tdestroy() {\n\t\t\t\t\t\t\tconst observedState = observedStateMap.get(stateful);\n\t\t\t\t\t\t\tif (observedState) {\n\t\t\t\t\t\t\t\tobservedState.subscription.unsubscribe();\n\t\t\t\t\t\t\t\tobservedStateMap.delete(stateful);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tobservedStateMap.set(stateful, observedState);\n\t\t\t\treturn observedState.handle;\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: StatefulMixin<State> & Evented, options: StatefulOptions<State>) {\n\t\t\t/* Using Object.create(null) will improve performance when looking up properties in state */\n\t\t\tstateWeakMap.set(instance, Object.create(null));\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tstateWeakMap.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\tconst { id, stateFrom, state } = options;\n\t\t\t\tif (typeof id !== 'undefined' && stateFrom) {\n\t\t\t\t\tinstance.own(instance.observeState(id, stateFrom));\n\t\t\t\t}\n\t\t\t\telse if (stateFrom) {\n\t\t\t\t\tthrow new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t\t\t\t}\n\t\t\t\tif (state) {\n\t\t\t\t\tinstance.setState(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createStateful;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createStateful.ts","export interface CancelableEvent<T extends string, U> {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: T;\n\n\t/**\n\t * The target for the event\n\t */\n\treadonly target: U;\n\n\t/**\n\t * Can the event be canceled?\n\t */\n\treadonly cancelable: boolean;\n\n\t/**\n\t * Was the event canceled?\n\t */\n\treadonly defaultPrevented: boolean;\n\n\t/**\n\t * Cancel the event\n\t */\n\tpreventDefault(): void;\n}\n\n/**\n * A simple factory that creates an event object which can be cancelled\n *\n * @param options The options for the event\n */\nfunction createCancelableEvent<T extends string, U>(options: { type: T, target: U }): CancelableEvent<T, U> {\n\tconst { type, target } = options;\n\tconst event: CancelableEvent<T, U> = Object.defineProperties({}, {\n\t\ttype: { value: type, enumerable: true },\n\t\ttarget: { value: target, enumerable: true },\n\t\tcancelable: { value: true, enumerable: true },\n\t\tdefaultPrevented: { value: false, enumerable: true, configurable: true },\n\t\tpreventDefault: { value() {\n\t\t\tObject.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n\t\t}, enumerable: true }\n\t});\n\n\treturn event;\n}\n\nexport default createCancelableEvent;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/util/createCancelableEvent.ts","import createMemoryStore from 'dojo-stores/createMemoryStore';\n\nexport default createMemoryStore<any>({\n\tdata: [\n\t\t{\n\t\t\tid: 'navbar',\n\t\t\tsections: [\n\t\t\t\t{ text: 'the cards', href: '#cards' },\n\t\t\t\t{ text: 'gameplay', href: '#gameplay' },\n\t\t\t\t{ text: 'about', href: '#about' }\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\tid: 'app',\n\t\t\troute: 'home'\n\t\t},\n\t\t{\n\t\t\tid: 'cardDetails',\n\t\t\tenterAnimation: 'fadeInSlideDown',\n\t\t\texitAnimation: 'fadeOutSlideUp'\n\t\t},\n\t\t{\n\t\t\tid: 'cards',\n\t\t\tenterAnimation: 'fadeIn',\n\t\t\texitAnimation: 'fadeOut'\n\t\t},\n\t\t{\n\t\t\tid: 'home',\n\t\t\tenterAnimation: 'fadeIn',\n\t\t\texitAnimation: 'fadeOut'\n\t\t},\n\t\t{\n\t\t\tid: 'about',\n\t\t\tenterAnimation: 'fadeIn',\n\t\t\texitAnimation: 'fadeOut'\n\t\t},\n\t\t{\n\t\t\tid: 'gameplay',\n\t\t\tenterAnimation: 'fadeIn',\n\t\t\texitAnimation: 'fadeOut'\n\t\t}\n\t]\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/widgetStore.ts","import { OrderedMap, Map } from 'immutable';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { assign } from 'dojo-core/lang';\nimport { Thenable } from 'dojo-interfaces/shim';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createDestroyable, { Destroyable } from 'dojo-compose/mixins/createDestroyable';\n\nexport type StoreIndex = number | string;\n\nexport interface MemoryStorePragma {\n\t/**\n\t * The identity of the object\n\t */\n\tid?: StoreIndex;\n\n\t/**\n\t * Should the item be replaced if already exists.\n\t */\n\treplace?: boolean;\n}\n\nexport interface MemoryStorePromise<T> extends Promise<T> {\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\n\tget(): MemoryStorePromise<Iterator<T>>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport interface MemoryStoreOptions<T extends Object> {\n\t/**\n\t * Any initial data that should populate the store\n\t */\n\tdata?: T[];\n\n\t/**\n\t * The property of each object to use as the identity for the object\n\t */\n\tidProperty?: StoreIndex;\n}\n\nexport const enum ChangeTypes {\n\tAdd = 1,\n\tPut,\n\tPatch,\n\tDelete\n}\n\nexport interface ChangeRecord<T extends Object> {\n\ttype: ChangeTypes;\n\tid: StoreIndex;\n\ttarget?: T;\n}\n\nexport interface MemoryStoreMixin<T extends Object> {\n\t/**\n\t * The property that determines the ID of the object (defaults to `id`)\n\t */\n\tidProperty: StoreIndex;\n\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\tget(): MemoryStorePromise<T>;\n\n\t/**\n\t * Observe an object, any subsequent changes to the object can also be observed via the observable\n\t * interface that is returned.  If the object is not present in the store, the observation will be\n\t * immediatly completed.  If the object is deleted from the store, the observation will be completed\n\t * @param id The ID of the object to observe\n\t */\n\tobserve(id: StoreIndex): Observable<T>;\n\tobserve(): Observable<ChangeRecord<T>>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport type MemoryStore<T extends Object> = MemoryStoreMixin<T> & Destroyable;\n\n/**\n * The weak map that contains the data for the stores\n */\nconst dataWeakMap = new WeakMap<MemoryStore<Object>, OrderedMap<StoreIndex, Object>>();\n\n/**\n * The weak map that contains any observers for the stores\n */\nconst itemObserverWeakMap = new WeakMap<MemoryStore<Object>, Map<StoreIndex, Observer<Object>[]>>();\n\n/**\n *\n */\nconst storeObserverWeakMap = new WeakMap<MemoryStore<Object>, Observer<Object>[]>();\n\n// const storeObserverWeakMap = new WeakMap<MemoryStore<Object>, Observer<ChangeRecord<Object>>[]>();\n\nexport interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {\n\t<T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;\n\n\t/**\n\t * Creates a memory store from an array of objects\n\t * @params data The array of data to create the memory store from\n\t */\n\tfromArray<T extends Object>(data: T[]): MemoryStore<T>;\n}\n\n/**\n * The methods to decorate the MemoryStorePromise with\n */\nconst storeMethods = [ 'get', 'put', 'add', 'patch', 'delete', 'fromArray' ];\n\n/**\n\t* Returns true if a given value has a `then` method.\n\t* @param {any} value The value to check if is Thenable\n\t* @returns {is Thenable<T>} A type guard if the value is thenable\n\t*/\nfunction isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * Utility function that takes a result and generates a MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n */\nfunction wrapResult<R>(store: MemoryStore<Object>, result: R): MemoryStorePromise<R> {\n\t/* TODO: this all seems pretty expensive, there has to be a better way */\n\tconst p = (isThenable(result) ? result : Promise.resolve(result)) as MemoryStorePromise<R>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Utility function that takes an error and generates a rejected MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap\n */\nfunction wrapError(store: MemoryStore<Object>, result: Error): MemoryStorePromise<Object> {\n\tconst p = (isThenable(result) ? result : Promise.reject(result)) as MemoryStorePromise<Object>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Create a new instance of a MemoryStore\n */\nconst createMemoryStore = compose<MemoryStoreMixin<Object>, MemoryStoreOptions<Object>>({\n\t\tidProperty: 'id',\n\n\t\tget(this: MemoryStore<Object>, id?: StoreIndex): MemoryStorePromise<Object | Iterator<Object>> {\n\t\t\tconst data = dataWeakMap.get(this);\n\t\t\tif (id) {\n\t\t\t\treturn wrapResult(this, data && data.get(String(id)));\n\t\t\t} else {\n\t\t\t\treturn wrapResult(this, data.values());\n\t\t\t}\n\t\t},\n\n\t\tobserve<T>(this: MemoryStore<Object>, id?: StoreIndex): Observable<T> {\n\t\t\tconst store = this;\n\t\t\tif (id) {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\tstore.get(String(id)).then((item: T) => {\n\t\t\t\t\t\tif (item) {\n\t\t\t\t\t\t\tobserver.next(item);\n\t\t\t\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\t\t\t\tconst observerArray: Observer<Object>[] = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t\t\t\t\t\t\tobserverArray.push(observer);\n\t\t\t\t\t\t\titemObserverWeakMap.set(store, (observers ? observers : Map<StoreIndex, Observer<Object>[]>()).set(String(id), observerArray));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tobserver.error(new Error(`ID \"${id}\" not found in store`));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\tconst data = dataWeakMap.get(store);\n\t\t\t\t\tconst observers = storeObserverWeakMap.get(store) || [];\n\t\t\t\t\tconst values: any = data.values();\n\t\t\t\t\tconst items = Array.from(values);\n\t\t\t\t\tconst payload: any = {\n\t\t\t\t\t\tputs: items,\n\t\t\t\t\t\tdeletes: [],\n\t\t\t\t\t\tbeforeAll: [],\n\t\t\t\t\t\tafterAll: items\n\t\t\t\t\t};\n\t\t\t\t\tobserver.next(payload);\n\t\t\t\t\tobservers.push(observer);\n\t\t\t\t\tstoreObserverWeakMap.set(store, observers);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tput(this: MemoryStore<Object>, item: { [property: string]: number | string | undefined; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst store = this;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tconst beforeAll: any = data ? data.values() : [];\n\t\t\tconst idProperty: any = store.idProperty;\n\t\t\tconst id =  options && 'id' in options ? options.id :\n\t\t\t\tidProperty in item ? item[idProperty] :\n\t\t\t\tdata ? data.size : 0;\n\t\t\tif (options && options.replace === false && data && data.has(String(id))) {\n\t\t\t\treturn wrapError(store, Error(`Duplicate ID \"${id}\" when pragma \"replace\" is false`));\n\t\t\t}\n\t\t\titem[idProperty] = id;\n\t\t\tdataWeakMap.set(store, (data ? data : OrderedMap<StoreIndex, Object>()).set(String(id), item));\n\n\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.next(item));\n\t\t\t}\n\t\t\tconst storeObservers = storeObserverWeakMap.get(store);\n\t\t\tif (storeObservers) {\n\t\t\t\tconst afterData = dataWeakMap.get(store);\n\t\t\t\tconst afterAll: any = afterData.values();\n\t\t\t\tconst payload: any = {\n\t\t\t\t\tputs: [item],\n\t\t\t\t\tdeletes: [],\n\t\t\t\t\tbeforeAll: Array.from(beforeAll),\n\t\t\t\t\tafterAll: Array.from(afterAll)\n\t\t\t\t};\n\t\t\t\tstoreObservers.forEach((observer) => {\n\t\t\t\t\tobserver.next(payload);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn wrapResult(store, item);\n\t\t},\n\n\t\tadd(this: MemoryStore<Object>, item: Object, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\treturn this.put(item, assign(options ? options : {}, { replace: false }));\n\t\t},\n\n\t\tpatch(this: MemoryStore<Object>, partial: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst idProperty = this.idProperty;\n\t\t\tconst id = options && 'id' in options ? options.id : partial[idProperty];\n\t\t\tif (!id) {\n\t\t\t\treturn wrapError(this, new Error(`Object ID must either be passed in \"partial.${idProperty}\" or \"options.id\"`));\n\t\t\t}\n\t\t\treturn wrapResult(this, this.get(id).then((item: Object = {}) => {\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.id = id;\n\t\t\t\treturn this.put(assign(item, partial), options);\n\t\t\t}));\n\t\t},\n\n\t\tdelete(this: MemoryStore<Object>, item: StoreIndex | { [property: string]: number | string; }): MemoryStorePromise<boolean> {\n\t\t\tconst store = this;\n\t\t\tconst idProperty = store.idProperty;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tconst beforeAll: any = data ? data.values() : [];\n\n\t\t\t/**\n\t\t\t * Complete any observers associated with this items id\n\t\t\t */\n\t\t\tfunction completeObservable(id: StoreIndex) {\n\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.complete());\n\t\t\t\t\titemObserverWeakMap.set(store, observers.delete(id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction completeStoreObservers() {\n\t\t\t\tconst storeObservers = storeObserverWeakMap.get(store);\n\t\t\t\tif (storeObservers) {\n\t\t\t\t\tconst afterData = dataWeakMap.get(store);\n\t\t\t\t\tconst afterAll: any = afterData.values();\n\t\t\t\t\tconst payload: any = {\n\t\t\t\t\t\tputs: [],\n\t\t\t\t\t\tdeletes: [item],\n\t\t\t\t\t\tbeforeAll: Array.from(beforeAll),\n\t\t\t\t\t\tafterAll: Array.from(afterAll)\n\t\t\t\t\t};\n\t\t\t\t\tstoreObservers.forEach((observer) => {\n\t\t\t\t\t\tobserver.next(payload);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof item === 'object') {\n\t\t\t\tif (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t\t\t\t\tcompleteObservable(item[idProperty]);\n\t\t\t\t\tcompleteStoreObservers();\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (data && data.has(String(item))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item)));\n\t\t\t\t\tcompleteObservable(item);\n\t\t\t\t\tcompleteStoreObservers();\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn wrapResult(store, false);\n\t\t},\n\t\tfromArray(this: MemoryStore<Object>, items: Object[]): MemoryStorePromise<void> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst map: Object = {};\n\t\t\tconst idProperty = store.idProperty;\n\t\t\titems.forEach((item: { [prop: string]: StoreIndex }, idx: number) => {\n\t\t\t\tconst id = idProperty in item ? item[idProperty] : idx;\n\t\t\t\titem[idProperty] = id;\n\t\t\t\t(<any> map)[id] = item;\n\t\t\t});\n\t\t\tdataWeakMap.set(store, OrderedMap<StoreIndex, Object>(map));\n\t\t\treturn wrapResult(store, undefined);\n\t\t}\n\t}, (instance, options) => {\n\t\tif (options) {\n\t\t\tif (options.idProperty) {\n\t\t\t\tinstance.idProperty = options.idProperty;\n\t\t\t}\n\t\t\tif (options.data) {\n\t\t\t\tinstance.fromArray(options.data);\n\t\t\t}\n\t\t}\n\t})\n\t.mixin(createDestroyable)\n\t.static({\n\t\tfromArray(data: any[]): MemoryStore<any> {\n\t\t\treturn createMemoryStore({ data });\n\t\t}\n\t}) as MemoryStoreFactory;\n\nexport default createMemoryStore;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-stores/createMemoryStore.ts","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable/dist/immutable.js\n// module id = 56\n// module chunks = 0","define([\"require\", \"exports\", './util/root', './symbol/observable', './util/toSubscriber'], function (require, exports, root_1, observable_1, toSubscriber_1) {\n    \"use strict\";\n    /**\n     * A representation of any set of values over any amount of time. This the most basic building block\n     * of RxJS.\n     *\n     * @class Observable<T>\n     */\n    var Observable = (function () {\n        /**\n         * @constructor\n         * @param {Function} subscribe the function that is  called when the Observable is\n         * initially subscribed to. This function is given a Subscriber, to which new values\n         * can be `next`ed, or an `error` method can be called to raise an error, or\n         * `complete` can be called to notify of a successful completion.\n         */\n        function Observable(subscribe) {\n            this._isScalar = false;\n            if (subscribe) {\n                this._subscribe = subscribe;\n            }\n        }\n        /**\n         * Creates a new Observable, with this Observable as the source, and the passed\n         * operator defined as the new observable's operator.\n         * @method lift\n         * @param {Operator} operator the operator defining the operation to take on the observable\n         * @return {Observable} a new observable with the Operator applied\n         */\n        Observable.prototype.lift = function (operator) {\n            var observable = new Observable();\n            observable.source = this;\n            observable.operator = operator;\n            return observable;\n        };\n        /**\n         * Registers handlers for handling emitted values, error and completions from the observable, and\n         *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n         * @method subscribe\n         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n         *  the error will be thrown as unhandled\n         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n         * @return {ISubscription} a subscription reference to the registered handlers\n         */\n        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n            var operator = this.operator;\n            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n            sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n            return sink;\n        };\n        /**\n         * @method forEach\n         * @param {Function} next a handler for each value emitted by the observable\n         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n         * @return {Promise} a promise that either resolves on observable completion or\n         *  rejects with the handled error\n         */\n        Observable.prototype.forEach = function (next, PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                var subscription = _this.subscribe(function (value) {\n                    if (subscription) {\n                        // if there is a subscription, then we can surmise\n                        // the next handling is asynchronous. Any errors thrown\n                        // need to be rejected explicitly and unsubscribe must be\n                        // called manually\n                        try {\n                            next(value);\n                        }\n                        catch (err) {\n                            reject(err);\n                            subscription.unsubscribe();\n                        }\n                    }\n                    else {\n                        // if there is NO subscription, then we're getting a nexted\n                        // value synchronously during subscription. We can just call it.\n                        // If it errors, Observable's `subscribe` imple will ensure the\n                        // unsubscription logic is called, then synchronously rethrow the error.\n                        // After that, Promise will trap the error and send it\n                        // down the rejection path.\n                        next(value);\n                    }\n                }, reject, resolve);\n            });\n        };\n        Observable.prototype._subscribe = function (subscriber) {\n            return this.source.subscribe(subscriber);\n        };\n        /**\n         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n         * @method Symbol.observable\n         * @return {Observable} this instance of the observable\n         */\n        Observable.prototype[observable_1.$$observable] = function () {\n            return this;\n        };\n        // HACK: Since TypeScript inherits static properties too, we have to\n        // fight against TypeScript here so Subject can have a different static create signature\n        /**\n         * Creates a new cold Observable by calling the Observable constructor\n         * @static true\n         * @owner Observable\n         * @method create\n         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n         * @return {Observable} a new cold observable\n         */\n        Observable.create = function (subscribe) {\n            return new Observable(subscribe);\n        };\n        return Observable;\n    }());\n    exports.Observable = Observable;\n});\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Observable.js\n// module id = 57\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    var objectTypes = {\n        'boolean': false,\n        'function': true,\n        'object': true,\n        'number': false,\n        'string': false,\n        'undefined': false\n    };\n    exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n    /* tslint:disable:no-unused-variable */\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n    var freeGlobal = objectTypes[typeof global] && global;\n    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n        exports.root = freeGlobal;\n    }\n});\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/root.js\n// module id = 58\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 59\n// module chunks = 0","define([\"require\", \"exports\", '../util/root'], function (require, exports, root_1) {\n    \"use strict\";\n    var Symbol = root_1.root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            exports.$$observable = Symbol.observable;\n        }\n        else {\n            if (typeof Symbol.for === 'function') {\n                exports.$$observable = Symbol.for('observable');\n            }\n            else {\n                exports.$$observable = Symbol('observable');\n            }\n            Symbol.observable = exports.$$observable;\n        }\n    }\n    else {\n        exports.$$observable = '@@observable';\n    }\n});\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/symbol/observable.js\n// module id = 60\n// module chunks = 0","define([\"require\", \"exports\", '../Subscriber', '../symbol/rxSubscriber'], function (require, exports, Subscriber_1, rxSubscriber_1) {\n    \"use strict\";\n    function toSubscriber(nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver === 'object') {\n            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n                return nextOrObserver;\n            }\n            else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n                return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n            }\n        }\n        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    }\n    exports.toSubscriber = toSubscriber;\n});\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/toSubscriber.js\n// module id = 61\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", './util/isFunction', './Subscription', './symbol/rxSubscriber', './Observer'], function (require, exports, isFunction_1, Subscription_1, rxSubscriber_1, Observer_1) {\n    \"use strict\";\n    /**\n     * Implements the {@link Observer} interface and extends the\n     * {@link Subscription} class. While the {@link Observer} is the public API for\n     * consuming the values of an {@link Observable}, all Observers get converted to\n     * a Subscriber, in order to provide Subscription-like capabilities such as\n     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n     * implementing operators, but it is rarely used as a public API.\n     *\n     * @class Subscriber<T>\n     */\n    var Subscriber = (function (_super) {\n        __extends(Subscriber, _super);\n        /**\n         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n         * defined Observer or a `next` callback function.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         */\n        function Subscriber(destinationOrNext, error, complete) {\n            _super.call(this);\n            this.syncErrorValue = null;\n            this.syncErrorThrown = false;\n            this.syncErrorThrowable = false;\n            this.isStopped = false;\n            switch (arguments.length) {\n                case 0:\n                    this.destination = Observer_1.empty;\n                    break;\n                case 1:\n                    if (!destinationOrNext) {\n                        this.destination = Observer_1.empty;\n                        break;\n                    }\n                    if (typeof destinationOrNext === 'object') {\n                        if (destinationOrNext instanceof Subscriber) {\n                            this.destination = destinationOrNext;\n                            this.destination.add(this);\n                        }\n                        else {\n                            this.syncErrorThrowable = true;\n                            this.destination = new SafeSubscriber(this, destinationOrNext);\n                        }\n                        break;\n                    }\n                default:\n                    this.syncErrorThrowable = true;\n                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                    break;\n            }\n        }\n        /**\n         * A static factory for a Subscriber, given a (potentially partial) definition\n         * of an Observer.\n         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n         * Observer represented by the given arguments.\n         */\n        Subscriber.create = function (next, error, complete) {\n            var subscriber = new Subscriber(next, error, complete);\n            subscriber.syncErrorThrowable = false;\n            return subscriber;\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `next` from\n         * the Observable, with a value. The Observable may call this method 0 or more\n         * times.\n         * @param {T} [value] The `next` value.\n         * @return {void}\n         */\n        Subscriber.prototype.next = function (value) {\n            if (!this.isStopped) {\n                this._next(value);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `error` from\n         * the Observable, with an attached {@link Error}. Notifies the Observer that\n         * the Observable has experienced an error condition.\n         * @param {any} [err] The `error` exception.\n         * @return {void}\n         */\n        Subscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._error(err);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive a valueless notification of type\n         * `complete` from the Observable. Notifies the Observer that the Observable\n         * has finished sending push-based notifications.\n         * @return {void}\n         */\n        Subscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._complete();\n            }\n        };\n        Subscriber.prototype.unsubscribe = function () {\n            if (this.isUnsubscribed) {\n                return;\n            }\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n        };\n        Subscriber.prototype._next = function (value) {\n            this.destination.next(value);\n        };\n        Subscriber.prototype._error = function (err) {\n            this.destination.error(err);\n            this.unsubscribe();\n        };\n        Subscriber.prototype._complete = function () {\n            this.destination.complete();\n            this.unsubscribe();\n        };\n        Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n            return this;\n        };\n        return Subscriber;\n    }(Subscription_1.Subscription));\n    exports.Subscriber = Subscriber;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SafeSubscriber = (function (_super) {\n        __extends(SafeSubscriber, _super);\n        function SafeSubscriber(_parent, observerOrNext, error, complete) {\n            _super.call(this);\n            this._parent = _parent;\n            var next;\n            var context = this;\n            if (isFunction_1.isFunction(observerOrNext)) {\n                next = observerOrNext;\n            }\n            else if (observerOrNext) {\n                context = observerOrNext;\n                next = observerOrNext.next;\n                error = observerOrNext.error;\n                complete = observerOrNext.complete;\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n            this._context = context;\n            this._next = next;\n            this._error = error;\n            this._complete = complete;\n        }\n        SafeSubscriber.prototype.next = function (value) {\n            if (!this.isStopped && this._next) {\n                var _parent = this._parent;\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._next, value);\n                }\n                else if (this.__tryOrSetError(_parent, this._next, value)) {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _parent = this._parent;\n                if (this._error) {\n                    if (!_parent.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._error, err);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parent, this._error, err);\n                        this.unsubscribe();\n                    }\n                }\n                else if (!_parent.syncErrorThrowable) {\n                    this.unsubscribe();\n                    throw err;\n                }\n                else {\n                    _parent.syncErrorValue = err;\n                    _parent.syncErrorThrown = true;\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                var _parent = this._parent;\n                if (this._complete) {\n                    if (!_parent.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._complete);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parent, this._complete);\n                        this.unsubscribe();\n                    }\n                }\n                else {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                this.unsubscribe();\n                throw err;\n            }\n        };\n        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            return false;\n        };\n        SafeSubscriber.prototype._unsubscribe = function () {\n            var _parent = this._parent;\n            this._context = null;\n            this._parent = null;\n            _parent.unsubscribe();\n        };\n        return SafeSubscriber;\n    }(Subscriber));\n});\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Subscriber.js\n// module id = 62\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    function isFunction(x) {\n        return typeof x === 'function';\n    }\n    exports.isFunction = isFunction;\n});\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isFunction.js\n// module id = 63\n// module chunks = 0","define([\"require\", \"exports\", './util/isArray', './util/isObject', './util/isFunction', './util/tryCatch', './util/errorObject', './util/UnsubscriptionError'], function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n    \"use strict\";\n    /**\n     * Represents a disposable resource, such as the execution of an Observable. A\n     * Subscription has one important method, `unsubscribe`, that takes no argument\n     * and just disposes the resource held by the subscription.\n     *\n     * Additionally, subscriptions may be grouped together through the `add()`\n     * method, which will attach a child Subscription to the current Subscription.\n     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n     * will be unsubscribed as well.\n     *\n     * @class Subscription\n     */\n    var Subscription = (function () {\n        /**\n         * @param {function(): void} [unsubscribe] A function describing how to\n         * perform the disposal of resources when the `unsubscribe` method is called.\n         */\n        function Subscription(unsubscribe) {\n            /**\n             * A flag to indicate whether this Subscription has already been unsubscribed.\n             * @type {boolean}\n             */\n            this.isUnsubscribed = false;\n            if (unsubscribe) {\n                this._unsubscribe = unsubscribe;\n            }\n        }\n        /**\n         * Disposes the resources held by the subscription. May, for instance, cancel\n         * an ongoing Observable execution or cancel any other type of work that\n         * started when the Subscription was created.\n         * @return {void}\n         */\n        Subscription.prototype.unsubscribe = function () {\n            var hasErrors = false;\n            var errors;\n            if (this.isUnsubscribed) {\n                return;\n            }\n            this.isUnsubscribed = true;\n            var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n            this._subscriptions = null;\n            if (isFunction_1.isFunction(_unsubscribe)) {\n                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n                if (trial === errorObject_1.errorObject) {\n                    hasErrors = true;\n                    (errors = errors || []).push(errorObject_1.errorObject.e);\n                }\n            }\n            if (isArray_1.isArray(_subscriptions)) {\n                var index = -1;\n                var len = _subscriptions.length;\n                while (++index < len) {\n                    var sub = _subscriptions[index];\n                    if (isObject_1.isObject(sub)) {\n                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                        if (trial === errorObject_1.errorObject) {\n                            hasErrors = true;\n                            errors = errors || [];\n                            var err = errorObject_1.errorObject.e;\n                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                                errors = errors.concat(err.errors);\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n            }\n            if (hasErrors) {\n                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n            }\n        };\n        /**\n         * Adds a tear down to be called during the unsubscribe() of this\n         * Subscription.\n         *\n         * If the tear down being added is a subscription that is already\n         * unsubscribed, is the same reference `add` is being called on, or is\n         * `Subscription.EMPTY`, it will not be added.\n         *\n         * If this subscription is already in an `isUnsubscribed` state, the passed\n         * tear down logic will be executed immediately.\n         *\n         * @param {TeardownLogic} teardown The additional logic to execute on\n         * teardown.\n         * @return {Subscription} Returns the Subscription used or created to be\n         * added to the inner subscriptions list. This Subscription can be used with\n         * `remove()` to remove the passed teardown logic from the inner subscriptions\n         * list.\n         */\n        Subscription.prototype.add = function (teardown) {\n            if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n                return;\n            }\n            var sub = teardown;\n            switch (typeof teardown) {\n                case 'function':\n                    sub = new Subscription(teardown);\n                case 'object':\n                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                        break;\n                    }\n                    else if (this.isUnsubscribed) {\n                        sub.unsubscribe();\n                    }\n                    else {\n                        (this._subscriptions || (this._subscriptions = [])).push(sub);\n                    }\n                    break;\n                default:\n                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n            return sub;\n        };\n        /**\n         * Removes a Subscription from the internal list of subscriptions that will\n         * unsubscribe during the unsubscribe process of this Subscription.\n         * @param {Subscription} subscription The subscription to remove.\n         * @return {void}\n         */\n        Subscription.prototype.remove = function (subscription) {\n            // HACK: This might be redundant because of the logic in `add()`\n            if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n                return;\n            }\n            var subscriptions = this._subscriptions;\n            if (subscriptions) {\n                var subscriptionIndex = subscriptions.indexOf(subscription);\n                if (subscriptionIndex !== -1) {\n                    subscriptions.splice(subscriptionIndex, 1);\n                }\n            }\n        };\n        Subscription.EMPTY = (function (empty) {\n            empty.isUnsubscribed = true;\n            return empty;\n        }(new Subscription()));\n        return Subscription;\n    }());\n    exports.Subscription = Subscription;\n});\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Subscription.js\n// module id = 64\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n});\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isArray.js\n// module id = 65\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    function isObject(x) {\n        return x != null && typeof x === 'object';\n    }\n    exports.isObject = isObject;\n});\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isObject.js\n// module id = 66\n// module chunks = 0","define([\"require\", \"exports\", './errorObject'], function (require, exports, errorObject_1) {\n    \"use strict\";\n    var tryCatchTarget;\n    function tryCatcher() {\n        try {\n            return tryCatchTarget.apply(this, arguments);\n        }\n        catch (e) {\n            errorObject_1.errorObject.e = e;\n            return errorObject_1.errorObject;\n        }\n    }\n    function tryCatch(fn) {\n        tryCatchTarget = fn;\n        return tryCatcher;\n    }\n    exports.tryCatch = tryCatch;\n    ;\n});\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/tryCatch.js\n// module id = 67\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    // typeof any so that it we don't have to cast when comparing a result to the error object\n    exports.errorObject = { e: {} };\n});\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/errorObject.js\n// module id = 68\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    /**\n     * An error thrown when one or more errors have occurred during the\n     * `unsubscribe` of a {@link Subscription}.\n     */\n    var UnsubscriptionError = (function (_super) {\n        __extends(UnsubscriptionError, _super);\n        function UnsubscriptionError(errors) {\n            _super.call(this);\n            this.errors = errors;\n            this.name = 'UnsubscriptionError';\n            this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n        }\n        return UnsubscriptionError;\n    }(Error));\n    exports.UnsubscriptionError = UnsubscriptionError;\n});\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/UnsubscriptionError.js\n// module id = 69\n// module chunks = 0","define([\"require\", \"exports\", '../util/root'], function (require, exports, root_1) {\n    \"use strict\";\n    var Symbol = root_1.root.Symbol;\n    exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n});\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/symbol/rxSubscriber.js\n// module id = 70\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.empty = {\n        isUnsubscribed: true,\n        next: function (value) { },\n        error: function (err) { throw err; },\n        complete: function () { }\n    };\n});\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Observer.js\n// module id = 71\n// module chunks = 0","import createMemoryStore, { MemoryStore } from 'dojo-stores/createMemoryStore';\nimport { putCard } from './../actions/widgetStoreActions';\nimport { from as arrayFrom } from 'dojo-shim/array';\n\nexport interface Card {\n\tid: string;\n\tcardType: 'momentum' | 'mayhem';\n\tname: string;\n\ttagline: string;\n\tdescription: string;\n\tscore: number;\n\timageClass: string;\n\tfavouriteCount: number;\n}\n\nexport type Store = MemoryStore<Card>;\n\nconst cardStore: Store = createMemoryStore<Card>({\n\tdata: [\n\t\t{ id: 'card-1', cardType: 'momentum', name: 'Brainstorming', description: 'People\\'s best ideas often come to them when they\\'re alone, but so do their worst. Your team brainstorms to build on each other\\'s great ideas.', score: 1, tagline: '', imageClass: 'Cards-Momentum1', favouriteCount: 0 },\n\t\t{ id: 'card-2', cardType: 'momentum', name: 'Clear Objectives', description: 'You tell your team that knowing the goal of the task is far more important than understanding the specific words of the request.', score: 3, tagline: '', imageClass: 'Cards-Momentum2', favouriteCount: 0 },\n\t\t{ id: 'card-3', cardType: 'momentum', name: 'Code Conventions', description: 'While tabs are superior to spaces in every way, the most important thing is that everyone on the project is structuring their code the same way.', score: 1, tagline: '', imageClass: 'Cards-Momentum3', favouriteCount: 0 },\n\t\t{ id: 'card-4', cardType: 'momentum', name: 'Code Reviews', description: 'The major benefit of your code review initiative wasn\\'t reducing errors, but in the camaraderie it built between engineers.', score: 4, tagline: '', imageClass: 'Cards-Momentum4', favouriteCount: 0 },\n\t\t{ id: 'card-5', cardType: 'momentum', name: 'Collaboration', description: 'Through collaboration, your team sees more of the big picture then most, enabling them to make better decisions.', score: 1, tagline: '', imageClass: 'Cards-Momentum5', favouriteCount: 0 },\n\t\t{ id: 'card-6', cardType: 'momentum', name: 'Communication', description: 'Your team communicates effectively, helping to avoid last minute scrambles and missed milestones.', score: 3, tagline: '', imageClass: 'Cards-Momentum6', favouriteCount: 0 },\n\t\t{ id: 'card-7', cardType: 'momentum', name: 'Decision Makers', description: 'Your team feels empowered to make important real-time decisions, removing minor roadblocks before they impact the entire project.', score: 4, tagline: '', imageClass: 'Cards-Momentum7', favouriteCount: 0 },\n\t\t{ id: 'card-8', cardType: 'momentum', name: 'Delegation', description: 'You let your team know that you don\\'t have to be involved in every decision. You trust them to use their judgement.', score: 2, tagline: '', imageClass: 'Cards-Momentum8', favouriteCount: 0 },\n\t\t{ id: 'card-9', cardType: 'momentum', name: 'Design Iteration', description: 'Your designers and developers iterate together to make sure that what\\'s being designed and built delivers the best possible experience', score: 2, tagline: '', imageClass: 'Cards-Momentum9', favouriteCount: 0 },\n\t\t{ id: 'card-10', cardType: 'momentum', name: 'Donuts!', description: 'Let\\'s be honest, we all revert to a childlike state when in the presence of sprinkled donuts.', score: 3, tagline: '', imageClass: 'Cards-Momentum10', favouriteCount: 0 },\n\t\t{ id: 'card-11', cardType: 'momentum', name: 'Feedback', description: 'You encourage the team to raise issues as they see them instead of letting them fester, even if the issue is you.', score: 2, tagline: '', imageClass: 'Cards-Momentum11', favouriteCount: 0 },\n\t\t{ id: 'card-12', cardType: 'momentum', name: 'Focused Meetings', description: 'You convinced \"The Inviter\" that the entire development team didn\\'t need to attend the weekly marketing meeting.', score: 1, tagline: '', imageClass: 'Cards-Momentum12', favouriteCount: 0 },\n\t\t{ id: 'card-13', cardType: 'momentum', name: 'Future Proofing', description: 'Your team not only solves the immediate problem, but works hard to ensure they aren\\'t creating new ones down the road.', score: 1, tagline: '', imageClass: 'Cards-Momentum13', favouriteCount: 0 },\n\t\t{ id: 'card-14', cardType: 'momentum', name: 'Hackathon', description: 'At the monthly hackathon you organized, the team came up with a clever way to improve the performance of your app.', score: 3, tagline: '', imageClass: 'Cards-Momentum14', favouriteCount: 0 },\n\t\t{ id: 'card-15', cardType: 'momentum', name: 'Integrated Teams', description: 'The project really started humming when you created small integrated teams of designers and engineers focused on specific features of the project.', score: 1, tagline: '', imageClass: 'Cards-Momentum15', favouriteCount: 0 },\n\t\t{ id: 'card-16', cardType: 'momentum', name: 'Leadership', description: 'You have built a team that believes leadership is a quality present in everyone and not inhereted from the top-down.', score: 4, tagline: '', imageClass: 'Cards-Momentum16', favouriteCount: 0 },\n\t\t{ id: 'card-17', cardType: 'momentum', name: 'Modern Tools', description: 'Moving to a modern toolchain cut down your build & deploy step from 12 minutes to 15 seconds.', score: 1, tagline: '', imageClass: 'Cards-Momentum17', favouriteCount: 0 },\n\t\t{ id: 'card-18', cardType: 'momentum', name: 'Open Source', description: 'Despite the Legal team\\'s fears of exploits and foreign hackers, they finally agreed to let you use \"Open Software\", as long as you \"close it up\".', score: 2, tagline: '', imageClass: 'Cards-Momentum18', favouriteCount: 0 },\n\t\t{ id: 'card-19', cardType: 'momentum', name: 'Planning', description: 'Knowing you could not control the other team, you influenced them by leading by example and demonstrating you had a viable plan to follow.', score: 2, tagline: '', imageClass: 'Cards-Momentum19', favouriteCount: 0 },\n\t\t{ id: 'card-20', cardType: 'momentum', name: 'Prioritization', description: 'You looked the VP right in the eye and told him that if everything is a top priority, nothing is.', score: 2, tagline: '', imageClass: 'Cards-Momentum20', favouriteCount: 0 },\n\t\t{ id: 'card-21', cardType: 'momentum', name: 'Recognition', description: 'When a VP thanked you for your good work on the latest demo, you asked the VP to thank your team in person, as well.', score: 4, tagline: '', imageClass: 'Cards-Momentum21', favouriteCount: 0 },\n\t\t{ id: 'card-22', cardType: 'momentum', name: 'Recruiting', description: 'Hiring a great team has become your best recruiting tool. Smart people want to work with other smart people.', score: 1, tagline: '', imageClass: 'Cards-Momentum22', favouriteCount: 0 },\n\t\t{ id: 'card-23', cardType: 'momentum', name: 'Requirements', description: 'Your team reviews each requirement in detail before starting each milestone to identify any gray areas that can be quickly clarified.', score: 3, tagline: '', imageClass: 'Cards-Momentum23', favouriteCount: 0 },\n\t\t{ id: 'card-24', cardType: 'momentum', name: 'Reusable Code', description: 'You save the orginization months of development hours by setting up a shared code repository', score: 2, tagline: '', imageClass: 'Cards-Momentum24', favouriteCount: 0 },\n\t\t{ id: 'card-25', cardType: 'momentum', name: 'Solid Architecture', description: 'Your architecture weathered the storm of changing business needs, letting your team focus on quickly delivering business value.', score: 1, tagline: '', imageClass: 'Cards-Momentum25', favouriteCount: 0 },\n\t\t{ id: 'card-26', cardType: 'momentum', name: 'Testing Plan', description: 'Your team \\'miraculously\\' knew if their code was working before they shipped it, avoiding rework.', score: 4, tagline: '', imageClass: 'Cards-Momentum26', favouriteCount: 0 },\n\t\t{ id: 'card-27', cardType: 'momentum', name: 'The A-Team', description: 'Your team has been called in to save the day in a flailing project, and they turn it around, but you still \\'don\\'t pity the fool!', score: 1, tagline: '', imageClass: 'Cards-Momentum27', favouriteCount: 0 },\n\t\t{ id: 'card-28', cardType: 'momentum', name: 'Unit Testing', description: 'Woah! The new developer on the team made their first commit in under a day, and the unit tests saved them from breaking the build.', score: 1, tagline: '', imageClass: 'Cards-Momentum28', favouriteCount: 0 },\n\t\t{ id: 'card-29', cardType: 'momentum', name: 'Work/Life Balance', description: 'Your team offered to work the weekend to get ahead of the game, but you let them know that personal time was more important.', score: 1, tagline: '', imageClass: 'Cards-Momentum29', favouriteCount: 0 },\n\t\t{ id: 'card-30', cardType: 'momentum', name: 'Workshops', description: 'Technology moves fast, but you\\'ve invested in your team by providing ongoing education. Your team is up to speed while others are stagnating.', score: 2, tagline: '', imageClass: 'Cards-Momentum30', favouriteCount: 0 },\n\t\t{ id: 'card-31', cardType: 'mayhem', name: 'Blunderer', description: 'The build broke...again! Some people on your team know just enough to be dangerous.', score: 1, tagline: '', imageClass: 'Cards-Mayhem1', favouriteCount: 0 },\n\t\t{ id: 'card-32', cardType: 'mayhem', name: 'Brain Drain', description: 'The only person who understands how your legacy app works just left for a hot, new startup.', score: 3, tagline: '', imageClass: 'Cards-Mayhem2', favouriteCount: 0 },\n\t\t{ id: 'card-33', cardType: 'mayhem', name: 'Dead-Line', description: 'The VP of Sales informs you that your project will need to be finished a few weeks early. No biggie, right?', score: 1, tagline: '', imageClass: 'Cards-Mayhem3', favouriteCount: 0 },\n\t\t{ id: 'card-34', cardType: 'mayhem', name: 'Dr. Deflector', description: 'Features were announced that aren\\'t even on the roadmap. Somehow, it\\'s your fault they won\\'t be included.', score: 4, tagline: '', imageClass: 'Cards-Mayhem4', favouriteCount: 0 },\n\t\t{ id: 'card-35', cardType: 'mayhem', name: 'Gen. Death March', description: 'Despite your plea for more time, the only thing you received was permission to work harder.', score: 1, tagline: '', imageClass: 'Cards-Mayhem5', favouriteCount: 0 },\n\t\t{ id: 'card-36', cardType: 'mayhem', name: 'Grim Repo', description: 'The wrong branch was merged into production. Untangling this mess is going to be a nightmare.', score: 3, tagline: '', imageClass: 'Cards-Mayhem6', favouriteCount: 0 },\n\t\t{ id: 'card-37', cardType: 'mayhem', name: 'King of Confusion', description: 'At a recent meeting to get everyone on the same page, it turned out that nobody was even in the same book.', score: 4, tagline: '', imageClass: 'Cards-Mayhem7', favouriteCount: 0 },\n\t\t{ id: 'card-38', cardType: 'mayhem', name: 'Landmine', description: 'Half of the requirements say \"TBD Later\". It\\'s well past later and nobody has determined anything.', score: 2, tagline: '', imageClass: 'Cards-Mayhem8', favouriteCount: 0 },\n\t\t{ id: 'card-39', cardType: 'mayhem', name: 'Pet Pony', description: 'Just like a six-year-old who wants a pony, stakeholders want their new ideas implemented NOW!', score: 2, tagline: '', imageClass: 'Cards-Mayhem9', favouriteCount: 0 },\n\t\t{ id: 'card-40', cardType: 'mayhem', name: 'Scope Creep', description: 'Apparently, a \"few small changes\" means 17 new user stories.', score: 3, tagline: '', imageClass: 'Cards-Mayhem10', favouriteCount: 0 },\n\t\t{ id: 'card-41', cardType: 'mayhem', name: 'Slingshot', description: 'DevOps changed the authentication scheme but how it affects your project is \"not their problem\".', score: 2, tagline: '', imageClass: 'Cards-Mayhem11', favouriteCount: 0 },\n\t\t{ id: 'card-42', cardType: 'mayhem', name: 'The Eraser', description: 'The only thing complete about the UI design is how completely lacking it is in detail.', score: 1, tagline: '', imageClass: 'Cards-Mayhem12', favouriteCount: 0 },\n\t\t{ id: 'card-43', cardType: 'mayhem', name: 'The Gambler', description: 'The closer the deadline gets, the more liberal your team becomes with the definition of \"done\".', score: 1, tagline: '', imageClass: 'Cards-Mayhem13', favouriteCount: 0 },\n\t\t{ id: 'card-44', cardType: 'mayhem', name: 'The Horde', description: 'Instead of more time to meet your requirements, you got a dozen untrained interns to \"help\".', score: 3, tagline: '', imageClass: 'Cards-Mayhem14', favouriteCount: 0 },\n\t\t{ id: 'card-45', cardType: 'mayhem', name: 'The Inventor', description: 'When discussing what framework to use, an enthusiastic voice says, \"We\\'ll just roll our own!\"', score: 1, tagline: '', imageClass: 'Cards-Mayhem15', favouriteCount: 0 },\n\t\t{ id: 'card-46', cardType: 'mayhem', name: 'The Inviter', description: 'You and your team have been invited to daily meetings to discuss your \"lack of progress\".', score: 4, tagline: '', imageClass: 'Cards-Mayhem16', favouriteCount: 0 },\n\t\t{ id: 'card-47', cardType: 'mayhem', name: 'The Juggler', description: 'Flimsy dates, changing priorities and bad assumptions are the pillars of your project manager\\'s master plan!', score: 1, tagline: '', imageClass: 'Cards-Mayhem17', favouriteCount: 0 },\n\t\t{ id: 'card-48', cardType: 'mayhem', name: 'Sigh-Low', description: 'While on a conference call it becomes painfully clear...two different teams just completed the same work.', score: 2, tagline: '', imageClass: 'Cards-Mayhem18', favouriteCount: 0 },\n\t\t{ id: 'card-49', cardType: 'mayhem', name: 'Caveman Coder', description: 'You brought in a contractor, who smashed your code until it \"worked\" and then he committed it to master.', score: 2, tagline: '', imageClass: 'Cards-Mayhem19', favouriteCount: 0 }\n\t]\n});\n\nexport interface ChangeRecord {\n\tbeforeAll: Card[];\n\tafterAll: Card[];\n\tdeletes: string[];\n\tputs: Card[];\n}\n\nexport function bindActions() {\n\treturn cardStore.observe().subscribe((options: any) => {\n\t\tconst changeRecord = <ChangeRecord> options;\n\t\treturn putCard.do(changeRecord);\n\t});\n}\n\nexport function getShuffledCards(): Promise<Card[]> {\n\treturn cardStore.get().then((cards: any) => {\n\t\tconst shuffledArray = <Card[]> arrayFrom(cards);\n\t\tlet i = 0;\n\t\tlet\tj = 0;\n\t\tlet\ttemp: Card;\n\n\t\tfor (i = shuffledArray.length - 1; i > 0; i -= 1) {\n\t\t\tj = Math.floor(Math.random() * (i + 1));\n\t\t\ttemp = shuffledArray[i];\n\t\t\tshuffledArray[i] = shuffledArray[j];\n\t\t\tshuffledArray[j] = temp;\n\t\t}\n\n\t\treturn shuffledArray;\n\t});\n}\n\nexport function pickRandomCards(numberToPick: number, exclude: string[] = []): Promise<Card[]> {\n\treturn getShuffledCards().then((cards) => {\n\t\tconst filteredCards = cards.filter((card: Card) => exclude.indexOf(card.id) < 0);\n\t\treturn filteredCards.slice(0, Math.min(filteredCards.length, numberToPick));\n\t});\n}\n\nexport default cardStore;\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/cardStore.ts","import createAction from 'dojo-actions/createAction';\n\nimport { ChangeRecord, Card } from '../stores/cardStore';\nimport widgetStore from '../stores/widgetStore';\n\nimport { CardState } from '../widgets/card/createCard';\nimport { CardSummaryState } from '../widgets/card/createCardSummary';\n\nfunction getStates(cards: Card[]): [ CardState[], CardSummaryState[] ] {\n\tconst cardStates: CardState[] = [];\n\tconst cardSummaryStates: CardSummaryState[] = [];\n\n\tcards.forEach(function ({ id, name, imageClass, score }) {\n\t\tcardStates.push({ id, imageClass });\n\t\tcardSummaryStates.push({ name, imageClass, score, id });\n\t});\n\n\treturn [ cardStates, cardSummaryStates ];\n}\n\nexport const putCard = createAction({\n\tdo({ afterAll, puts }: ChangeRecord) {\n\t\tif (puts.length) {\n\t\t\tconst [ cardStates, cardSummaryStates ] = getStates(afterAll);\n\n\t\t\twidgetStore.patch({ id: 'cards', cards: cardSummaryStates });\n\t\t\twidgetStore.patch({ id: 'cardDetails', cards: cardStates });\n\t\t}\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/widgetStoreActions.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport { DNode, Widget, WidgetOptions, WidgetState } from 'dojo-widgets/interfaces';\nimport { w } from 'dojo-widgets/d';\nimport createProjector, { Projector, ProjectorOptions } from 'dojo-widgets/createProjector';\n\nimport createNavbar from './widgets/navbar/createNavbar';\nimport createHomePage from './widgets/home/createHomePage';\nimport createCardDetailsPage from './widgets/card-details/createCardDetailsPage';\nimport createCardsPage from './widgets/cards/createCardsPage';\nimport createGameplayPage from './widgets/gameplay/createGameplayPage';\nimport createAboutPage from './widgets/about/createAboutPage';\n\ninterface AppState extends WidgetState {\n\troute?: string;\n}\n\ntype App = Widget<AppState> & Projector;\n\ninterface AppFactory extends ComposeFactory<App, ProjectorOptions> {}\n\nlet previousRouteDNode: DNode;\n\nfunction getPageFromRoute(instance: App) {\n\tconst { state } = instance;\n\tlet routeDNode: DNode;\n\tconst options: WidgetOptions<WidgetState> = {\n\t\tid: state.route,\n\t\tstateFrom: instance.stateFrom\n\t};\n\n\tswitch (state.route) {\n\t\tcase 'home':\n\t\t\trouteDNode = w(createHomePage, options);\n\t\t\tbreak;\n\t\tcase 'cards':\n\t\t\trouteDNode = w(createCardsPage, options);\n\t\t\tbreak;\n\t\tcase 'cardDetails':\n\t\t\trouteDNode = w(createCardDetailsPage, options);\n\t\t\tbreak;\n\t\tcase 'gameplay':\n\t\t\trouteDNode = w(createGameplayPage, options);\n\t\t\tbreak;\n\t\tcase 'about':\n\t\t\trouteDNode = w(createAboutPage, options);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (previousRouteDNode) {\n\t\t\t\trouteDNode = previousRouteDNode;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trouteDNode = w(createHomePage, options);\n\t\t\t}\n\t}\n\tpreviousRouteDNode = routeDNode;\n\treturn routeDNode;\n}\n\nconst createApp: AppFactory = createProjector.mixin({\n\tmixin: {\n\t\tgetChildrenNodes: function(this: App): DNode[] {\n\t\t\tconst { stateFrom } = this;\n\t\t\tif (this.state.route) {\n\t\t\t\treturn [\n\t\t\t\t\tw(createNavbar, <WidgetOptions<WidgetState>> { id: 'navbar', stateFrom }),\n\t\t\t\t\tgetPageFromRoute(this)\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t},\n\t\ttagName: 'main'\n\t}\n});\n\nexport default createApp;\n\n\n\n// WEBPACK FOOTER //\n// ./src/app.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport { assign } from 'dojo-core/lang';\nimport { VNode, VNodeProperties } from 'dojo-interfaces/vdom';\nimport { h } from 'maquette';\nimport {\n\tDNode,\n\tHNode,\n\tWNode,\n\tWidget,\n\tWidgetOptions,\n\tWidgetState\n} from './interfaces';\nimport FactoryRegistry from './FactoryRegistry';\n\nexport const registry = new FactoryRegistry();\n\nexport function w<S extends WidgetState, W extends Widget<S>, O extends WidgetOptions<S>>(\n\tfactory: ComposeFactory<W, O> | string,\n\toptions: O\n): WNode;\nexport function w<S extends WidgetState, W extends Widget<S>, O extends WidgetOptions<S>>(\n\tfactory: ComposeFactory<W, O> | string,\n\toptions: O,\n\tchildren?: DNode[]\n): WNode;\nexport function w<S extends WidgetState, W extends Widget<S>, O extends WidgetOptions<S>>(\n\tfactory: ComposeFactory<W, O> | string,\n\toptions: O,\n\tchildren: DNode[] = []\n): WNode {\n\n\treturn {\n\t\tchildren,\n\t\tfactory,\n\t\toptions\n\t};\n}\n\nexport function v(tag: string, options: VNodeProperties, children?: DNode[]): HNode;\nexport function v(tag: string, children: DNode[]): HNode;\nexport function v(tag: string): HNode;\nexport function v(tag: string, optionsOrChildren: VNodeProperties = {}, children: DNode[] = []): HNode {\n\n\t\tif (Array.isArray(optionsOrChildren)) {\n\t\t\tchildren = optionsOrChildren;\n\t\t\toptionsOrChildren = {};\n\t\t}\n\n\t\treturn {\n\t\t\tchildren,\n\t\t\trender<T>(this: { children: VNode[] }, options: { bind?: T } = { }) {\n\t\t\t\treturn h(tag, assign(options, optionsOrChildren), this.children);\n\t\t\t}\n\t\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/d.ts","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    'use strict';\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children\n            ]);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute('type', vnode.properties.type);\n                            }\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < argsLength; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/maquette/dist/maquette.js\n// module id = 76\n// module chunks = 0","import { isComposeFactory } from 'dojo-compose/compose';\nimport Promise from 'dojo-shim/Promise';\nimport Map from 'dojo-shim/Map';\nimport {\n\tWidgetFactory,\n\tFactoryRegistryInterface,\n\tFactoryRegistryItem,\n\tWidgetFactoryFunction\n} from './interfaces';\n\nexport default class FactoryRegistry implements FactoryRegistryInterface {\n\tprotected registry: Map<string, FactoryRegistryItem>;\n\n\tconstructor() {\n\t\tthis.registry = new Map<string, FactoryRegistryItem>();\n\t}\n\n\thas(factoryLabel: string): boolean {\n\t\treturn this.registry.has(factoryLabel);\n\t}\n\n\tdefine(factoryLabel: string, registryItem: FactoryRegistryItem): void {\n\t\tif (this.registry.has(factoryLabel)) {\n\t\t\tthrow new Error(`factory has already been registered for '${factoryLabel}'`);\n\t\t}\n\t\tthis.registry.set(factoryLabel, registryItem);\n\t}\n\n\tget(factoryLabel: string): WidgetFactory | Promise<WidgetFactory> | null {\n\t\tif (!this.has(factoryLabel)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = this.registry.get(factoryLabel);\n\n\t\tif (isComposeFactory(item) || item instanceof Promise) {\n\t\t\treturn item;\n\t\t}\n\n\t\tconst promise = (<WidgetFactoryFunction> item)();\n\t\tthis.registry.set(factoryLabel, promise);\n\n\t\treturn promise.then((factory) => {\n\t\t\tthis.registry.set(factoryLabel, factory);\n\t\t\treturn factory;\n\t\t}, (error) => {\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/FactoryRegistry.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport { EventTargettedObject, Handle } from 'dojo-interfaces/core';\nimport { VNode, VNodeProperties } from 'dojo-interfaces/vdom';\nimport { Widget, WidgetState, WidgetOptions } from './interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { createProjector as createMaquetteProjector, Projector as MaquetteProjector } from 'maquette';\nimport createWidgetBase from './createWidgetBase';\nimport global from 'dojo-core/global';\nimport Promise from 'dojo-shim/Promise';\n\n/**\n * Represents the state of the projector\n */\nexport enum ProjectorState {\n\tAttached = 1,\n\tDetached\n};\n\n/**\n * Attach type for the projector\n */\nexport enum AttachType {\n\tAppend = 1,\n\tMerge = 2,\n\tReplace = 3\n};\n\nexport interface AttachOptions {\n\n\t/**\n\t * If `'append'` it will append to the root. If `'merge'` it will merge with the root. If `'replace'` it will\n\t * replace the root.\n\t */\n\ttype: AttachType;\n}\n\n/**\n * Projector interface\n */\nexport interface ProjectorOptions extends WidgetOptions<WidgetState> {\n\n\t/**\n\t * An optional root of the projector\n\t */\n\troot?: Element;\n\n\t/**\n\t * If `true`, will configure the projector to support css transitions using `cssTransitions` global object.\n\t * The projector will fail create if the options is true but the global object cannot be found.\n\t */\n\tcssTransitions?: boolean;\n}\n\nexport interface ProjectorMixin {\n\n\t/**\n\t * Append the projector to the root.\n\t */\n\tappend(): Promise<Handle>;\n\n\t/**\n\t * Merge the projector onto the root.\n\t */\n\tmerge(): Promise<Handle>;\n\n\t/**\n\t * Replace the root with the projector node.\n\t *\n\t *\n\t */\n\treplace(): Promise<Handle>;\n\n\t/**\n\t * Root element to attach the projector\n\t */\n\troot: Element;\n\n\t/**\n\t * The Maquette projector\n\t */\n\treadonly projector: MaquetteProjector;\n\n\t/**\n\t * The status of the projector\n\t */\n\treadonly projectorState: ProjectorState;\n}\n\n/**\n * Internal projector state\n */\ninterface ProjectorData {\n\tprojector: MaquetteProjector;\n\troot: Element;\n\tstate: ProjectorState;\n\tattachPromise?: Promise<Handle>;\n\tattachHandle?: Handle;\n\tafterCreate?: () => void;\n}\n\nexport type Projector = Widget<WidgetState> & ProjectorMixin;\n\nexport interface ProjectorFactory extends ComposeFactory<Projector, ProjectorOptions> { }\n\n/**\n * Private state map keyed by instance.\n */\nconst projectorDataMap = new WeakMap<Projector, ProjectorData>();\n\n/**\n * Schedules a render.\n */\nfunction scheduleRender(event: EventTargettedObject<Projector>) {\n\tconst { target: projector } = event;\n\tconst projectorData = projectorDataMap.get(projector);\n\tif (projectorData.state === ProjectorState.Attached) {\n\t\tprojector.emit({\n\t\t\ttype: 'render:scheduled',\n\t\t\ttarget: projector\n\t\t});\n\t\tprojectorData.projector.scheduleRender();\n\t}\n}\n\nfunction attach(instance: Projector, { type }: AttachOptions) {\n\tconst projectorData = projectorDataMap.get(instance);\n\tconst render = instance.render.bind(instance);\n\n\tif (projectorData.state === ProjectorState.Attached) {\n\t\treturn projectorData.attachPromise || Promise.resolve({});\n\t}\n\tprojectorData.state = ProjectorState.Attached;\n\n\tprojectorData.attachHandle = instance.own({\n\t\tdestroy() {\n\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\tprojectorData.projector.stop();\n\t\t\t\tprojectorData.projector.detach(render);\n\t\t\t\tprojectorData.state = ProjectorState.Detached;\n\t\t\t}\n\t\t\tprojectorData.attachHandle = { destroy() {} };\n\t\t}\n\t});\n\n\tprojectorData.attachPromise = new Promise((resolve, reject) => {\n\t\tprojectorData.afterCreate = () => {\n\t\t\tinstance.emit({\n\t\t\t\ttype: 'projector:attached',\n\t\t\t\ttarget: instance\n\t\t\t});\n\t\t\tresolve(projectorData.attachHandle);\n\t\t};\n\t});\n\n\tswitch (type) {\n\t\tcase AttachType.Append:\n\t\t\tprojectorData.projector.append(projectorData.root, render);\n\t\tbreak;\n\t\tcase AttachType.Merge:\n\t\t\tprojectorData.projector.merge(projectorData.root, render);\n\t\tbreak;\n\t\tcase AttachType.Replace:\n\t\t\tprojectorData.projector.replace(projectorData.root, render);\n\t\tbreak;\n\t}\n\n\treturn projectorData.attachPromise;\n}\n\n/**\n * Projector Factory\n */\nconst createProjector: ProjectorFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\tappend(this: Projector) {\n\t\t\t\tconst options = {\n\t\t\t\t\ttype: AttachType.Append\n\t\t\t\t};\n\n\t\t\t\treturn attach(this, options);\n\t\t\t},\n\n\t\t\tmerge(this: Projector) {\n\t\t\t\tconst options = {\n\t\t\t\t\ttype: AttachType.Merge\n\t\t\t\t};\n\n\t\t\t\treturn attach(this, options);\n\t\t\t},\n\n\t\t\treplace(this: Projector) {\n\t\t\t\tconst options = {\n\t\t\t\t\ttype: AttachType.Replace\n\t\t\t\t};\n\n\t\t\t\treturn attach(this, options);\n\t\t\t},\n\n\t\t\tset root(this: Projector, root: Element) {\n\t\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\t\tthrow new Error('Projector already attached, cannot change root element');\n\t\t\t\t}\n\t\t\t\tprojectorData.root = root;\n\t\t\t},\n\n\t\t\tget root(this: Projector): Element {\n\t\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\t\treturn projectorData && projectorData.root;\n\t\t\t},\n\n\t\t\tget projector(this: Projector): MaquetteProjector {\n\t\t\t\treturn projectorDataMap.get(this).projector;\n\t\t\t},\n\n\t\t\tget projectorState(this: Projector): ProjectorState {\n\t\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\t\treturn projectorData && projectorData.state;\n\t\t\t}\n\t\t},\n\t\taspectAdvice: {\n\t\t\tafter: {\n\t\t\t\trender(this: Projector, result: VNode | string | null) {\n\t\t\t\t\tif (typeof result === 'string' || result === null) {\n\t\t\t\t\t\tthrow new Error('Must provide a VNode at the root of a projector');\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: Projector, options: ProjectorOptions = {}) {\n\t\t\tconst { root = document.body, cssTransitions = false } = options;\n\t\t\tconst maquetteProjectorOptions: { transitions?: any } = {};\n\n\t\t\tif (cssTransitions) {\n\t\t\t\tif (global.cssTransitions) {\n\t\t\t\t\tmaquetteProjectorOptions.transitions = global.cssTransitions;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinstance.own(instance.on('widget:children', instance.invalidate));\n\t\t\tinstance.own(instance.on('invalidated', scheduleRender));\n\n\t\t\tconst projector = createMaquetteProjector(maquetteProjectorOptions);\n\n\t\t\tprojectorDataMap.set(instance, {\n\t\t\t\tprojector,\n\t\t\t\troot,\n\t\t\t\tstate: ProjectorState.Detached\n\t\t\t});\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: {\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction(this: Projector): VNodeProperties {\n\t\t\t\t\tconst { afterCreate } = projectorDataMap.get(this);\n\t\t\t\t\treturn { afterCreate };\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createProjector;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/createProjector.ts","import { isComposeFactory } from 'dojo-compose/compose';\nimport createStateful from 'dojo-compose/bases/createStateful';\nimport {\n\tDNode,\n\tWNode,\n\tWidget,\n\tWidgetMixin,\n\tWidgetState,\n\tWidgetOptions,\n\tWidgetFactory,\n\tFactoryRegistryItem\n} from './interfaces';\nimport { VNode, VNodeProperties } from 'dojo-interfaces/vdom';\nimport { assign } from 'dojo-core/lang';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport Promise from 'dojo-shim/Promise';\nimport Map from 'dojo-shim/Map';\nimport { v, registry } from './d';\nimport FactoryRegistry from './FactoryRegistry';\nimport createVNodeEvented from './mixins/createVNodeEvented';\n\ninterface WidgetInternalState {\n\tchildren: DNode[];\n\treadonly id?: string;\n\tdirty: boolean;\n\twidgetClasses: string[];\n\tcachedVNode?: VNode | string;\n\tfactoryRegistry: FactoryRegistry;\n\tinitializedFactoryMap: Map<string, Promise<WidgetFactory>>;\n\thistoricChildrenMap: Map<string | Promise<WidgetFactory> | WidgetFactory, Widget<WidgetState>>;\n\tcurrentChildrenMap: Map<string | Promise<WidgetFactory> | WidgetFactory, Widget<WidgetState>>;\n};\n\n/**\n * Internal state map for widget instances\n */\nconst widgetInternalStateMap = new WeakMap<Widget<WidgetState>, WidgetInternalState>();\n\n/**\n * The counter for generating a unique ID\n */\nlet widgetCount = 0;\n\nfunction generateID(instance: Widget<WidgetState>): string {\n\tconst id = `widget-${++widgetCount}`;\n\tinstance.setState({ id });\n\treturn id;\n}\n\nfunction isWNode(child: DNode): child is WNode {\n\treturn Boolean(child && (<WNode> child).factory !== undefined);\n}\n\nfunction getFromRegistry(instance: Widget<WidgetState>, factoryLabel: string): FactoryRegistryItem | null {\n\tif (instance.registry.has(factoryLabel)) {\n\t\treturn instance.registry.get(factoryLabel);\n\t}\n\n\treturn registry.get(factoryLabel);\n}\n\nfunction dNodeToVNode(instance: Widget<WidgetState>, dNode: DNode): VNode | string | null {\n\tconst internalState = widgetInternalStateMap.get(instance);\n\n\tif (typeof dNode === 'string' || dNode === null) {\n\t\treturn dNode;\n\t}\n\n\tif (isWNode(dNode)) {\n\t\tconst { children, options: { id, state } } = dNode;\n\n\t\tlet { factory } = dNode;\n\t\tlet child: Widget<WidgetState>;\n\n\t\tif (typeof factory === 'string') {\n\t\t\tconst item = getFromRegistry(instance, factory);\n\n\t\t\tif (isComposeFactory(item)) {\n\t\t\t\tfactory = <WidgetFactory> item;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (item && !internalState.initializedFactoryMap.has(factory)) {\n\t\t\t\t\tconst promise = (<Promise<WidgetFactory>> item).then((factory) => {\n\t\t\t\t\t\tinstance.invalidate();\n\t\t\t\t\t\treturn factory;\n\t\t\t\t\t});\n\t\t\t\t\tinternalState.initializedFactoryMap.set(factory, promise);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tconst childrenMapKey = id || factory;\n\t\tconst cachedChild = internalState.historicChildrenMap.get(childrenMapKey);\n\n\t\tif (cachedChild) {\n\t\t\tchild = cachedChild;\n\t\t\tif (state) {\n\t\t\t\tchild.setState(state);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchild = factory(dNode.options);\n\t\t\tchild.own(child.on('invalidated', () => {\n\t\t\t\tinstance.invalidate();\n\t\t\t}));\n\t\t\tinternalState.historicChildrenMap.set(childrenMapKey, child);\n\t\t\tinstance.own(child);\n\t\t}\n\t\tif (!id && internalState.currentChildrenMap.has(factory)) {\n\t\t\tconst errorMsg = 'must provide unique keys when using the same widget factory multiple times';\n\t\t\tconsole.error(errorMsg);\n\t\t\tinstance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n\t\t}\n\n\t\tchild.children = children;\n\t\tinternalState.currentChildrenMap.set(childrenMapKey, child);\n\n\t\treturn child.render();\n\t}\n\n\tdNode.children = dNode.children\n\t\t.filter((child) => child !== null)\n\t\t.map((child: DNode) => {\n\t\t\treturn dNodeToVNode(instance, child);\n\t\t});\n\n\treturn dNode.render({ bind: instance });\n}\n\nfunction manageDetachedChildren(instance: Widget<WidgetState>): void {\n\tconst internalState = widgetInternalStateMap.get(instance);\n\n\tinternalState.historicChildrenMap.forEach((child, key) => {\n\t\tif (!internalState.currentChildrenMap.has(key)) {\n\t\t\tinternalState.historicChildrenMap.delete(key);\n\t\t\tchild.destroy();\n\t\t}\n\t});\n\tinternalState.currentChildrenMap.clear();\n}\n\nfunction formatTagNameAndClasses(tagName: string, classes: string[]) {\n\tif (classes.length) {\n\t\treturn `${tagName}.${classes.join('.')}`;\n\t}\n\treturn tagName;\n}\n\nconst createWidget: WidgetFactory = createStateful\n\t.mixin(createVNodeEvented)\n\t.mixin<WidgetMixin, WidgetOptions<WidgetState>>({\n\t\tmixin: {\n\t\t\tclasses: [],\n\n\t\t\tgetNode(): DNode {\n\t\t\t\tconst tag = formatTagNameAndClasses(this.tagName, this.classes);\n\t\t\t\treturn v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n\t\t\t},\n\n\t\t\tset children(this: Widget<WidgetState>, children: DNode[]) {\n\t\t\t\tconst internalState = widgetInternalStateMap.get(this);\n\t\t\t\tinternalState.children = children;\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'widget:children',\n\t\t\t\t\ttarget: this\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tget children() {\n\t\t\t\treturn widgetInternalStateMap.get(this).children;\n\t\t\t},\n\n\t\t\tgetChildrenNodes(this: Widget<WidgetState>): DNode[] {\n\t\t\t\treturn this.children;\n\t\t\t},\n\n\t\t\tgetNodeAttributes(this: Widget<WidgetState>, overrides?: VNodeProperties): VNodeProperties {\n\t\t\t\tconst props: VNodeProperties = {};\n\n\t\t\t\tthis.nodeAttributes.forEach((fn) => {\n\t\t\t\t\tconst newProps: VNodeProperties = fn.call(this);\n\t\t\t\t\tif (newProps) {\n\t\t\t\t\t\tassign(props, newProps);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn props;\n\t\t\t},\n\n\t\t\tinvalidate(this: Widget<WidgetState>): void {\n\t\t\t\tconst internalState = widgetInternalStateMap.get(this);\n\t\t\t\tinternalState.dirty = true;\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'invalidated',\n\t\t\t\t\ttarget: this\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tget id(this: Widget<WidgetState>): string {\n\t\t\t\tconst { id } = widgetInternalStateMap.get(this);\n\n\t\t\t\treturn id || (this.state && this.state.id) || generateID(this);\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: Widget<WidgetState>): VNodeProperties {\n\t\t\t\t\tconst baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n\t\t\t\t\tconst { styles = {} } = this.state;\n\t\t\t\t\tconst classes: { [index: string]: boolean; } = {};\n\n\t\t\t\t\tconst internalState = widgetInternalStateMap.get(this);\n\n\t\t\t\t\tinternalState.widgetClasses.forEach((c) => classes[c] = false);\n\n\t\t\t\t\tif (this.state && this.state.classes) {\n\t\t\t\t\t\tthis.state.classes.forEach((c) => classes[c] = true);\n\t\t\t\t\t\tinternalState.widgetClasses =  this.state.classes;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn assign(baseIdProp, { key: this, classes, styles });\n\t\t\t\t}\n\n\t\t\t],\n\n\t\t\trender(this: Widget<WidgetState>): VNode | string | null {\n\t\t\t\tconst internalState = widgetInternalStateMap.get(this);\n\t\t\t\tif (internalState.dirty || !internalState.cachedVNode) {\n\t\t\t\t\tconst widget = dNodeToVNode(this, this.getNode());\n\t\t\t\t\tmanageDetachedChildren(this);\n\t\t\t\t\tif (widget) {\n\t\t\t\t\t\tinternalState.cachedVNode = widget;\n\t\t\t\t\t}\n\t\t\t\t\tinternalState.dirty = false;\n\t\t\t\t\treturn widget;\n\t\t\t\t}\n\t\t\t\treturn internalState.cachedVNode;\n\t\t\t},\n\n\t\t\tget registry(this: Widget<WidgetState>): FactoryRegistry {\n\t\t\t\treturn widgetInternalStateMap.get(this).factoryRegistry;\n\t\t\t},\n\n\t\t\ttagName: 'div'\n\t\t},\n\t\tinitialize(instance: Widget<WidgetState>, options: WidgetOptions<WidgetState> = {}) {\n\t\t\tconst { id, tagName } = options;\n\t\t\tinstance.tagName = tagName || instance.tagName;\n\n\t\t\twidgetInternalStateMap.set(instance, {\n\t\t\t\tid,\n\t\t\t\tdirty: true,\n\t\t\t\twidgetClasses: [],\n\t\t\t\tfactoryRegistry: new FactoryRegistry(),\n\t\t\t\tinitializedFactoryMap: new Map<string, Promise<WidgetFactory>>(),\n\t\t\t\thistoricChildrenMap: new Map<string | Promise<WidgetFactory> | WidgetFactory, Widget<WidgetState>>(),\n\t\t\t\tcurrentChildrenMap: new Map<string | Promise<WidgetFactory> | WidgetFactory, Widget<WidgetState>>(),\n\t\t\t\tchildren: []\n\t\t\t});\n\n\t\t\tinstance.own(instance.on('state:changed', () => {\n\t\t\t\tinstance.invalidate();\n\t\t\t}));\n\t\t}\n\t});\n\nexport default createWidget;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/createWidgetBase.ts","import { deepAssign } from 'dojo-core/lang';\nimport { Handle } from 'dojo-interfaces/core';\nimport {\n\tEvented,\n\tStateful,\n\tState,\n\tStatefulOptions,\n\tStatefulMixin\n} from 'dojo-interfaces/bases';\nimport { Observable, Subscription } from 'dojo-interfaces/observables';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport createEvented from './createEvented';\nimport { ComposeFactory } from '../compose';\nimport createCancelableEvent from './createCancelableEvent';\n\nexport interface ObservableState<S extends State> {\n\t/**\n\t * A method that allows the return of an `Observable` interface for a particular `id`\n\t * @param id The ID to observe\n\t */\n\tobserve(id: string): Observable<S>;\n\n\t/**\n\t * A method that allows the `Stateful` to provide a change to its state, instead of\n\t * changing its state directly.\n\t * @param partial The partial state to be *patched*\n\t * @param options A map of options, which includes the `id` being observed\n\t */\n\tpatch(partial: any, options?: { id?: string }): Promise<S>;\n}\n\nexport interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {\n\t<S extends State>(options?: StatefulOptions<S>): Stateful<S>;\n}\n\n/**\n * Internal interface which contains references to an observed state\n */\ninterface ObservedState {\n\tid: string;\n\tobservable: ObservableState<State>;\n\tsubscription: Subscription;\n\thandle: Handle;\n}\n\n/**\n * A weak map of stateful instances to their obseved state references\n */\nconst observedStateMap = new WeakMap<Stateful<State>, ObservedState>();\n\n/**\n * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n * cancelled.\n *\n * @param stateful The `Stateful` object to unobserve\n */\nfunction completeStatefulState(stateful: Stateful<State>): void {\n\tconst observedState = observedStateMap.get(stateful);\n\tif (observedState) {\n\t\tobservedState.handle.destroy();\n\t\tconst statecomplete = createCancelableEvent({\n\t\t\ttype: 'state:completed',\n\t\t\ttarget: stateful\n\t\t});\n\t\tstateful.emit(statecomplete);\n\t\tif (!statecomplete.defaultPrevented) {\n\t\t\tstateful.destroy();\n\t\t}\n\t}\n}\n\n/**\n * Internal function that actually applies the state to the Stateful's state and\n * emits the `statechange` event.\n *\n * @param stateful The Stateful instance\n * @param state The State to be set\n */\nfunction setStatefulState(target: Stateful<State>, state: State): void {\n\tconst previousState = stateWeakMap.get(target);\n\tif (!previousState) {\n\t\tthrow new Error('Unable to set destroyed state');\n\t}\n\tconst type = 'state:changed';\n\tstate = deepAssign(previousState, state);\n\tconst eventObject = {\n\t\ttype,\n\t\tstate,\n\t\ttarget\n\t};\n\ttarget.emit(eventObject);\n}\n\n/**\n * A weak map that contains the stateful's state\n */\nconst stateWeakMap = new WeakMap<Stateful<State>, State>();\n\n/**\n * Create an instance of a stateful object\n */\nconst createStateful: StatefulFactory = createEvented\n\t.mixin({\n\t\tclassName: 'Stateful',\n\t\tmixin: {\n\t\t\tget stateFrom(this: Stateful<State>): ObservableState<State> | undefined {\n\t\t\t\tconst observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\treturn observedState.observable;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget state(this: Stateful<State>): State {\n\t\t\t\treturn stateWeakMap.get(this);\n\t\t\t},\n\n\t\t\tsetState(this: Stateful<State>, value: State): void {\n\t\t\t\tconst observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tobservedState.observable.patch(value, { id: observedState.id });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsetStatefulState(this, value);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tobserveState(this: Stateful<State>, id: string, observable: ObservableState<State>): Handle {\n\t\t\t\tlet observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tif (observedState.id === id && observedState.observable === observable) {\n\t\t\t\t\t\treturn observedState.handle;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Already observing state with ID '${observedState.id}'`);\n\t\t\t\t}\n\t\t\t\tconst stateful = this;\n\t\t\t\tconst handle = {\n\t\t\t\t\tdestroy() {\n\t\t\t\t\t\tconst observedState = observedStateMap.get(stateful);\n\t\t\t\t\t\tif (observedState) {\n\t\t\t\t\t\t\tobservedState.subscription.unsubscribe();\n\t\t\t\t\t\t\tobservedStateMap.delete(stateful);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst subscription = observable\n\t\t\t\t\t.observe(id)\n\t\t\t\t\t.subscribe(\n\t\t\t\t\t\t(state) => {\n\t\t\t\t\t\t\tsetStatefulState(stateful, state);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tcompleteStatefulState(stateful);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\tobservedStateMap.set(stateful, { id, observable, subscription, handle });\n\t\t\t\treturn handle;\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: StatefulMixin<State> & Evented, options: StatefulOptions<State>) {\n\t\t\tstateWeakMap.set(instance, Object.create(null));\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tstateWeakMap.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\tconst { id, stateFrom, state } = options;\n\t\t\t\tif (typeof id !== 'undefined' && stateFrom) {\n\t\t\t\t\tinstance.own(instance.observeState(id, stateFrom));\n\t\t\t\t}\n\t\t\t\telse if (stateFrom) {\n\t\t\t\t\tthrow new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t\t\t\t}\n\t\t\t\tif (state) {\n\t\t\t\t\tinstance.setState(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createStateful;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/bases/createStateful.ts","import { on } from 'dojo-core/aspect';\nimport {\n\tEventObject,\n\tEventTargettedObject,\n\tHandle\n} from 'dojo-interfaces/core';\nimport {\n\tEvented,\n\tEventedOptions,\n\tEventedListener,\n\tEventedListenerOrArray,\n\tEventedListenersMap,\n\tEventedCallback\n} from 'dojo-interfaces/bases';\nimport { Actionable } from 'dojo-interfaces/abilities';\nimport Map from 'dojo-shim/Map';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { ComposeFactory } from '../compose';\nimport createDestroyable from './createDestroyable';\n\n/**\n * A map of callbacks where the key is the event `type`\n */\ntype EventedCallbackMap = Map<string, EventedCallback<EventObject>>;\n\nexport interface EventedFactory extends ComposeFactory<Evented, EventedOptions> { }\n\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nconst listenersMap = new WeakMap<Evented, EventedCallbackMap>();\n\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable(value: any): value is Actionable<any, any> {\n\treturn Boolean(value && typeof value.do === 'function');\n}\n\n/**\n * An internal function that always returns an EventedCallback\n *\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nexport function resolveListener<T, E extends EventTargettedObject<T>>(listener: EventedListener<T, E>): EventedCallback<E> {\n\treturn isActionable(listener) ? (event: E) => listener.do({ event }) : listener;\n}\n\n/**\n * Internal function to convert an array of handles to a single handle\n *\n * @param handles The array of handles to convert into a signle handle\n * @return The single handle\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * Creates a new instance of an `Evented`\n */\nconst createEvented: EventedFactory = createDestroyable\n\t.mixin({\n\t\tclassName: 'Evented',\n\t\tmixin: {\n\t\t\temit<E extends EventObject>(this: Evented, event: E): void {\n\t\t\t\tconst method = listenersMap.get(this).get(event.type);\n\t\t\t\tif (method) {\n\t\t\t\t\tmethod.call(this, event);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ton(this: Evented, ...args: any[]): Handle {\n\t\t\t\tconst listenerMap = listenersMap.get(this);\n\t\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\t\tconst [ type, listeners ] = <[ string, EventedListenerOrArray<any, EventTargettedObject<any>>]> args;\n\t\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\t\tconst handles = listeners.map((listener) => on(listenerMap, type, resolveListener(listener)));\n\t\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn on(listenerMap, type, resolveListener(listeners));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\t\tconst [ listenerMapArg ] = <[EventedListenersMap<any>]> args;\n\t\t\t\t\tconst handles = Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type]));\n\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t}\n\t\t\t\telse { /* unexpected signature */\n\t\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: Evented, options: EventedOptions) {\n\t\t\tlistenersMap.set(instance, new Map<string, EventedCallback<EventObject>>());\n\t\t\tif (options && options.listeners) {\n\t\t\t\tinstance.own(instance.on(options.listeners));\n\t\t\t}\n\t\t}\n\t});\n\nexport default createEvented;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/bases/createEvented.ts","import { EventTargettedObject, EventObject, Handle } from 'dojo-interfaces/core';\nimport { on } from 'dojo-core/aspect';\nimport { assign } from 'dojo-core/lang';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, { resolveListener } from 'dojo-compose/bases/createEvented';\nimport {\n\tEvented,\n\tEventedOptions,\n\tEventedListenerOrArray,\n\tEventedListenersMap\n} from 'dojo-interfaces/bases';\nimport Set from 'dojo-shim/Set';\nimport { VNodeProperties } from 'dojo-interfaces/vdom';\nimport { NodeAttributeFunction } from './../interfaces';\n\nexport type VNodeListenerReturn = boolean | undefined | null;\n\nexport interface VNodeListeners {\n\t[on: string]: undefined | ((ev?: EventTargettedObject<any>) => VNodeListenerReturn);\n\tontouchcancel?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchend?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchmove?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchstart?(ev?: TouchEvent): VNodeListenerReturn;\n\tonblur?(ev?: FocusEvent): VNodeListenerReturn;\n\tonchange?(ev?: Event): VNodeListenerReturn;\n\tonclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tondblclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tonfocus?(ev?: FocusEvent): VNodeListenerReturn;\n\toninput?(ev?: Event): VNodeListenerReturn;\n\tonkeydown?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeypress?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeyup?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonload?(ev?: Event): VNodeListenerReturn;\n\tonmousedown?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseenter?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseleave?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousemove?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseout?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseover?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseup?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousewheel?(ev?: MouseWheelEvent): VNodeListenerReturn;\n\tonscroll?(ev?: UIEvent): VNodeListenerReturn;\n\tonsubmit?(ev?: Event): VNodeListenerReturn;\n}\n\nconst vnodeEvents = new Set([\n\t'touchcancel',\n\t'touchend',\n\t'touchmove',\n\t'touchstart',\n\t'blur',\n\t'change',\n\t'click',\n\t'dblclick',\n\t'focus',\n\t'input',\n\t'keydown',\n\t'keypress',\n\t'keyup',\n\t'load',\n\t'mousedown',\n\t'mouseenter',\n\t'mouseleave',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'mousewheel',\n\t'scroll',\n\t'submit'\n]);\n\nexport interface VNodeEventedMixin {\n\t/**\n\t * A map of listeners that are exposed for use by the virutal DOM\n\t */\n\tlisteners: VNodeListeners;\n\n\t/**\n\t * An array of functions the provide the VNode attributes when rendering\n\t */\n\tnodeAttributes: NodeAttributeFunction[];\n}\n\nexport interface VNodeEventedOverrides {\n\ton(type: 'touchcancel', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'touchend', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'touchmove', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'blur', listener: EventedListenerOrArray<EventTarget, FocusEvent>): Handle;\n\ton(type: 'change', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'click', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'dblclick', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'focus', listener: EventedListenerOrArray<EventTarget, FocusEvent>): Handle;\n\ton(type: 'input', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'keydown', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'keypress', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'keyup', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'load', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'mousedown', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseenter', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseleave', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mousemove', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseout', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseover', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseup', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mousewheel', listener: EventedListenerOrArray<EventTarget, MouseWheelEvent>): Handle;\n\ton(type: 'scroll', listener: EventedListenerOrArray<EventTarget, UIEvent>): Handle;\n\ton(type: 'submit', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n}\n\nexport type VNodeEvented = Evented & VNodeEventedMixin & VNodeEventedOverrides;\n\nexport type VNodeEventedOptions = EventedOptions;\n\nexport interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, VNodeEventedOptions> { }\n\n/**\n * Internal function to convert an array of handles to a single array\n *\n * TODO: This is used in a couple places, maybe should migrate to a better place\n *\n * @params handles An array of handles\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\nconst UNINITIALIZED_LISTENERS = Object.freeze({});\n\nconst createVNodeEvented: VNodeEventedFactory = createEvented\n\t.mixin({\n\t\tmixin: {\n\t\t\tlisteners: UNINITIALIZED_LISTENERS,\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: any): VNodeProperties {\n\t\t\t\t\treturn assign({}, this.listeners);\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\taspectAdvice: {\n\t\t\taround: {\n\t\t\t\ton(origFn): (...args: any[]) => Handle {\n\t\t\t\t\treturn function (this: VNodeEvented, ...args: any[]): Handle {\n\t\t\t\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\t\t\t\t/* During initialization, sometimes the initialize functions occur out of order,\n\t\t\t\t\t\t\t* and Evented's initialize function could be called before this mixins, therefore\n\t\t\t\t\t\t\t* leaving this.listeners with an uninitiliazed value, therefore it is better to\n\t\t\t\t\t\t\t* determine if the value is unitialized here, ensuring that this.listeners is\n\t\t\t\t\t\t\t* always valid.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif (this.listeners === UNINITIALIZED_LISTENERS) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet type: string;\n\t\t\t\t\t\t\tlet listeners: EventedListenerOrArray<VNodeEvented, EventTargettedObject<any>>;\n\t\t\t\t\t\t\t[ type, listeners ] = args;\n\t\t\t\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\t\t\t\tconst handles = listeners.map((listener) => vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listener)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listener));\n\t\t\t\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listeners)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listeners);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\t\t\t\tconst listenerMapArg: EventedListenersMap<any> = args[0];\n\t\t\t\t\t\t\treturn handlesArraytoHandle(Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { /* unexpected signature */\n\t\t\t\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\temit(origFn): <T extends EventObject>(event: T) => void {\n\t\t\t\t\treturn function <T extends EventObject>(this: VNodeEvented, event: T): void {\n\t\t\t\t\t\tif (vnodeEvents.has(event.type)) {\n\t\t\t\t\t\t\tif (this.listeners === null) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst method = this.listeners['on' + event.type];\n\t\t\t\t\t\t\tif (method) {\n\t\t\t\t\t\t\t\tmethod.call(this, event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\torigFn.call(this, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createVNodeEvented;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/mixins/createVNodeEvented.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, IterableIterator, Iterable, ShimIterator } from './iterator';\nimport './Symbol';\n\nexport namespace Shim {\n\texport class Set<T> {\n\t\tprivate readonly _setData: T[] = [];\n\n\t\tconstructor(iterable?: ArrayLike<T> | Iterable<T>) {\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, (value) => this.add(value));\n\t\t\t}\n\t\t};\n\n\t\tadd(value: T): this {\n\t\t\tif (this.has(value)) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._setData.push(value);\n\t\t\treturn this;\n\t\t};\n\n\t\tclear(): void {\n\t\t\tthis._setData.length = 0;\n\t\t};\n\n\t\tdelete(value: T): boolean {\n\t\t\tconst idx = this._setData.indexOf(value);\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._setData.splice(idx, 1);\n\t\t\treturn true;\n\t\t};\n\n\t\tentries(): IterableIterator<[T, T]> {\n\t\t\treturn new ShimIterator<[any, any]>(this._setData.map<[any, any]>((value) => [ value, value ]));\n\t\t};\n\n\t\tforEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void {\n\t\t\tconst iterator = this.values();\n\t\t\tlet result = iterator.next();\n\t\t\twhile (!result.done) {\n\t\t\t\tcallbackfn.call(thisArg, result.value, result.value, this);\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t};\n\n\t\thas(value: T): boolean {\n\t\t\treturn this._setData.indexOf(value) > -1;\n\t\t};\n\n\t\tkeys(): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\tget size(): number {\n\t\t\treturn this._setData.length;\n\t\t};\n\n\t\tvalues(): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\t[Symbol.iterator](): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\t[Symbol.toStringTag]: string = 'Set';\n\t}\n}\n\n@hasClass('es6-set', global.Set, Shim.Set)\nexport default class Set<T> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<T> | Iterable<T>) { };\n\n\t/* istanbul ignore next */\n\tadd(value: T): this { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tclear(): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tdelete(value: T): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tentries(): IterableIterator<[T, T]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tforEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\thas(value: T): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tkeys(): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tget size(): number { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tvalues(): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.iterator](): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'Set';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Set.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { v, w } from 'dojo-widgets/d';\nimport createSearchInput from '../common/createSearchInput';\n\nexport type NavBarState = WidgetState & {\n\tsections: NavBarLinkDefinition[];\n}\n\nexport type NavBar = Widget<NavBarState>\n\nexport type NavBarLinkDefinition = {\n\ttext: string;\n\thref: string;\n}\n\nlet counter = 0;\n\nfunction listItem(childNode: DNode, key?: any): DNode {\n\tconst options = key ? { key } : {};\n\treturn v('li', options, [ childNode ]);\n}\n\nfunction createNavBarLink({ text: innerHTML, href }: NavBarLinkDefinition): DNode {\n\treturn listItem(v('a', { key: counter++, href, innerHTML }), innerHTML);\n}\n\nconst createNavbar = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'header',\n\t\tclasses: [ 'navbar' ],\n\t\tgetChildrenNodes: function(this: NavBar): DNode[] {\n\t\t\tconst { state } = this;\n\t\t\tconst isReady = Object.keys(state).length > 0;\n\n\t\t\tconst homeLink = listItem(v('a', { href: '#' }, [\n\t\t\t\tv('img', { src: 'images/navbar-app-icon.png' })\n\t\t\t]));\n\t\t\tconst sectionLinks = isReady ? this.state.sections.map(createNavBarLink) : [ v('li', { key: 'dummy' }) ];\n\t\t\tconst searchAction = listItem(w(createSearchInput, {}));\n\t\t\tconst favouriteAction = listItem(v('i.fa.fa-2x.fa-heart-o'));\n\n\t\t\tconst pageLinks = v('ul.inline-list', {}, [ homeLink, ...sectionLinks ]);\n\t\t\tconst actionLinks = v('ul.inline-list.pull-right', {}, [ searchAction, favouriteAction ]);\n\n\t\t\treturn [ pageLinks, actionLinks ];\n\t\t}\n\t}\n});\n\nexport default createNavbar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/navbar/createNavbar.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { v } from 'dojo-widgets/d';\n\nexport type SearchInput = Widget<WidgetState>\n\nconst createSearchInput = createWidgetBase.mixin({\n\tmixin: {\n\t\tgetChildrenNodes: function(this: SearchInput): DNode[] {\n\t\t\tconst input = v('input', { type: 'search' });\n\t\t\tconst icon = v('i.fa.fa-2x.fa-search');\n\n\t\t\treturn [ input, icon ];\n\t\t}\n\t}\n});\n\nexport default createSearchInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/common/createSearchInput.ts","import { Widget, DNode } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport { v } from 'dojo-widgets/d';\n\nexport type HomePageState = {}\nexport type HomePage = Widget<HomePageState>\n\nconst createHomePage = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'pageHolder', 'home' ],\n\t\t\tgetChildrenNodes: function(this: HomePage): DNode[] {\n\t\t\t\tconst mmLogo = v('img', { src: './images/mm_logo.png' });\n\t\t\t\tconst jumbotron = v('div.jumbotron', {}, [ mmLogo ]);\n\n\t\t\t\treturn [ jumbotron ];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createHomePage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/home/createHomePage.ts","import { VNodeProperties } from 'dojo-interfaces/vdom';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport { NodeAttributeFunction } from './../interfaces';\nimport createStateful from 'dojo-compose/bases/createStateful';\nimport { State, Stateful, StatefulOptions } from 'dojo-interfaces/bases';\n\nexport type CssTransitionMixinState = State & {\n\t/**\n\t * The class of the CSS animation to be applied as the widget enters the dom\n\t */\n\tenterAnimation?: string;\n\n\t/**\n\t * The class of the CSS animation to be applied as the widget exits the dom\n\t */\n\texitAnimation?: string;\n}\n\nexport interface CssTransition {\n\t/**\n\t * An array of node attribute functions which return additional attributes that should be mixed into\n\t * the final VNode during a render call\n\t */\n\tnodeAttributes: NodeAttributeFunction[];\n}\n\nexport type CssTransitionMixin<S extends CssTransitionMixinState> = CssTransition & Stateful<S>;\n\nexport interface CssTransitionMixinFactory extends ComposeFactory<CssTransitionMixin<CssTransitionMixinState>, StatefulOptions<CssTransitionMixinState>> {};\n\nconst createCssTransitionMixin: CssTransitionMixinFactory = compose({\n\t\tnodeAttributes: [\n\t\t\tfunction (this: CssTransitionMixin<CssTransitionMixinState>): VNodeProperties {\n\t\t\t\tconst { enterAnimation, exitAnimation } = this.state;\n\t\t\t\treturn { enterAnimation, exitAnimation };\n\t\t\t}\n\t\t]\n\t})\n\t.mixin(createStateful);\n\nexport default createCssTransitionMixin;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-widgets/mixins/createCssTransitionMixin.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport { CardState } from '../card/createCard';\nimport createCardDescription, { CardDescriptionState } from './createCardDescription';\nimport createCardNavBar from './createCardNavBar';\nimport createSeenWith from './createSeenWith';\nimport { v, w } from 'dojo-widgets/d';\nimport { assign } from 'dojo-core/lang';\n\nexport type CardDetailsPageState = WidgetState & {\n\tcards: CardState[];\n\tcardDescription: CardDescriptionState;\n\tseenWith: CardState[];\n}\nexport type CardDetailsPage = Widget<CardDetailsPageState>\n\nconst createCardDetailsPage = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'pageHolder', 'cardDetails' ],\n\t\t\tgetChildrenNodes: function(this: CardDetailsPage): DNode[] {\n\t\t\t\tconst { cards, cardDescription, seenWith } = this.state;\n\n\t\t\t\tconst cardNavBar = w(createCardNavBar, { state: { cards }});\n\n\t\t\t\tconst descriptionState = assign({\n\t\t\t\t\tenterAnimation: 'slideInRight',\n\t\t\t\t\texitAnimation: 'slideOutLeft'\n\t\t\t\t}, cardDescription);\n\n\t\t\t\tconst cardDescriptionView = cardDescription ? w(createCardDescription, {\n\t\t\t\t\tid: `card-details-description-${cardDescription.id}`,\n\t\t\t\t\tstate: descriptionState\n\t\t\t\t}) : null;\n\n\t\t\t\tconst jumbotron = v('div.jumbotron', {} , [ cardDescriptionView ]);\n\n\t\t\t\tconst seenWithView = w(createSeenWith, { state: { cards: seenWith }});\n\n\t\t\t\treturn [ cardNavBar, jumbotron, seenWithView ];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCardDetailsPage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card-details/createCardDetailsPage.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { v } from 'dojo-widgets/d';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\n\nexport type CardDescriptionState = WidgetState & {\n\tname: string;\n\ttagline: string;\n\tdescription: string;\n\timageClass: string;\n\tfavouriteCount: number;\n\tid: string;\n}\n\nexport type CardDescription = Widget<CardDescriptionState>;\n\nexport type ShareButtonConfig = {\n\ticonClass: string;\n\thref?: string;\n\ttext?: string;\n}\n\nfunction createButtonLink({ iconClass, href, text: innerHTML }: ShareButtonConfig): DNode {\n\tconst icon = v(`i.fa.${iconClass}`);\n\tconst buttonText = innerHTML ? v('span', { innerHTML }) : null;\n\n\treturn v('a.button', { href }, [ icon, buttonText ]);\n}\n\nconst shareButtonConfig: ShareButtonConfig[] = [\n\t{ href: '', iconClass: 'fa-heart-o', text: 'Add to favourites' },\n\t{ href: 'http://www.twitter.com', iconClass: 'fa-twitter' },\n\t{ href: 'https://facebook.com', iconClass: 'fa-facebook' }\n];\n\nconst createCardDescription = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'cardDescription' ],\n\t\t\tgetChildrenNodes: function(this: CardDescription): DNode[] {\n\t\t\t\tconst { imageClass, name, tagline, description, favouriteCount } = this.state;\n\n\t\t\t\tconst cardImage = v(`div.cardImage.card-sprite-large.${imageClass}`);\n\t\t\t\tconst cardName = v('h1', { innerHTML: name });\n\t\t\t\tconst cardTagline = v('strong.tagline', { innerHTML: tagline });\n\t\t\t\tconst cardDescription = v('p', { innerHTML: description });\n\t\t\t\tconst cardFavouriteCount = v('span', { innerHTML: `Favourited: ${favouriteCount}` });\n\t\t\t\tconst shareButtons = v('div.buttonHolder', {}, shareButtonConfig.map(createButtonLink));\n\n\t\t\t\treturn [\n\t\t\t\t\tcardImage,\n\t\t\t\t\tv('article', {}, [\n\t\t\t\t\t\tcardName,\n\t\t\t\t\t\tcardTagline,\n\t\t\t\t\t\tcardDescription,\n\t\t\t\t\t\tcardFavouriteCount,\n\t\t\t\t\t\tshareButtons\n\t\t\t\t\t])\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCardDescription;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card-details/createCardDescription.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { w } from 'dojo-widgets/d';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport createCard, { CardState } from '../card/createCard';\n\nexport type CardNavBarState = WidgetState & {\n\tcards: CardState[];\n}\n\nexport type CardNavBar = Widget<CardNavBarState>;\n\nconst createCardNavBar = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'cardNavBar' ],\n\t\t\tgetChildrenNodes: function(this: CardNavBar): DNode[] {\n\t\t\t\tconst { cards = [] } = this.state;\n\n\t\t\t\tconst cardNodes = cards.map((state) => {\n\t\t\t\t\treturn w(createCard, { id: `card-details-nav-bar-${state.id}`, state });\n\t\t\t\t});\n\n\t\t\t\treturn cardNodes;\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCardNavBar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card-details/createCardNavBar.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { v } from 'dojo-widgets/d';\nimport { VNodeProperties } from 'maquette';\n\nexport type CardState = WidgetState & {\n\timageClass: string;\n\tid: string;\n\tlarge?: boolean;\n}\n\nexport type Card = Widget<CardState>;\n\nconst createCard = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'a',\n\t\tclasses: [ 'milestoneCard' ],\n\t\tnodeAttributes: [\n\t\t\tfunction (this: Card): VNodeProperties {\n\t\t\t\treturn {\n\t\t\t\t\thref: `#/cards/${this.state.id}`\n\t\t\t\t};\n\t\t\t}\n\t\t],\n\t\tgetChildrenNodes: function(this: Card): DNode[] {\n\t\t\tconst baseImageClass = this.state.large ? 'card-sprite-large' : 'card-sprite-small';\n\n\t\t\treturn [ v(`div.${baseImageClass}.${this.state.imageClass}`) ];\n\t\t}\n\t}\n});\n\nexport default createCard;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card/createCard.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { w, v } from 'dojo-widgets/d';\nimport createCard, { CardState } from '../card/createCard';\nimport { assign } from 'dojo-core/lang';\n\nexport type SeenWithState = WidgetState & {\n\tcards: CardState[];\n}\n\nexport type SeenWith = Widget<SeenWithState>;\n\nconst createSeenWith = createWidgetBase.mixin({\n\tmixin: {\n\t\tclasses: [ 'seenWith' ],\n\t\tgetChildrenNodes: function(this: SeenWith): DNode[] {\n\t\t\tconst { cards = [] } = this.state;\n\n\t\t\tconst cardNodes = cards.map((card) => {\n\t\t\t\tconst state = assign({ large: true }, card);\n\t\t\t\treturn w(createCard, { id: `card-details-seen-with-${state.id}`, state });\n\t\t\t});\n\n\t\t\treturn [\n\t\t\t\tv('h2', { innerHTML: 'last seen with'}),\n\t\t\t\t...cardNodes\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createSeenWith;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card-details/createSeenWith.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport createCardsList from './createCardsList';\nimport { CardSummaryState } from '../card/createCardSummary';\nimport { v, w } from 'dojo-widgets/d';\n\nexport type CardsPageState = WidgetState & {\n\tcards: CardSummaryState[];\n}\nexport type CardsPage = Widget<CardsPageState>\n\nconst createCardsPage = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'pageHolder', 'cards' ],\n\t\t\tgetChildrenNodes: function(this: CardsPage): DNode[] {\n\t\t\t\tconst jumbotron = v('div.jumbotron');\n\t\t\t\tconst cardsList = w(createCardsList, { state: this.state });\n\n\t\t\t\treturn [ jumbotron, cardsList ];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCardsPage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/cards/createCardsPage.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { w } from 'dojo-widgets/d';\nimport createCardSummary, { CardSummaryState } from '../card/createCardSummary';\n\nexport type CardListState = WidgetState & {\n\tcards: CardSummaryState[];\n}\n\nexport type CardList = Widget<CardListState>;\n\nconst createCardList = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'cardList' ],\n\t\t\tgetChildrenNodes: function(this: CardList): DNode[] {\n\t\t\t\tconst { cards = [] } = this.state;\n\n\t\t\t\treturn cards.map((state) => {\n\t\t\t\t\treturn w(createCardSummary, { id: `card-list-summary-${state.id}`, state });\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCardList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/cards/createCardsList.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport { v, w } from 'dojo-widgets/d';\nimport createCard from './createCard';\n\nexport type CardSummaryState = WidgetState & {\n\tname: string;\n\timageClass: string;\n\tscore: number;\n\tid: string;\n}\n\nexport type CardSummary = Widget<CardSummaryState>\n\nconst createCardSummary = createWidgetBase.mixin({\n\tmixin: {\n\t\tclasses: [ 'cardSummary' ],\n\t\tgetChildrenNodes: function(this: CardSummary): DNode[] {\n\t\t\tconst { id, imageClass, name, score } = this.state;\n\n\t\t\tconst cardImage = w(createCard, { state: { id, imageClass, large: true } });\n\t\t\tconst cardName = v('h2', { innerHTML: name });\n\t\t\tconst cardPoints = v('p.points', { innerHTML: `milestone points: ${score}` });\n\n\t\t\treturn [\n\t\t\t\tcardImage,\n\t\t\t\tcardName,\n\t\t\t\tcardPoints\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createCardSummary;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/card/createCardSummary.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport { v } from 'dojo-widgets/d';\n\nexport type GameplayPage = Widget<WidgetState>\n\nconst createGameplayPage = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'pageHolder', 'gameplay' ],\n\t\t\tgetChildrenNodes: function(this: GameplayPage): DNode[] {\n\t\t\t\tconst heading = v('h1', { innerHTML: 'Gameplay' });\n\t\t\t\tconst jumbotron = v('div.jumbotron', {}, [ heading ]);\n\n\t\t\t\treturn [ jumbotron ];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createGameplayPage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/gameplay/createGameplayPage.ts","import { Widget, DNode, WidgetState } from 'dojo-widgets/interfaces';\nimport createWidgetBase from 'dojo-widgets/createWidgetBase';\nimport createCssTransitionMixin from 'dojo-widgets/mixins/createCssTransitionMixin';\nimport { v } from 'dojo-widgets/d';\n\nexport type AboutPage = Widget<WidgetState>\n\nconst createAboutPage = createWidgetBase\n\t.mixin(createCssTransitionMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'animated', 'pageHolder', 'about' ],\n\t\t\tgetChildrenNodes: function(this: AboutPage): DNode[] {\n\t\t\t\tconst heading = v('h1', { innerHTML: 'About' });\n\t\t\t\tconst jumbotron = v('div.jumbotron', {}, [ heading ]);\n\n\t\t\t\treturn [ jumbotron ];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createAboutPage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/about/createAboutPage.ts","(function (global) {\n\n  \"use strict\";\n\n  var browserSpecificTransitionEndEventName = null;\n\n  var determineBrowserSpecificStyleNames = function (element) {\n    if (\"WebkitTransition\" in element.style) {\n      browserSpecificTransitionEndEventName = \"webkitTransitionEnd\";\n    } else if (\"transition\" in element.style) {\n      browserSpecificTransitionEndEventName = \"transitionend\";\n    } else if (\"MozTransition\" in element.style) {\n      browserSpecificTransitionEndEventName = \"transitionend\";\n    } else {\n      throw new Error(\"Your browser is not supported\");\n    }\n  };\n\n  var init = function (testElement) {\n    if (browserSpecificTransitionEndEventName === null) {\n      determineBrowserSpecificStyleNames(testElement);\n    }\n  };\n\n  var cssTransitions = {\n    exit: function (node, properties, exitAnimation, removeNode) {\n      init(node);\n      var finished = false;\n      var transitionEnd = function (evt) {\n        if (!finished) {\n          finished = true;\n          node.removeEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n          removeNode();\n        }\n      };\n      node.classList.add(exitAnimation);\n      node.addEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n      requestAnimationFrame(function () {\n        node.classList.add(exitAnimation + \"-active\");\n      });\n    },\n    enter: function (node, properties, enterAnimation) {\n      init(node);\n      var finished = false;\n      var transitionEnd = function (evt) {\n        if (!finished) {\n          finished = true;\n          node.removeEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n          node.classList.remove(enterAnimation);\n          node.classList.remove(enterAnimation + \"-active\");\n        }\n      };\n      node.classList.add(enterAnimation);\n      node.addEventListener(browserSpecificTransitionEndEventName, transitionEnd);\n      requestAnimationFrame(function () {\n        node.classList.add(enterAnimation + \"-active\");\n      });\n    }\n  };\n\n  if (global.module !== undefined && global.module.exports) {\n    // Node and other CommonJS-like environments that support module.exports\n    global.module.exports = cssTransitions;\n  } else if (typeof global.define == 'function' && global.define.amd) {\n    // AMD / RequireJS\n    global.define(function () {\n      return cssTransitions;\n    });\n  }\n  if (window) {\n    // Browser\n    window.cssTransitions = cssTransitions;\n  }\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/maquette/src/css-transitions.js\n// module id = 100\n// module chunks = 0"],"sourceRoot":""}